# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/rdb.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literate programming approach used applying the R Markdown format.

# rdb: Download Data from the Referendum Database (RDB), Which Covers Direct Democratic Votes Worldwide
# Copyright (C) 2024 Centre for Democracy Studies Aarau (ZDA)
# 
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

utils::globalVariables(names = c(".",
                                 # tidyselect fns
                                 "all_of",
                                 "any_of",
                                 "ends_with",
                                 "everything",
                                 "matches",
                                 "starts_with",
                                 "where",
                                 # other
                                 "alias",
                                 "alpha_2",
                                 "alpha_2_old",
                                 "alpha_3",
                                 "alpha_4",
                                 "applicability_constraint",
                                 "archive",
                                 "attachments",
                                 "child_table",
                                 "children_tier_1",
                                 "children_tier_2",
                                 "children_tier_3",
                                 "code",
                                 "column_default",
                                 "column_name",
                                 "committee_name",
                                 "content-disposition",
                                 "count",
                                 "country_code",
                                 "country_code_long",
                                 "country_code_continual",
                                 "country_name",
                                 "country_name_de",
                                 "country_name_long",
                                 "data_type",
                                 "date_last_edited",
                                 "date_time_last_active",
                                 "date_withdrawn",
                                 "day",
                                 "display_col",
                                 "display_name",
                                 "electorate_abroad",
                                 "electorate_total",
                                 "files",
                                 "generated",
                                 "generation_expression",
                                 "has_default",
                                 "id",
                                 "id_official",
                                 "id_sudd",
                                 "id_sudd_prefix",
                                 "identity_generation",
                                 "inst_has_precondition",
                                 "inst_has_urgent_legal_basis",
                                 "inst_is_assembly",
                                 "inst_is_binding",
                                 "inst_is_counter_proposal",
                                 "inst_legal_basis_type",
                                 "inst_object_author",
                                 "inst_object_legal_level",
                                 "inst_object_revision_extent",
                                 "inst_object_revision_modes",
                                 "inst_object_type",
                                 "inst_precondition_actor",
                                 "inst_precondition_decision",
                                 "inst_quorum_approval",
                                 "inst_quorum_turnout",
                                 "inst_topics_excluded",
                                 "inst_topics_only",
                                 "inst_trigger_actor",
                                 "inst_trigger_actor_level",
                                 "inst_trigger_threshold",
                                 "inst_trigger_time_limit",
                                 "inst_trigger_type",
                                 "is_admin",
                                 "is_aux",
                                 "is_draft",
                                 "is_filled_auto",
                                 "is_filled_nocodb",
                                 "is_filled_pg",
                                 "is_former_country",
                                 "is_generated",
                                 "is_identity",
                                 "is_meta",
                                 "is_multi_valued",
                                 "is_nullable",
                                 "is_opt",
                                 "is_pk",
                                 "is_self_referencing",
                                 "is_testing_server",
                                 "is_updatable",
                                 "items",
                                 "level",
                                 "lower_house_abstentions",
                                 "lower_house_no",
                                 "lower_house_yes",
                                 "month",
                                 "municipality_name",
                                 "n",
                                 "name",
                                 "name_long",
                                 "name_short",
                                 "nocodb_id",
                                 "number",
                                 "ordinal_position",
                                 "parent_code",
                                 "parent_table",
                                 "parent_tbls",
                                 "parent_topic",
                                 "password",
                                 "position_government",
                                 "ptype",
                                 "question",
                                 "question_en",
                                 "referendum_text_options",
                                 "remarks",
                                 "req",
                                 "resp",
                                 "result",
                                 "role",
                                 "rowid",
                                 "sources",
                                 "subnational_entity_code",
                                 "subnational_entity_name",
                                 "subterritories_no",
                                 "subterritories_yes",
                                 "sudd_prefix",
                                 "tags",
                                 "title",
                                 "topic",
                                 "topic_tier_1",
                                 "topic_tier_2",
                                 "topic_tier_3",
                                 "topics_tier_1",
                                 "topics_tier_2",
                                 "topics_tier_3",
                                 "territory_name_de",
                                 "territory_name_de_short",
                                 "title_de",
                                 "title_fr",
                                 "title_en",
                                 "turnout",
                                 "type",
                                 "un_country_code",
                                 "un_region_tier_1_code",
                                 "un_region_tier_2_name",
                                 "un_region_tier_3_name",
                                 "updated_at",
                                 "upper_house_abstentions",
                                 "upper_house_no",
                                 "upper_house_yes",
                                 "url_sudd",
                                 "url_swissvotes",
                                 "value_labels",
                                 "value_scale",
                                 "variable_name",
                                 "variable_name_unnested",
                                 "variable_name_print",
                                 "variable_values",
                                 "value",
                                 "value_total",
                                 "votes",
                                 "votes_empty",
                                 "votes_invalid",
                                 "votes_no",
                                 "votes_per_subterritory",
                                 "votes_yes",
                                 "year"))

# avoid notes about "possible error"s when using non-exported rex shortcuts, cf. https://rex.r-lib.org/#using-rex-in-other-packages
rex::register_shortcuts(pkg_name = utils::packageName())

# katex is used in documentation dynamically via `\Sexpr`, so it has to be imported to avoid an error when rendering the corresponding help page
# TODO: since the `R CMD check` warning can be considered a bug in this case, investigate the situation and possibly submit bug report
has_katex <- function() {
  nchar(katex::example_math()) > 0L
}

.onLoad <- function(libname, pkgname) {
  
  # clear pkgpins cache
  tryCatch(expr = pkgpins::clear_cache(board = pkgpins::board(pkg = pkgname),
                                       max_age = pal::pkg_config_val(key = "global_max_cache_age",
                                                                     pkg = pkgname)),
           error = function(e) cli::cli_alert_warning(text = "Failed to clear pkgpins cache on load of {.pkg {pkgname}}. Error message: {e$message}"))
}



as_fm_list <- function(x) {
  
  purrr::imap(x,
              \(val, key) rlang::new_formula(lhs = key,
                                             rhs = val,
                                             env = emptyenv()))
}

assert_cols_valid <- function(data,
                              type = c("validate", "add", "edit"),
                              action = cli::cli_abort,
                              cli_progress_id = NULL) {
  
  type <- rlang::arg_match(type)
  
  non_na_col_names <- c("id",
                        "date",
                        "level")
  na_col_names <-
    data %>%
    dplyr::select(any_of(non_na_col_names)) %>%
    dplyr::filter(dplyr::if_any(.cols = everything(),
                                .fns = is.na)) %>%
    dplyr::select(where(\(x) anyNA(x))) %>%
    colnames()
  n_na_col_names <- length(na_col_names)
  
  if (n_na_col_names) {
    cli::cli_progress_done(id = cli_progress_id,
                           result = "failed")
    action("Detected {n_na_col_names} column{?s} in {.arg data} that contain forbidden {.val NA}s: {.var {na_col_names}}")
  }
  
  ## check `id`
  if ("id" %in% colnames(data) && anyDuplicated(data$id)) {
    cli::cli_progress_done(id = cli_progress_id,
                           result = "failed")
    action("Duplicated {.var id}s detected. IDs must be unique.")
  }
  
  ## check `date`
  if ("date" %in% colnames(data)) {
    
    check <- checkmate::check_date(data$date,
                                   any.missing = FALSE)
    if (!isTRUE(check)) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action("Failed to validate {.var data$date}. {check}")
    }
  }
  
  ## check `level`
  if ("level" %in% colnames(data)) {
    
    check <- checkmate::check_subset(as.character(data$level),
                                     choices = var_vals("level"))
    if (!isTRUE(check)) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action("Failed to validate {.var data$level}. {check}")
    }
  }

  ## check `country_code`
  if ("country_code" %in% colnames(data)) {
    
    check <- checkmate::check_subset(as.character(data$country_code),
                                     choices = val_set$country_code)
    if (!isTRUE(check)) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action("Failed to validate {.var data$country_code}. {check}")
    }
    
    ## ensure `position_government` is present for additions when `country_code = "CH" & level = "national"`
    if (type == "add"
        && (data %>%
            dplyr::filter(country_code == "CH" & level == "national") %>%
            nrow() %>%
            magrittr::is_greater_than(0L))
        && !("position_government" %in% colnames(data))) {
      
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action(paste0("Referendums with {.code country_code = \"CH\" & level = \"national\"} present in {.arg data} but column {.var ",
                    "position_government} is missing."))
    }
  }
  
  ## check `subnational_entity_name`
  ## TODO: check `subnational_entity_code` instead once it's available
  if (any(data[["level"]] != "national")) {
    
    if (!("subnational_entity_name" %in% colnames(data))) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action(paste0("Referendums of {.var level} below {.val national} present in {.arg data} but column {.var subnational_entity_name} is missing."))
    }
    
    ix_missing_subnational_entities <-
      data %>%
      tibble::rowid_to_column() %>%
      dplyr::filter(level != "national" & is.na(subnational_entity_name)) %$%
      rowid
    
    n_missing_subnational_entities <- length(ix_missing_subnational_entities)
    
    if (n_missing_subnational_entities) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action(paste0("{n_missing_subnational_entities} row{?s} in {.arg data} {?is/are} missing a {.var subnational_entity_name}. Affected {?is/are} ",
                    "the row{?s} with ind{?ex/ices} {.val {ix_missing_subnational_entities}}."))
    }
  }
  if ("subnational_entity_name" %in% colnames(data)) {
    
    ix_illegal_subnational_entities <-
      data %>%
      tibble::rowid_to_column() %>%
      dplyr::filter(level == "national" & !is.na(subnational_entity_name)) %$%
      rowid
    
    n_illegal_subnational_entities <- length(ix_illegal_subnational_entities)
    
    if (n_illegal_subnational_entities) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action(paste0("{n_illegal_subnational_entities} row{?s} in {.arg data} {?has/have} a {.var subnational_entity_name} set although they are on the ",
                    "national level. Affected {?is/are} the row{?s} with ind{?ex/ices} {.val {ix_illegal_subnational_entities}}."))
    }
  }
  
  ## check `municipality_name`
  if (any(data[["level"]] == "municipal")) {
    
    if (!("municipality_name" %in% colnames(data))) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action(paste0("Referendums of {.var level = \"municipal\"} present in {.arg data} but column {.var municipality_name} is missing."))
    }
    
    ix_missing_municipalities <-
      data %>%
      tibble::rowid_to_column() %>%
      dplyr::filter(level == "municipal" & is.na(municipality_name)) %$%
      rowid
    
    n_missing_municipalities <- length(ix_missing_municipalities)
    
    if (n_missing_municipalities) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action(paste0("{n_missing_municipalities} row{?s} in {.arg data} {?is/are} missing a {.var municipality_name}. Affected {?is/are} the row{?s} with ",
                    "ind{?ex/ices} {.val {ix_missing_subnational_entities}}."))
    }
  }
  if ("municipality_name" %in% colnames(data)) {
    
    ix_illegal_municipalities <-
      data %>%
      tibble::rowid_to_column() %>%
      dplyr::filter(level != "municipal" & !is.na(municipality_name)) %$%
      rowid
    
    n_illegal_municipalities <- length(ix_illegal_municipalities)
    
    if (n_illegal_municipalities) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action(paste0("{n_illegal_municipalities} row{?s} in {.arg data} {?has/have} a {.var municipality_name} set although they are not on the municipal ",
                    "level. Affected {?is/are} the row{?s} with ind{?ex/ices} {.val {ix_illegal_municipalities}}."))
    }
  }
  
  ## check variables that are only meant to be set for Swiss national referendums
  ## TODO: Remove this as soon as [issue #52](https://github.com/zdaarau/c2d-app/issues/52) is resolved.
  ### `votes_per_subterritory`
  if (all(c("votes_per_subterritory", "level", "country_code") %in% colnames(data))) {
    
    ix_illegal_votes_per_subterritory <-
      data %>%
      tibble::rowid_to_column() %>%
      dplyr::filter((level != "national" | country_code != "CH") & !purrr::map_lgl(votes_per_subterritory, is.null)) %$%
      rowid
    
    n_illegal_votes_per_subterritory <- length(ix_illegal_votes_per_subterritory)
    
    if (n_illegal_votes_per_subterritory) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action(paste0("{n_illegal_votes_per_subterritory} row{?s} in {.arg data} {?has/have} a {.var position_government} set although they are not Swiss ",
                    "national referendums. Affected {?is/are} the row{?s} with ind{?ex/ices} {.val {ix_illegal_votes_per_subterritory}}."))
    }
  }
  ### non-list vars
  c("lower_house_yes",
    "lower_house_no",
    "lower_house_abstentions",
    "upper_house_yes",
    "upper_house_no",
    "upper_house_abstentions",
    "position_government") %>%
    purrr::walk(function(var_name) {
      
      if (all(c(var_name, "level", "country_code") %in% colnames(data))) {
        
        ix_illegal <-
          data %>%
          tibble::rowid_to_column() %>%
          dplyr::filter((level != "national" | country_code != "CH") & !is.na(!!as.symbol(var_name))) %$%
          rowid
        
        n_illegal <- length(ix_illegal)
        
        if (n_illegal) {
          cli::cli_progress_done(id = cli_progress_id,
                                 result = "failed")
          action(paste0("{n_illegal} row{?s} in {.arg data} {?has/have} a {.var {var_name}} set although {cli::qty(n_illegal)}{?it is not a/they are not} ",
                        "Swiss national referendum{?s}. Affected {?is/are} the row{?s} with ind{?ex/ices} {.val {ix_illegal}}."))
        }
      }
    })
  
  invisible(data)
}

assert_dm <- function(dm) {
  
  if (!dm::is_dm(dm)) {
    cli::cli_abort("{.arg dm} must be an object of type {.help dm::dm}.")
  }
  
  invisible(dm)
}

col_names_autofilled <- function(tbl_name = tbl_metadata$name) {
  
  tbl_name <- rlang::arg_match(tbl_name)
  
  result <-
    pg_tbl_metadata[[tbl_name]]
    dplyr::filter(is_filled_auto) |>
    dplyr::pull("column_name")
  
  if (tbl_name == "referendums") {
    
    result %<>% c(eval(expr = formals(fun = add_period)$period),
                  col_names_un,
                  "country_code_continual",
                  "country_code_long",
                  "country_name",
                  "country_name_long",
                  "is_former_country",
                  "municipality_name",
                  "subnational_entity_name",
                  "turnout",
                  "url_sudd",
                  "url_swissvotes")
  }
  
  result
}

col_names_mandatory <- function(tbl_name = tbl_metadata$name) {
  
  tbl_name <- rlang::arg_match(tbl_name)
  
  pg_tbl_metadata[[tbl_name]] |>
    dplyr::filter(!is_nullable & !is_filled_auto) |>
    dplyr::pull("column_name")
}

country_code_to_name <- function(country_code) {
  
  purrr::map2_chr(.x = country_code,
                  .y = nchar(as.character(country_code)) > 2L,
                  .f = \(x, y) {
                    
                    if (isTRUE(y)) {
                      
                      result <-
                        data_iso_3166_3 %>%
                        dplyr::filter(alpha_4 == !!x) %$%
                        name_short
                      
                    } else {
                      
                      result <-
                        data_iso_3166_1 %>%
                        dplyr::filter(alpha_2 == !!x) %$%
                        name_short
                    }
                    
                    if (length(result) == 0L) {
                      result <- NA_character_
                    }
                    
                    result
                  })
}

#' Remove `GENERATED ALWAYS` columns from `dm`
#'
#' Removes `GENERATED ALWAYS` columns from a data model object.
#'
#' @param dm `r pkgsnip::param_lbl("dm")`
#'
#' @return `r pkgsnip::return_lbl("dm")`
#' @keywords internal
#'
#' @examples
#' rdb::dm() |> rdb:::dm_excl_gen_always_cols()
dm_excl_gen_always_cols <- function(dm) {
  
  assert_dm(dm)
  
  # exclude non-PK `GENERATED ALWAYS` cols
  for (tbl_name in names(dm)) {
    
    col_names_to_excl <-
      pg_col_metadata(tbl_name = tbl_name) |>
      dplyr::filter(generated == "ALWAYS" & !is_pk) |>
      dplyr::pull(column_name)
    
    if (length(col_names_to_excl) > 0L) {
      dm %<>% dm::dm_select(table = !!tbl_name,
                            -!!col_names_to_excl)
    }
  }
  
  dm
}

fct_flip <- function(x) {
  
  checkmate::assert_factor(x,
                           n.levels = 2L)
  flip_map <-
    levels(x) %>%
    magrittr::set_names(value = rev(.)) %>%
    as.list()
  
  x %>% forcats::fct_recode(!!!flip_map)
}

hostname_to_ep <- function(x) {
  
  x |>
    stringr::str_split_1(pattern = stringr::fixed(".")) |>
    dplyr::first()
}

md_link_codebook <- function(var_names) {
  
  purrr::map_chr(var_names,
                 \(x) paste0("[`", x, "`](", url_codebook(x), ")"))
}

order_rfrnd_cols <- function(data) {
  
  data %>% dplyr::relocate(any_of(rfrnd_cols_order))
}

parse_array <- function(x) {
  
  pg_class <- class(x)
  
  stringr::str_extract(string = x,
                       pattern = "^(\\{)(.*)(\\})$",
                       group = 2L) |>
    stringr::str_split(pattern = stringr::fixed(",")) |>
    pal::when(length(pg_class) == 1L && startsWith(pg_class, "pq__int") ~ purrr::map(., as.integer),
              ~ .)
}

#' Get primary key column name(s)
#'
#' Returns the primary key column name(s) of the specified table, based on PostgreSQL metadata obtained at package-build time. This function is faster than
#' [pg_pk()] since it doesn't perform network requests. But it can return outdated information if changes were made to the RDB PostgreSQL schema *after* the
#' package-internal `rdb:::pg_tbl_metadata` was last updated.
#'
#' @inheritParams pg_pk
#'
#' @return A character scalar.
#' @keywords internal
pk <- function(tbl_name = tbl_metadata$name) {
  
  tbl_name <- rlang::arg_match(tbl_name)
  
  pg_tbl_metadata[[tbl_name]] |>
    dplyr::filter(is_pk) |>
    dplyr::pull("column_name")
}

plot_share_per_period <- function(data_freq,
                                  x,
                                  period) {
  rlang::check_installed("plotly",
                         reason = pal::reason_pkg_required())
  
  grid_step <- switch(EXPR = period,
                      week = 4L,
                      year = 50L,
                      decade = 50L,
                      century = 100L,
                      1L)
  
  grid_x <- seq(from = ceiling(pal::safe_min(data_freq[[period]])[1L] / grid_step) * grid_step,
                to = floor(pal::safe_max(data_freq[[period]])[1L] / grid_step) * grid_step,
                by = grid_step)
  
  plotly::plot_ly(data = data_freq,
                  type = "scatter",
                  mode = "none",
                  stackgroup = "one",
                  groupnorm = "percent",
                  x = ~eval(as.symbol(period)),
                  y = ~n,
                  name = ~eval(as.symbol(x))) %>%
    plotly::layout(hovermode = "x",
                   legend = list(orientation = "h"),
                   xaxis = list(dtick = switch(EXPR = period,
                                               week = 1L,
                                               month = 1L,
                                               quarter = 1L,
                                               year = 10L,
                                               decade = 10L,
                                               century = 100L),
                                showgrid = FALSE,
                                ticklabelstep = switch(EXPR = period,
                                                       week = 4L,
                                                       month = 1L,
                                                       quarter = 1L,
                                                       year = 5L,
                                                       decade = 5L,
                                                       century = 1L),
                                range = switch(EXPR = period,
                                               week = c(1L, 53L),
                                               month = c(1L, 12L),
                                               quarter = c(1L, 4L),
                                               NULL),
                                ticks = "outside",
                                title = list(text = NULL)),
                   yaxis = list(fixedrange = TRUE,
                                hoverformat = ".1f",
                                showgrid = FALSE,
                                ticksuffix = "\u2009% ",
                                title = list(text = NULL)),
                   # draw custom grid
                   shapes =
                     grid_x %>%
                     purrr::map(\(x) list(type = "line",
                                          y0 = 0L,
                                          y1 = 1L,
                                          yref = "paper",
                                          x0 = x,
                                          x1 = x,
                                          line = list(color = "#fff",
                                                      width = 0.2))))
}

restore_topics <- function(topics_tier_1,
                           topics_tier_2,
                           topics_tier_3) {
  list(topics_tier_1,
       topics_tier_2,
       topics_tier_3) %>%
    purrr::pmap(~ {
      
      ..1 %>%
        unlist() %>%
        as.character() %>%
        checkmate::assert_character(any.missing = FALSE,
                                    max.len = 3L,
                                    .var.name = "topics_tier_1")
      ..2 %>%
        unlist() %>%
        as.character() %>%
        checkmate::assert_character(any.missing = FALSE,
                                    max.len = 3L,
                                    .var.name = "topics_tier_2")
      ..3 %>%
        unlist() %>%
        as.character() %>%
        checkmate::assert_character(any.missing = FALSE,
                                    max.len = 3L,
                                    .var.name = "topics_tier_3")
      
      topics_hierarchy <- hierarchize_topics(tibble::tibble(topics_tier_1 = list(..1),
                                                            topics_tier_2 = list(..2),
                                                            topics_tier_3 = list(..3)))
      
      topics <- topics_hierarchy$topic_tier_3 %>% setdiff(NA_character_)
      
      if (length(topics) < 3L) {
        
        topics <-
          topics_hierarchy %>%
          dplyr::filter(is.na(topic_tier_3)) %$%
          topic_tier_2 %>%
          setdiff(NA_character_) %>%
          c(topics)
      }
      
      if (length(topics) < 3L) {
        
        topics <-
          topics_hierarchy %>%
          dplyr::filter(is.na(topic_tier_3) & is.na(topic_tier_2)) %$%
          topic_tier_1 %>%
          setdiff(NA_character_) %>%
          c(topics)
      }
      
      topics
    })
}

topic_frequency <- function(topics,
                            tier) {
  topics %>%
    purrr::list_c(ptype = character()) %>%
    factor(levels = topics(tiers = tier)) %>%
    tibble::tibble(topic = .) %>%
    dplyr::group_by(topic) %>%
    dplyr::summarise(n = dplyr::n())
}

#' Assemble C2D Services API URL
#'
#' @param ... Optional path components added to the base URL.
#'
#' @return A character scalar.
#' @family url_assembly
#' @keywords internal
#'
#' @examples
#' rdb:::url_api_old("health")
url_api_old <- function(...) {
  
  fs::path("services.c2d.ch", ...) %>% paste0("https://", .)
}

#' Assemble RDB admin portal URL
#'
#' @inheritParams url_api_old
#'
#' @inherit url_api_old return
#' @family url_assembly
#' @keywords internal
#'
#' @examples
#' rdb:::url_admin_portal("referendum/5bbbfd7b92a21351232e46b5")
url_admin_portal <- function(...) {
  
  fs::path("admin.c2d.ch", ...) %>% paste0("https://", .)
}

#' Assemble codebook URL
#'
#' @param var_name Optional variable name to add as the [fragment identifier](https://en.wikipedia.org/wiki/URI_fragment) of the returned URL, which leads to a
#' direct link to the relevant codebook section. Must be either one of the column names of [`data_codebook`], or a valid fragment identifier of a codebook
#' section above the individual variables (`r pal::enum_str(codebook_fragments, last = " or ")`).
#'
#' @return A character scalar.
#' @family url_assembly
#' @keywords internal
#'
#' @examples
#' rdb:::url_codebook("level")
#' rdb:::url_codebook("topics")
url_codebook <- function(var_name = NULL) {
  
  checkmate::assert_string(var_name,
                           null.ok = TRUE)
  
  if (!is.null(var_name)) {
    
    var_name %<>% stringr::str_replace_all(pattern = stringr::fixed("_"),
                                           replacement = "-")
  }
  
  paste0("https://rdb.rpkg.dev/articles/codebook.html", "#"[!is.null(var_name)], var_name)
}

#' Assemble website URL
#'
#' @param ... Optional path components added to the base URL.
#'
#' @return A character scalar.
#' @family url_assembly
#' @keywords internal
#'
#' @examples
#' rdb:::url_website("referendum/CH/5bbc04f692a21351232e5a01")
url_website <- function(...) {
  
  fs::path("c2d.ch", ...) %>%
    paste0("https://", .)
}

#' Get PostgreSQL column metadata
#'
#' @inheritParams pg_pk
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family pg
#' @keywords internal
pg_col_metadata <- function(tbl_name,
                            schema = pg_schema,
                            connection = connect()) {
  
  checkmate::assert_string(tbl_name)
  checkmate::assert_string(schema)
  
  if (!DBI::dbExistsTable(conn = connection,
                          name = DBI::Id(schema = schema,
                                         table = tbl_name))) {
    
    cli::cli_abort("No {.field {schema}.{tbl_name}} table found.")
  }
  
  glue::glue_sql(.con = connection,
                 "SELECT * FROM information_schema.columns",
                 "  WHERE table_schema = {schema} AND table_name = {tbl_name};") |>
    DBI::dbGetQuery(conn = connection) |>
    dplyr::collect() |>
    dplyr::rename(generated = is_generated) |>
    dplyr::mutate(dplyr::across(.cols = any_of(c("is_nullable",
                                                 "is_self_referencing",
                                                 "is_identity",
                                                 "is_updatable")),
                                .fns = \(x) dplyr::case_match(.x = x,
                                                              "YES" ~ TRUE,
                                                              "NO" ~ FALSE,
                                                              .default = NA,
                                                              .ptype = logical())),
                  has_default = !is.na(column_default),
                  is_filled_pg = has_default | (is_identity & identity_generation %in% c("ALWAYS", "BY DEFAULT")) | generated != "NEVER",
                  is_filled_nocodb = column_name %in% col_names_nocodb_filled,
                  is_filled_auto = is_filled_pg | is_filled_nocodb,
                  is_pk = column_name %in% pg_pk(tbl_name = tbl_name,
                                                 schema = schema,
                                                 connection = connection)) |>
    dplyr::select(column_name,
                  ordinal_position,
                  column_default,
                  data_type,
                  has_default,
                  is_pk,
                  is_nullable,
                  is_filled_pg,
                  is_filled_nocodb,
                  is_filled_auto,
                  is_updatable,
                  is_self_referencing,
                  is_identity,
                  identity_generation,
                  generated,
                  generation_expression) |>
    tibble::as_tibble()
}

#' Get PostgreSQL column name from number
#'
#' @inheritParams pg_pk
#' @param col_nr Number of the column whose name is to be retrieved.
#'
#' @return A character scalar.
#' @family pg
#' @keywords internal
pg_col_nr_to_name <- function(col_nr,
                              tbl_name,
                              schema = pg_schema,
                              connection = connect()) {
  
  checkmate::assert_int(col_nr)
  checkmate::assert_string(tbl_name)
  checkmate::assert_string(schema)
  
  result <-
    glue::glue_sql(.con = connection,
                   "SELECT pg_attribute.attname AS column_name",
                   "  FROM pg_attribute",
                   "  JOIN pg_class ON pg_class.oid = pg_attribute.attrelid",
                   "  JOIN pg_namespace ON pg_namespace.oid = pg_class.relnamespace",
                   "  WHERE pg_class.oid = {tbl_name}::regclass",
                   "    AND pg_namespace.nspname = {schema}",
                   "    AND pg_attribute.attnum = {col_nr}",
                   "    AND pg_attribute.attisdropped = FALSE;") |>
    DBI::dbGetQuery(conn = connection)
  
  if (nrow(result) == 0L) {
    cli::cli_abort("Table {.field {schema}.{tbl_name}} has no column number {.val {col_nr}}.")
  }
  
  result$column_name
}

#' Test whether PostgreSQL table exists
#'
#' @inheritParams pg_pk
#'
#' @return A logical scalar.
#' @family pg
#' @keywords internal
pg_has_tbl <- function(tbl_name,
                       schema = pg_schema,
                       connection = connect()) {
  
  checkmate::assert_string(tbl_name)
  checkmate::assert_string(schema)
  
  glue::glue_sql("SELECT to_regclass({paste(schema, tbl_name, sep = '.')}) AS \"tbl\";",
                 .con = connection) |>
    DBI::dbGetQuery(conn = connection) |>
    dplyr::pull("tbl") |>
    is.na() |>
    magrittr::not()
}

#' Drop PostgreSQL tables
#'
#' Deletes the specified `tbl_names` from a PostgreSQL database.
#'
#' @inheritParams rfrnds
#' @param tbl_names Names of the tables to delete from the PostgreSQL database.
#' @param min_msg_severity_lvl Minimum PostgreSQL [message severity
#'   level](https://www.postgresql.org/docs/current/runtime-config-logging.html#RUNTIME-CONFIG-SEVERITY-LEVELS) to be printed. one of
#'   `r pal::as_md_vals(pg_client_min_messages) |> pal::enum_str(sep2 = " or ")`. Each level includes all the levels that follow it. The later the level, the
#'   fewer messages are sent.
#'
#' @return `tbl_names`, invisibly.
#' @family pg
#' @keywords internal
pg_drop_tbls <- function(tbl_names,
                         connection = connect(user = "rdb_admin",
                                              password = pg_role_pw("rdb_admin")),
                         disconnect = TRUE,
                         min_msg_severity_lvl = "WARNING") {
  
  checkmate::assert_character(tbl_names,
                              any.missing = FALSE)
  min_msg_severity_lvl <- rlang::arg_match(arg = min_msg_severity_lvl,
                                           values = pg_client_min_messages)
  checkmate::assert_flag(disconnect)
  
  DBI::dbWithTransaction(conn = connection,
                         code = {
                           
                           DBI::dbSendStatement(conn = connection,
                                                statement = glue::glue("SET client_min_messages TO {min_msg_severity_lvl};")) |>
                             DBI::dbClearResult()
                           
                           DBI::sqlInterpolate(conn = connection,
                                               sql = paste("DO LANGUAGE plpgsql",
                                                           "  $$",
                                                           "  DECLARE",
                                                           "    t text;",
                                                           "  BEGIN",
                                                           "    FOREACH t IN ARRAY ARRAY[?tbl_names]",
                                                           "    LOOP",
                                                           "      EXECUTE format('DROP TABLE IF EXISTS %I CASCADE', t);",
                                                           "    END LOOP;",
                                                           "  END;",
                                                           "  $$;",
                                                           sep = "\n"),
                                               tbl_names =
                                                 tbl_names |>
                                                 DBI::dbQuoteLiteral(conn = connection) |>
                                                 cli::ansi_collapse(sep2 = ", ",
                                                                    last = ", ") |>
                                                 DBI::SQL()) |>
                             DBI::dbSendStatement(conn = connection) |>
                             DBI::dbClearResult()
                         })
  if (disconnect) {
    DBI::dbDisconnect(conn = connection)
  }
  
  invisible(tbl_names)
}

#' Reset RDB PostgreSQL database
#'
#' Drops and recreates the RDB PostgreSQL database.
#' 
#' Remember to restart the corresponding read-only Neon.tech compute endpoint (e.g. via [restart_neon_ep()]) after runnning `pg_reset_db()` to render it
#' accessible again.
#' 
#' If the [following error](https://stackoverflow.com/a/71279781/7196903) occurs, try deleting the `rdb` database manually via [Neon
#' console](https://console.neon.tech/):
#' 
#' ```
#' permission denied to terminate process
#' DETAIL: Only roles with privileges of the role whose process is being terminated or with privileges of the "pg_signal_backend" role may terminate this (...)
#' ```
#'
#' @inheritParams rfrnds
#'
#' @return `NULL`, invisibly.
#' @family pg
#' @keywords internal
pg_reset_db <- function(connection = connect(dbname = "postgres",
                                             user = "rdb_admin",
                                             password = pg_role_pw("rdb_admin")),
                        disconnect = TRUE) {
  
  checkmate::assert_flag(disconnect)
  
  "sql/1-reset_db.sql" |> 
    fs::path_package(package = this_pkg) |>
    read_sql_file(.connection = connection) |>
    purrr::walk(\(statement) {
      DBI::dbSendStatement(statement = statement,
                           conn = connection) |>
        DBI::dbClearResult()
    })
  
  if (disconnect) {
    DBI::dbDisconnect(conn = connection)
  }
  
  invisible(NULL)
}

#' Initialize RDB PostgreSQL database
#'
#' @inheritParams rfrnds
#'
#' @return `NULL`, invisibly.
#' @family pg
#' @keywords internal
pg_init_db <- function(connection = connect(user = "rdb_admin",
                                            password = pg_role_pw("rdb_admin")),
                       disconnect = TRUE) {
  vars <-
    pal::pkg_config_val("pg_roles_csv_file") |>
    readr::read_csv(col_types = "c") %$%
    magrittr::set_names(x = password,
                        value = paste0("pw_", role))
  
  "sql/2-init_db.sql" |> 
    fs::path_package(package = this_pkg) |>
    exec_sql_file(.connection = connection,
                  .disconnect = disconnect,
                  !!!vars)
  
  invisible(NULL)
}

#' Initialize auxiliary RDB PostgreSQL tables
#'
#' @inheritParams rfrnds
#'
#' @return `NULL`, invisibly.
#' @family pg
#' @keywords internal
pg_init_aux_tbls <- function(connection = connect(user = "rdb_admin",
                                                  password = pg_role_pw("rdb_admin")),
                             disconnect = TRUE) {
  
  "sql/3-init_aux_tbls.sql" |>
    fs::path_package(package = this_pkg) |>
    exec_sql_file(.connection = connection,
                  .disconnect = disconnect)
  
  invisible(NULL)
}

#' Initialize main RDB PostgreSQL tables
#'
#' @inheritParams rfrnds
#'
#' @return `NULL`, invisibly.
#' @family pg
#' @keywords internal
pg_init_main_tbls <- function(connection = connect(user = "rdb_admin",
                                                   password = pg_role_pw("rdb_admin")),
                              disconnect = TRUE) {
  
  "sql/4-init_main_tbls.sql" |>
    fs::path_package(package = this_pkg) |>
    exec_sql_file(.connection = connection,
                  .disconnect = disconnect)
  
  invisible(NULL)
}

#' Alter RDB PostgreSQL meta columns
#'
#' @inheritParams rfrnds
#'
#' @return `NULL`, invisibly.
#' @family pg
#' @keywords internal
pg_post_nocodb <- function(connection = connect(user = "rdb_admin",
                                                password = pg_role_pw("rdb_admin")),
                           disconnect = TRUE) {
  
  "sql/5-post_nocodb.sql" |>
    fs::path_package(package = this_pkg) |>
    exec_sql_file(.connection = connection,
                  .disconnect = disconnect)
  
  invisible(NULL)
}

#' Add default RDB PostgreSQL data
#'
#' @inheritParams rfrnds
#'
#' @return `NULL`, invisibly.
#' @family pg
#' @keywords internal
pg_add_default_data <- function(connection = connect(user = "rdb_admin",
                                                     password = pg_role_pw("rdb_admin")),
                                disconnect = TRUE) {
  
  "sql/6-add_default_data.sql" |>
    fs::path_package(package = this_pkg) |>
    exec_sql_file(.connection = connection,
                  .disconnect = disconnect)
  
  invisible(NULL)
}

#' Test whether PostgreSQL table has row-level security enabled
#'
#' @inheritParams pg_pk
#'
#' @return A logical scalar.
#' @family pg
#' @keywords internal
pg_has_rls <- function(tbl_name,
                       schema = pg_schema,
                       connection = connect()) {
  
  checkmate::assert_string(tbl_name)
  checkmate::assert_string(schema)
  
  glue::glue_sql(.con = connection,
                 "SELECT relrowsecurity",
                 "  FROM pg_class",
                 "  WHERE oid = {tbl_name}::regclass;") |>
    DBI::dbGetQuery(conn = connection) |>
    dplyr::pull("relrowsecurity")
}

#' Get primary key column name(s) from PostgreSQL
#'
#' Returns the primary key column name(s) from RDB's DBMS, a PostgreSQL server.
#'
#' @inheritParams pg_tbl_read
#' @param tbl_name `r pkgsnip::type("chr", 1)`
#'   Table name.
#' @param schema `r pkgsnip::type("chr", 1)`
#'   Schema name.
#'
#' @return A character vector.
#' @family pg
#' @keywords internal
pg_pk <- function(tbl_name,
                  schema = pg_schema,
                  connection = connect()) {
  
  checkmate::assert_string(tbl_name)
  checkmate::assert_string(schema)
  
  # return early if tbl doesn't exist
  if (!pg_has_tbl(tbl_name = tbl_name,
                  schema = schema,
                  connection = connection)) {
    
    return(character())
  }
  
  result <-
    glue::glue_sql(.con = connection,
                   "SELECT pg_attribute.attname AS column_name",               
                   "  FROM pg_index, pg_class, pg_attribute, pg_namespace",
                   "  WHERE pg_class.oid = {tbl_name}::regclass",
                   "    AND indrelid = pg_class.oid",
                   "    AND nspname = {schema}",
                   "    AND pg_class.relnamespace = pg_namespace.oid",
                   "    AND pg_attribute.attrelid = pg_class.oid",
                   "    AND pg_attribute.attnum = any(pg_index.indkey)",
                   "    AND indisprimary;") |>
    DBI::dbGetQuery(conn = connection)
  
  if (nrow(result) == 0L) {
    cli::cli_abort("Table {.field {schema}.{tbl_name}} has no primary key set.")
  }
  
  result$column_name
}

#' Get PostgreSQL role password
#'
#' Extracts the specified `role`'s password from the CSV file under `path`.
#'
#' @param role Role name to return the password for.
#' @param path Path to a CSV file containing PostgreSQL user account information. The two columns `role` and `password` must be present.
#'
#' @return `role`'s password as a character scalar.
#' @family pg
#' @keywords internal
pg_role_pw <- function(role,
                       path = pal::pkg_config_val("pg_roles_csv_file")) {
  roles <- readr::read_csv(file = path,
                           col_types = "c")
  pal::assert_cols(data = roles,
                   cols = c("role", "password"),
                   obj_name = "path")
  role <- rlang::arg_match0(arg = role,
                            values = roles$role)
  roles |>
    dplyr::filter(role == !!role) |>
    dplyr::pull("password")
}

#' Update PostgreSQL column sequence
#'
#' Updates the current value of the sequence associated with a PostgreSQL table column to the maximum `col_name` value if necessary, so that the sequence
#' is valid to be used for inserting new rows again. Useful after manually overriding `col_name` values.
#'
#' This function obtains a [table-level lock](https://www.postgresql.org/docs/current/sql-lock.html) to avoid concurrency issues during the sequence update.
#' The sequence is only ever *in*creased and never *de*creased to further defend against concurrency issues in certain edge cases. Finally, `pg_update_seq()`
#' also works on empty tables where the sequence has never been called before.
#'
#' @inheritParams pg_pk
#' @param col_name Name of the column whose sequence is to be updated.
#'
#' @return The updated sequence value as an integer.
#' @family pg
#' @keywords internal
pg_update_seq <- function(tbl_name,
                          col_name = pg_pk(tbl_name = tbl_name,
                                           schema = schema,
                                           connection = connection),
                          schema = pg_schema,
                          connection = connect()) {
  
  checkmate::assert_string(tbl_name)
  checkmate::assert_string(col_name)
  checkmate::assert_string(schema)
  
  connection |>
    DBI::dbWithTransaction(code = {
      
      seq_id <-
        connection |>
        DBI::dbGetQuery(statement = glue::glue_sql(.con = connection,
                                                   "SELECT pg_get_serial_sequence({paste(schema, tbl_name, sep = '.')}, {col_name});")) |>
        unlist(use.names = FALSE)
      
      seq_id_split <- stringr::str_split_1(string = seq_id,
                                           pattern = stringr::fixed("."))
      max_col_val <-
        connection |>
        DBI::dbGetQuery(statement = glue::glue_sql(.con = connection,
                                                   "SELECT MAX({`col_name`}) FROM {`schema`}.{`tbl_name`};")) |>
        unlist(use.names = FALSE)
      
      DBI::dbExecute(conn = connection,
                     statement = glue::glue_sql(.con = connection,
                                                "LOCK TABLE {`schema`}.{`tbl_name`} IN SHARE MODE;"))
      connection |>
        DBI::dbGetQuery(statement = glue::glue_sql(.con = connection,
                                                   "SELECT setval({seq_id}, COALESCE(MAX({`col_name`}) + 1, 1), false)",
                                                   "  FROM {`schema`}.{`tbl_name`}",
                                                   "  HAVING MAX({`col_name`}) > (SELECT last_value FROM {`seq_id_split[1L]`}.{`seq_id_split[2L]`});")) |>
        unlist(use.names = FALSE) |>
        pal::safe_max(max_col_val)
    }) |>
    invisible()
}

#' Get PostgreSQL table constraints
#'
#' @inheritParams pg_pk
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family pg
#' @keywords internal
pg_tbl_constraints <- function(tbl_name,
                               schema = pg_schema,
                               connection = connect()) {
  
  checkmate::assert_string(tbl_name)
  checkmate::assert_string(schema)
  
  glue::glue_sql(.con = connection,
                   "SELECT con.*",               
                   "  FROM pg_catalog.pg_constraint con",
                   "    INNER JOIN pg_catalog.pg_class rel",
                   "      ON rel.oid = con.conrelid",
                   "    INNER JOIN pg_catalog.pg_namespace nsp",
                   "      ON nsp.oid = connamespace",
                   "    WHERE nsp.nspname = {schema}",
                   "      AND rel.relname = {tbl_name};",
                   "  ") |>
    DBI::dbGetQuery(conn = connection) |>
    dplyr::collect() |>
    tibble::as_tibble()
}

#' Read PostgreSQL table
#'
#' Reads in a PostgreSQL table and returns it as a [tibble][tibble::tbl_df].
#'
#' @param tbl_name Table name, passed on to [DBI::dbQuoteIdentifier()]. Options are:
#'   - A character string with the unquoted DBMS table name, e.g. `"table_name"`.
#'   - A call to [DBI::Id()] with components to the fully qualified table name, e.g. `DBI::Id(schema = "my_schema", table = "table_name")`.
#'   - A call to [DBI::SQL()] with the quoted and fully qualified table name given verbatim, e.g. `DBI::SQL('"my_schema"."table_name"')`.
#' @param connection `r pkgsnip::type("pg_conn")`
#'   Database connection to a PostgreSQL DBMS as returned by [connect()].
#' @param disconnect `r pkgsnip::type("lgl", 1)`
#'   Whether or not to [terminate][DBI::dbDisconnect] the database connection when finished.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family pg
#' @keywords internal
pg_tbl_read <- function(tbl_name,
                        connection = connect(),
                        disconnect = TRUE) {
  
  checkmate::assert_string(tbl_name)
  checkmate::assert_flag(disconnect)
  
  # necessary to avoid error on first run of `connect()`
  force(connection)
  
  data <-
    DBI::dbReadTable(conn = connection,
                     name = tbl_name) |>
    tibble::as_tibble()
  
  if (disconnect) {
    DBI::dbDisconnect(conn = connection)
  }
  
  data
}

#' Delete specified data from PostgreSQL table
#'
#' @param tbl PostgreSQL database table from which data is to be deleted. A [`dbplyr::tbl.src_dbi`] object.
#' @param data Table data to delete. A data frame that must contain the table's primary key column. Additional columns are ignored.
#' @param pk_col_names Primary key column name(s). A character vector.
#'
#' @inherit pg_tbl_update return
#' @family pg
#' @keywords internal
pg_tbl_del <- function(tbl,
                       data,
                       pk_col_names) {
  
  checkmate::assert_class(tbl,
                          classes = "tbl_PqConnection")
  checkmate::assert_data_frame(data)
  checkmate::assert_character(pk_col_names,
                              any.missing = FALSE)
  tbl |>
    dplyr::select(!!pk_col_names) |>
    dplyr::collect() |>
    dplyr::intersect(y =
                       data |>
                       dplyr::select(!!pk_col_names) |>
                       dplyr::filter(!dplyr::if_any(.cols = !!pk_col_names,
                                                    .fns = is.na))) |>
    dplyr::rows_delete(x = tbl,
                       by = pk_col_names,
                       unmatched = "ignore",
                       copy = TRUE,
                       in_place = TRUE)
}

#' Delete everything from PostgreSQL table except specified data
#'
#' @inheritParams pg_tbl_del
#' @param data Table data to keep. A data frame that must contain the table's primary key column. Additional columns are ignored.
#'
#' @inherit pg_tbl_update return
#' @family pg
#' @keywords internal
pg_tbl_keep <- function(tbl,
                        data,
                        pk_col_names) {
  
  checkmate::assert_class(tbl,
                          classes = "tbl_PqConnection")
  checkmate::assert_data_frame(data)
  checkmate::assert_character(pk_col_names,
                              any.missing = FALSE)
  tbl |>
    dplyr::select(!!pk_col_names) |>
    dplyr::collect() |>
    dplyr::setdiff(y =
                     data |>
                     dplyr::select(!!pk_col_names) |>
                     dplyr::filter(!dplyr::if_any(.cols = !!pk_col_names,
                                                  .fns = is.na))) |>
    dplyr::rows_delete(x = tbl,
                       by = pk_col_names,
                       unmatched = "ignore",
                       copy = TRUE,
                       in_place = TRUE)
}

#' Update PostgreSQL table
#'
#' Updates the specified PostgreSQL `tbl` with values from `data`.
#'
#' If the `tbl`'s primary key column is `GENERATED ALWAYS`, rows to be newly added must have `NA` values in the corresponding `data` column unless
#' `override_pk_sys_val = TRUE`. This is a safety measure to avoid accidental insertions.
#'
#' @inheritParams read_tbl
#' @param tbl PostgreSQL database table to be updated. A [`dbplyr::tbl.src_dbi`] object.
#' @param data New or updated table data. A data frame that must contain at least the table's primary key column plus any additional columns with new values to
#'   update the corresponding database fields with.
#' @param sweep Whether or not to also sweep the table, i.e. delete rows that are not contained in `data`.
#' @param override_pk_sys_val Whether or not to add new rows that have primary key values set (i.e. which are not `NA`) to a `tbl` whose primary key is
#'   `GENERATED ALWAYS`. Setting `override_pk_sys_val = TRUE` is roughly equivalent to [specifying `OVERRIDING SYSTEM VALUE` in an SQL `INSERT`
#'   statement](https://www.postgresql.org/docs/current/sql-insert.html#id-1.9.3.152.6.2).
#'
#' @return The updated table data as a [tibble][tibble::tbl_df], invisibly. Note that newly inserted rows aren't included if the table's primary key column is
#'   `GENERATED ALWAYS`.
#' @family pg
#' @keywords internal
pg_tbl_update <- function(tbl,
                          data,
                          tbl_name,
                          schema = pg_schema,
                          sweep = FALSE,
                          override_pk_sys_val = FALSE,
                          connection = connect()) {
  
  checkmate::assert_class(tbl,
                          classes = "tbl_PqConnection")
  checkmate::assert_flag(sweep)
  checkmate::assert_flag(override_pk_sys_val)
  
  col_metadata <- pg_col_metadata(tbl_name = tbl_name,
                                  schema = schema,
                                  connection = connection)
  pk_col_names <-
    col_metadata |>
    dplyr::filter(is_pk) |>
    dplyr::pull("column_name")
  
  pk_col_names_gen_always <-
    col_metadata |>
    dplyr::filter(is_pk & (identity_generation == "ALWAYS" | generated == "ALWAYS")) |>
    dplyr::pull("column_name")
  
  # delete obsolete data if requested
  if (sweep) {
    pg_tbl_keep(tbl = tbl,
                data = data,
                pk_col_names = pk_col_names)
  }
  
  # ensure PK cols are present in `data`
  missing_pk_col_names <- setdiff(pk_col_names,
                                  colnames(data))
  n_missing_pk_col_names <- length(missing_pk_col_names)
  
  if (n_missing_pk_col_names > 0L) {
    cli::cli_abort("{cli::qty(n_missing_pk_col_names)} Primary key column{?s} {.var {missing_pk_col_names}} {?is/are} missing from {.arg data}.")
  }
  
  # update existing and add new data
  # NOTE: we can't use `dplyr::rows_in/upsert()` on tables with always-generated pk
  if (length(pk_col_names_gen_always) == 0L) {
    
    result <- dplyr::rows_upsert(x = tbl,
                                 y = data,
                                 by = pk_col_names,
                                 copy = TRUE,
                                 in_place = TRUE)
  } else {
    
    rows_overridden_gen_always_pk <-
      data |>
      dplyr::select(!!pk_col_names_gen_always) |>
      dplyr::setdiff(y =
                       tbl |>
                       dplyr::select(!!pk_col_names_gen_always) |>
                       dplyr::collect() |>
                       # add an empty row to account for all-NA vals
                       tibble::add_row())
    nrow_overridden_gen_always_pk <- nrow(rows_overridden_gen_always_pk)
    
    if (nrow_overridden_gen_always_pk > 0L && !override_pk_sys_val) {
      cli::cli_abort(paste0("{.val {nrow_overridden_gen_always_pk}} row{?s} detected in {.arg data} with explicit primary key values that are supposed to be ",
                            "{.code GENERATED ALWAYS}. Rows to be newly inserted ",
                            "into the {.field {tbl_name}} table must have `NA` values in the primary key {cli::qty(pk_col_names)} column{?s} ",
                            "({.var {pk_col_names}}) since {?it is/at least one of them is} {.code GENERATED ALWAYS} but {.arg override_pk_sys_val} is set to ",
                            "{.val FALSE}."))
    }
    
    # update existing rows
    result <- dplyr::rows_update(x = tbl,
                                 y = data,
                                 by = pk_col_names,
                                 copy = TRUE,
                                 in_place = TRUE,
                                 unmatched = "ignore")
    
    # add new rows with regular always-generated pk
    rows_new_gen_pk <- data |> dplyr::filter(dplyr::if_all(.cols = !!pk_col_names_gen_always,
                                                           .fns = is.na))
    if (nrow(rows_new_gen_pk) > 0L) {
      
      # NOTE: we can't append the result of `DBI::dbAppendTable()` to `result` since the former just returns an integer scalar
      rows_new_gen_pk |>
        dplyr::select(-!!pk_col_names_gen_always) |>
        DBI::dbAppendTable(conn = connection,
                           name = DBI::Id(schema = schema,
                                          table = tbl_name),
                           value = _,
                           # disable `COPY FROM` for tbls with RLS enabled, cf. https://github.com/r-dbi/RPostgres/issues/470
                           copy = !pg_has_rls(tbl_name = tbl_name))
    }
    
    # add new rows with overridden always-generated pk
    rows_new_overridden_pk <- dplyr::semi_join(x = data,
                                               y = rows_overridden_gen_always_pk,
                                               by = colnames(rows_overridden_gen_always_pk))
    if (nrow(rows_new_overridden_pk) > 0L) {
      
      DBI::dbAppendTable(conn = connection,
                         name = DBI::Id(schema = schema,
                                        table = tbl_name),
                         value = rows_new_overridden_pk,
                         # disable `COPY FROM` for tbls with RLS enabled, cf. https://github.com/r-dbi/RPostgres/issues/470
                         copy = !pg_has_rls(tbl_name = tbl_name))
      
      # update tbl's pk seqs
      pk_col_names_gen_always |>
        purrr::walk(\(x) pg_update_seq(tbl_name = tbl_name,
                                       col_name = x,
                                       schema = schema,
                                       connection = connection))
    }
  }
  
  result
}

#' Executes SQL script
#'
#' Reads an SQL script using [read_sql_file()] and executes it as an atomic SQL transaction using [DBI::dbWithTransaction()].
#'
#' @inheritParams read_sql_file
#'
#' @return `path`, invisibly.
#' @family pg
#' @keywords internal
exec_sql_file <- function(.path,
                          ...,
                          .connection = connect(),
                          .disconnect = TRUE) {
  
  checkmate::assert_flag(.disconnect)
  
  DBI::dbWithTransaction(conn = .connection,
                         code = {
                           
                           read_sql_file(.path = .path,
                                         .connection = .connection,
                                         ...) |>
                             purrr::walk(\(statement) {
                               DBI::dbSendStatement(statement = statement,
                                                    conn = .connection) |>
                                 DBI::dbClearResult()
                             })
                         })
  if (.disconnect) {
    DBI::dbDisconnect(conn = .connection)
  }
  
  invisible(.path)
}

#' Read SQL script as statements
#'
#' Reads in an SQL script and returns it as individual interpolated SQL statements using [split_sql_str()].
#'
#' @inheritParams split_sql_str
#' @param .path Path to a file containing SQL statements.
#'
#' @inherit split_sql_str return
#' @family pg
#' @keywords internal
read_sql_file <- function(.path,
                          ...,
                          .connection = connect()) {
  
  rlang::check_installed("brio",
                         reason = pal::reason_pkg_required())
  
  brio::read_file(path = .path) |>
    split_sql_str(.connection = .connection,
                  ...)
}

#' Split SQL string into statements
#'
#' Splits a string of SQL into individual SQL statements and interpolates them using [DBI::sqlInterpolate()]. Useful to prepare the contents of an `.sql` script
#' to be able to feed it to [DBI::dbSendStatement()] (which only accepts a single statement per invocation).
#'
#' @param .text SQL statements to split as a character scalar.
#' @param .connection Database connection as returned by [connect()]. `r pkgsnip::param_lbl("dbi_connection")`
#' @param ... Further (named) arguments used as temporary variables available for substitution while interpolating the SQL statements via
#'   [DBI::sqlInterpolate()].
#'
#' @return A list of [`DBI::SQL`] objects.
#' @family pg
#' @keywords internal
# nolint start: cyclocomp_linter
split_sql_str <- function(.text,
                          ...,
                          .connection = connect()) {
  parts <-
    .text |>
    # remove comments
    stringr::str_remove_all(pattern = "/\\*(.|\n)*?(\\*/)") |>
    stringr::str_remove_all(pattern = "(?<=(^|\n))--.*?\n") |>
    # split by dollar-quoted string constants
    stringr::str_split_1(pattern = "\\$([[:alpha:]_]\\w+)?\\$") |>
    as.list() |>
    purrr::imap(\(x, i) {
      
      if ((i %% 2L) > 0L) {
        x %<>% stringr::str_split_1(pattern = ";(\\s|\\n)*")
      }
      
      x
    })
  
  n_parts <- floor((length(parts) - 1L) / 2L)
  result <- character()
  
  for (i in pal::safe_seq_len(n_parts)) {
    
    i_middle <- i * 2L
    n_subparts_before <- length(parts[[i_middle - 1L]])
    n_subparts_after <- length(parts[[i_middle + 1L]])
    
    if (i == 1L && n_subparts_before > 1L) {
      result %<>% c(parts[[i_middle - 1L]][-n_subparts_before])
    }
    
    middle <- paste0(dplyr::last(parts[[i_middle - 1L]]) %|% "", "$$", parts[[i_middle]], "$$")
    
    if (n_subparts_after > 1L || i == n_parts) {
      middle %<>% paste0(dplyr::first(parts[[i_middle + 1L]]))
    }
    
    result %<>% c(middle,
                  parts[[i_middle + 1L]][-c(1L, n_subparts_after)])
    
    if (i == n_parts && n_subparts_after > 1L) {
      result %<>% c(parts[[i_middle + 1L]][n_subparts_after])
    }
  }
  
  # handle single-part case (`n_parts = 0`, i.e. for loop above evaded)
  if (n_parts == 0L) {
    result <- unlist(parts)
  }
  
  
  # remove empty els
  result %<>% magrittr::extract(. != "")
  
  vars <- rlang::list2(...)
  
  purrr::map(result,
             \(x) {
               
               # NOTE: `DBI::sqlInterpolate()` errors when surplus vars are provided
               vars_present <-
                 x |>
                 stringr::str_extract_all(pattern = "(?<=\\?)[[:alpha:]_]\\w+") |>
                 unlist() |>
                 intersect(names(vars)) %||%
                 character() |>
                 purrr::keep_at(x = vars,
                                at = _)
               
               DBI::sqlInterpolate(sql = x,
                                   conn = .connection,
                                   .dots = vars_present)
             })
}
# nolint end

#' Authenticate S3-compatible object store
#'
#' Executes [s3fs::s3_file_system()] to authenticate against the specified S3-compatible object storage provider.
#'
#' @param s3_endpoint S3-compatible endpoint URL.
#' @param s3_access_key S3-compatible access key ID.
#' @param s3_access_secret S3-compatible access secret.
#'
#' @return An object of class [`s3fs::S3FileSystem`], invisibly.
#' @family s3
#' @keywords internal
s3_auth <- function(s3_endpoint = s3_endpoint_url,
                    s3_access_key = pal::pkg_config_val("nocodb_s3_access_key"),
                    s3_access_secret = pal::pkg_config_val("nocodb_s3_access_secret")) {
  checkmate::assert_string(s3_endpoint)
  checkmate::assert_string(s3_access_key)
  checkmate::assert_string(s3_access_secret)
  
  s3fs::s3_file_system(aws_access_key_id = s3_access_key,
                       aws_secret_access_key = s3_access_secret,
                       endpoint = s3_endpoint,
                       refresh = TRUE)
}

derive_country_vars <- function(country_code,
                                date) {
  
  country_code %<>% as.character()
  subnational_entity_code <- NA_character_
  
  # handle subnational entities
  ## Ascension
  if (country_code == "AC") {
    
    country_code <- "SH"
    subnational_entity_code <- "SH-AC"
  }
  
  # assign canonical pseudo codes
  ## Kosovo
  country_code %<>% dplyr::case_match(.x = .,
                                      "KS" ~ "XK",
                                      .default = .)
  data_former <-
    data_iso_3166_3 %>%
    dplyr::filter(alpha_2_old == !!country_code & !!date <= (clock::add_years(date_withdrawn, 50L))) %>%
    dplyr::filter(date_withdrawn == pal::safe_max(date_withdrawn))
  
  is_former <- nrow(data_former) > 0L
  is_current <- !is_former && country_code %in% data_iso_3166_1$alpha_2
  
  if (!(is_former || is_current) && !(country_code %in% country_codes_sudd_invalid)) {
    cli::cli_alert_warning("Neither ISO 3166-1 alpha-2 nor ISO 3166-3 alpha-4 {.var country_code} found for {.val {country_code}}.")
  }
  
  country_code <-
    country_code %>%
    pal::when(is_former ~
                data_former %>%
                dplyr::filter(date_withdrawn == min(date_withdrawn)) %>%
                assertr::verify(nrow(.) == 1L) %$%
                alpha_4,
              is_current ~
                country_code,
              ~
                NA_character_)
  
  tibble::tibble(country_code = country_code,
                 country_name = country_code_to_name(country_code),
                 is_former_country = is_former,
                 subnational_entity_code = subnational_entity_code)
}

parse_sudd_date <- function(x) {
  
  x_parts <- stringr::str_split_1(string = x,
                                  pattern = "-")
  to_int <- function(x) {
    x %<>% as.integer()
    x[x == 0L] <- NA_integer_
    x
  }
  
  tibble::tibble(year = to_int(x_parts[1L]),
                 month = to_int(x_parts[2L]),
                 day = to_int(x_parts[3L]))
}

parse_sudd_date_de <- function(x) {
  
  components <- stringr::str_split_fixed(string = x,
                                         pattern = "\\s+",
                                         n = 3L)
  
  list(year = components[, 3L] %>% stringr::str_extract(pattern = "\\d+") %>% as.integer(),
       month = components[, 2L] %>% dplyr::case_match(!!!months_de_fms),
       day = components[, 1L] %>% stringr::str_extract(pattern = "\\d+") %>% as.integer())
}

parse_sudd_id <- function(id_sudd) {
  
  sudd_year <-
    id_sudd %>%
    stringr::str_extract(pattern = "\\d{4}$") %>%
    as.integer()
  
  sudd_country_code <-
    id_sudd %>%
    stringr::str_sub(end = 2L) %>%
    stringr::str_to_upper()
  
  derive_country_vars(country_code = sudd_country_code,
                      date = clock::date_build(year = sudd_year,
                                               month = 1L,
                                               day = 1L))
}



sudd_rfrnd <- function(id_sudd) {
  
  checkmate::assert_string(id_sudd)
  
  html <-
    httr2::request(base_url = url_sudd("event.php")) |>
    httr2::req_method(method = "GET") |>
    httr2::req_url_query(id = id_sudd) |>
    httr2::req_retry(max_tries = 3L) |>
    httr2::req_perform() |>
    httr2::resp_body_string() |>
    xml2::read_html() |>
    rvest::html_element(css = "main table") |>
    rvest::html_children()
  
  field_names <-
    html |>
    rvest::html_elements(css = "td.feld") |>
    rvest::html_text()
  
  # handle fields with duplicated/ambiguous names
  if (anyDuplicated(field_names)) {
    
    ## simple duplicates (probably data errors)
    if (id_sudd == "gr011862") {
      
      ix_to_drop <- c(which(field_names == "\u2517\u2501 Republik")[2L],
                      which(field_names == "\u2517\u2501 Russischer Prinz")[2L])
      html %<>% .[-ix_to_drop]
      field_names %<>% .[-ix_to_drop]
      
      ## competing / mutually exclusive proposals, e.g. proposals with direct counter proposal and (optionally) tie-breaker question (CH and LI)
    } else {
      
      option_names <-
        html |>
        rvest::html_elements(css = "td.feld strong") |>
        rvest::html_text()
      
      if (length(option_names) < 2L) {
        cli::cli_abort("Unknown table layout detected for referendum with {.arg id_sudd = {id_sudd}}. Please debug.",
                       .internal = TRUE)
      }
      
      ix_option_names <- which(field_names %in% option_names)
      option_names_counter <- c("Gegenentwurf", "Gegenvorschlag")
      option_names_tie_breaker <- "Stichfrage"
      option_names_special <- c(option_names_counter, option_names_tie_breaker)
      has_counter_proposal <- any(option_names_counter %in% option_names)
      n_proposals_original <-
        option_names |>
        setdiff(option_names_special) |>
        length()
      
      ix_option_field_names <-
        ix_option_names[-length(ix_option_names)] |>
        purrr::imap(\(x, i) (x + 1L):(ix_option_names[i + 1L] - 1L)) |>
        c(list((dplyr::last(ix_option_names) + 1L):(min(length(field_names), which(field_names %in% c("Medien",
                                                                                                      "Bemerkungen",
                                                                                                      "Gleichzeitig mit",
                                                                                                      "Quellen",
                                                                                                      "Vollst\u00e4ndigkeit",
                                                                                                      "Letzte \u00c4nderung"))) - 1L)))
      # rename field names
      option_suffixes <-
        option_names |>
        purrr::imap_chr(\(x, i) {
          x |> pal::when(. %in% option_names_counter                        ~ "counter_proposal",
                         . %in% option_names_tie_breaker                    ~ "tie_breaker",
                         has_counter_proposal && n_proposals_original == 1L ~ "proposal",
                         ~ glue::glue("option_{i}"))
        })
      renamings <-
        purrr::map2(.x = setdiff(option_names,
                                 option_names_tie_breaker),
                    .y = setdiff(option_suffixes,
                                 "tie_breaker"),
                    .f = \(x, y) rlang::list2(!!paste("\u2517\u2501", x) := glue::glue("votes_tie_breaker_{y}"),
                                              !!paste("\u2517\u2501 St\u00e4nde", x) := glue::glue("subterritories_{y}_tie_breaker"))) |>
        purrr::list_flatten() |>
        as_fm_list()
      
      for (i in seq_along(option_names)) {
        
        field_names[ix_option_field_names[[i]]] %<>%
          dplyr::case_match(.x = .,
                            !!!c(renamings,
                                 list("Abgegebene Stimmen"                   ~ glue::glue("votes_{option_suffixes[i]}_total"),
                                      "Stimmen ausser Betracht"              ~ glue::glue("votes_{option_suffixes[i]}_invalid"),
                                      "Ohne Antwort"                         ~ glue::glue("votes_{option_suffixes[i]}_empty"),
                                      "G\u00fcltige (= massgebende) Stimmen" ~ glue::glue("votes_{option_suffixes[i]}_valid"),
                                      "\u2517\u2501 Ja-Stimmen"              ~ glue::glue("votes_{option_suffixes[i]}_yes"),
                                      "\u2517\u2501 Nein-Stimmen"            ~ glue::glue("votes_{option_suffixes[i]}_no"),
                                      "Ja-Stimmen"                           ~ glue::glue("votes_{option_suffixes[i]}_yes"),
                                      "Nein-Stimmen"                         ~ glue::glue("votes_{option_suffixes[i]}_no"),
                                      "St\u00e4nde (Kantone)"                ~ glue::glue("subterritories_{option_suffixes[i]}"),
                                      "\u2517\u2501 Annehmende St\u00e4nde"  ~ glue::glue("subterritories_{option_suffixes[i]}_yes"),
                                      "\u2517\u2501 Verwerfende St\u00e4nde" ~ glue::glue("subterritories_{option_suffixes[i]}_no"))),
                            .default = .)
      }
      
      # drop obsolete fields
      html %<>% .[-ix_option_names]
      field_names %<>% .[-ix_option_names]
    }
  }
  
  # handle other special cases
  if (id_sudd %in% c("li011954",
                     "li031985")) {
    
    field_names %<>% dplyr::case_match(.x = .,
                                       "\u2517\u2501 Initiative"     ~ "votes_proposal",
                                       "\u2517\u2501 Gegenvorschlag" ~ "votes_counter_proposal",
                                       "\u2517\u2501 Nein-Stimmen"   ~ "votes_option_none",
                                       .default = .)
  }
  
  ## move content of exotic fields to `remarks`
  remarks_field <-
    html[field_names == "Bemerkungen"] |>
    pal::when(length(.) > 0L ~ rvest::html_elements(x = ., css = "td")[[2L]],
              ~ .)
  
  remarks_list_col <- list(list(text = rvest::html_text2(remarks_field),
                                urls =
                                  remarks_field |>
                                  rvest::html_elements(css = "a") |>
                                  purrr::map_chr(\(x) {
                                    x |>
                                      rvest::html_attr(name = "href") |>
                                      url_sudd()
                                  }),
                                html =
                                  remarks_field |>
                                  xml2::xml_contents() |>
                                  as.character() |>
                                  paste(collapse = "")))
  ix_fields_to_remarks <-
    field_names |>
    stringr::str_detect(pattern = rex::rex(start,
                                           or("\u2517\u2501\u2501\u2501 .+Stimmen( .+)?",
                                              "Unklare Stimmen",
                                              "Unstimmigkeiten",
                                              "G\u00fcltig stimmende Personen"),
                                           end)) |>
    which()
  
  if (length(ix_fields_to_remarks) > 0L) {
    
    addendum <- field_names[ix_fields_to_remarks]
    
    if (length(addendum) > 0L) {
      
      addendum %<>%
        stringr::str_extract("\\w.*") %>%
        paste0(": ",
               html[ix_fields_to_remarks] |>
                 rvest::html_elements(css = "td") |>
                 magrittr::extract2(2L) |>
                 rvest::html_elements(css = "data") |>
                 rvest::html_attr("value"),
               collapse = "\n\n")
    }
    
    remarks_list_col[[1L]]$text %<>% paste0(addendum, "\n\n"[length(addendum) > 0L], .)
    remarks_list_col[[1L]]$html %<>% paste0("<p>\n", addendum, "\n</p>", .)
    html %<>% .[-ix_fields_to_remarks]
    field_names %<>% .[-ix_fields_to_remarks]
  }
  
  # remove unnecessary fields
  ix_to_drop <- which(field_names %in% c("Nicht eingelegte Stimmzettel",
                                         "Nicht eingelegte Stimmenzettel",
                                         "Nicht teilgenommen"))
  
  if (length(ix_to_drop)) {
    html %<>% .[-ix_to_drop]
    field_names %<>% .[-ix_to_drop]
  }
  
  field_names %<>%
    dplyr::case_match(.x = .,
                      "Gebiet"                                          ~ "territory_name_de",
                      "\u2517\u2501 Stellung"                           ~ "territory_type_de",
                      "Datum"                                           ~ "date",
                      "Titel"                                           ~ "title_de",
                      "Vorlage"                                         ~ "title_de",
                      "\u2517\u2501 Fragemuster"                        ~ "question_type_de",
                      "\u2517\u2501 Abstimmungstyp"                     ~ "types",
                      "Ergebnis"                                        ~ "result_de",
                      "Vollst\u00e4ndigkeit"                            ~ "result_status_de",
                      "\u2517\u2501 Mehrheiten"                         ~ "adoption_requirements_de",
                      "Stimmberechtigte"                                ~ "electorate_total",
                      "\u2517\u2501 Davon im Ausland"                   ~ "electorate_abroad",
                      "Stimmausweise"                                   ~ "polling_cards",
                      "Ausgegebene Stimmzettel"                         ~ "polling_cards",
                      "Stimmbeteiligung"                                ~ "votes_total",
                      "Stimmen ausser Betracht"                         ~ "votes_invalid",
                      "Stimmzettel ausser Betracht"                     ~ "votes_invalid",
                      "Leere Stimmen"                                   ~ "votes_empty",
                      "\u2517\u2501 Leere Stimmen"                      ~ "votes_empty",
                      "\u2517\u2501 Leere Stimmzettel"                  ~ "votes_empty",
                      "Ung\u00fcltige Stimmen"                          ~ "votes_void",
                      "\u2517\u2501 Ung\u00fcltige Stimmen"             ~ "votes_void",
                      "\u2517\u2501 Ung\u00fcltige Stimmzettel"         ~ "votes_void",
                      "Ung\u00fcltig eingelegte Stimmzettel"            ~ "votes_void",
                      "Ganz ung\u00fcltige Stimmzettel"                 ~ "votes_void",
                      "G\u00fcltige (= massgebende) Stimmen"            ~ "votes_valid",
                      "\u2517\u2501 Ja-Stimmen"                         ~ "votes_yes",
                      "\u2517\u2501 Nein-Stimmen"                       ~ "votes_no",
                      "\u2517\u2501 Nein zu beiden Vorschl\u00e4gen"    ~ "votes_option_none",
                      "\u2517\u2501 Stimmen ausser Betracht"            ~ "votes_invalid",
                      "Staaten"                                         ~ "subterritories",
                      "\u2517\u2501 Annehmende Staaten"                 ~ "subterritories_yes",
                      "\u2517\u2501 Verwerfende Staaten"                ~ "subterritories_no",
                      "Gebiete"                                         ~ "subterritories",
                      "\u2517\u2501 Annehmende Gebiete"                 ~ "subterritories_yes",
                      "\u2517\u2501 Verwerfende Gebiete"                ~ "subterritories_no",
                      "Provinzen"                                       ~ "subterritories",
                      "\u2517\u2501 Annehmende Provinzen"               ~ "subterritories_yes",
                      "\u2517\u2501 Verwerfende Provinzen"              ~ "subterritories_no",
                      "Inseln"                                          ~ "subterritories",
                      "\u2517\u2501 Annehmende Inseln"                  ~ "subterritories_yes",
                      "\u2517\u2501 Verwerfende Inseln"                 ~ "subterritories_no",
                      "St\u00e4nde (Kantone)"                           ~ "subterritories",
                      "\u2517\u2501 Annehmende St\u00e4nde"             ~ "subterritories_yes",
                      "\u2517\u2501 Verwerfende St\u00e4nde"            ~ "subterritories_no",
                      "Regionen / St\u00e4dte"                          ~ "subterritories",
                      "\u2517\u2501 Annehmende Regionen / St\u00e4dte"  ~ "subterritories_yes",
                      "\u2517\u2501 Verwerfende Regionen / St\u00e4dte" ~ "subterritories_no",
                      "Wahlkreise"                                      ~ "subterritories",
                      "\u2517\u2501 Annehmende Wahlkreise"              ~ "subterritories_yes",
                      "\u2517\u2501 Verwerfende Wahlkreise"             ~ "subterritories_no",
                      "Senatswahlkreise"                                ~ "subterritories",
                      "\u2517\u2501 Annehmende Senatswahlkreise"        ~ "subterritories_yes",
                      "\u2517\u2501 Verwerfende Senatswahlkreise"       ~ "subterritories_no",
                      "Medien"                                          ~ "files",
                      "Bemerkungen"                                     ~ "remarks",
                      "Gleichzeitig mit"                                ~ "ids_sudd_simultaneous",
                      "Quellen"                                         ~ "sources",
                      "Letzte \u00c4nderung"                            ~ "date_last_edited",
                      .default = .) %>%
    # assert field names are unique
    checkmate::assert_character(any.missing = FALSE,
                                unique = TRUE,
                                .var.name = "field_names") %>%
    # referendum-option-specific recodings (sequentially numbered `votes_option_#` columns)
    # TODO: adapt this to new `referendums.option_label` variable that can capture more than yes/no answer options
    purrr::map_at(.at = which(startsWith(., "\u2517\u2501 ")),
                  .f = \(old_name, old_names) paste0("votes_option_", which(old_names == old_name)),
                  old_names = stringr::str_subset(string = .,
                                                  pattern = "^\u2517\u2501 ")) %>%
    purrr::list_c(ptype = character())

  # assert no original uppercase field names are left over
  ix_field_names_unknown <-
    field_names |>
    stringr::str_detect(pattern = "[:upper:]") |>
    which()
  
  if (length(ix_field_names_unknown)) {
    cli::cli_abort(paste0("Unknown {cli::qty(length(ix_field_names_unknown))} field{?s} {.field {field_names[ix_field_names_unknown]}} present in data for ",
                          "referendum with {.arg {paste0('id_sudd = ', id_sudd)}}."),
                   .internal = TRUE)
  }
  
  purrr::map2_dfc(.x = html,
                  .y = field_names,
                  .f = \(html, col_name) {
                    
                    cells <- html |> rvest::html_elements(css = "td")
                    col_text <- rvest::html_text2(cells[[2L]])
                    
                    # extract hyperlinks if necessary
                    if (col_name %in% c("remarks",
                                        "ids_sudd_simultaneous",
                                        "sources")) {
                      urls <-
                        cells[[2L]] |>
                        rvest::html_elements(css = "a") |>
                        purrr::map_chr(\(x) {
                          x |>
                            rvest::html_attr(name = "href") |>
                            url_sudd()
                        })
                    }
                    
                    tibble::tibble(!!col_name :=
                                     col_name |>
                                     pal::when(
                                       # character scalars
                                       . %in% c("territory_name_de",
                                                "territory_type_de",
                                                "title_de",
                                                "question_type_de",
                                                "result_de",
                                                "result_status_de") ~
                                         col_text,
                                       
                                       # integer scalars
                                       stringr::str_detect(
                                         string = .,
                                         pattern = paste0(
                                           "^",
                                           pal::fuse_regex(
                                             "electorate_total",
                                             "electorate_abroad",
                                             "polling_cards",
                                             "votes_total",
                                             "votes_invalid",
                                             "votes_empty",
                                             "votes_void",
                                             "votes_valid",
                                             "votes_yes",
                                             "votes_no",
                                             "votes_proposal",
                                             "votes_counter_proposal",
                                             paste0("votes_",
                                                    pal::fuse_regex("option_(\\d+|none)",
                                                                    "(counter_)?proposal",
                                                                    "tie_breaker(_(option_\\d+|(counter_)?proposal))?"),
                                                    paste0("(_",
                                                           pal::fuse_regex("total",
                                                                           "empty",
                                                                           "void",
                                                                           "invalid",
                                                                           "valid",
                                                                           "yes",
                                                                           "no"),
                                                           ")?"))),
                                           "$")) ~
                                         cells[[2L]] |>
                                         rvest::html_elements(css = "data") |>
                                         rvest::html_attr("value") |>
                                         # fall back to parsing text if no semantic data could be extracted
                                         pal::when(length(.) == 0L ~ col_text |> stringr::str_remove_all(pattern = "[^\\d]"),
                                                   ~ .) |>
                                         as.integer(),
                                       
                                       startsWith(., "subterritories") ~
                                         cells[[2L]] |>
                                         rvest::html_elements(css = "data") |>
                                         rvest::html_attr("value") |>
                                         # fall back to parsing text if no semantic data could be extracted
                                         pal::when(length(.) == 0L ~ col_text |> stringr::str_remove_all(pattern = "[^\\d]"),
                                                   ~ .) |>
                                         as.numeric(),
                                       
                                       # date scalars
                                       . == "date" ~
                                         cells[[2L]] |>
                                         rvest::html_element(css = "time") |>
                                         rvest::html_attr(name = "datetime"),
                                       
                                       . == "date_last_edited" ~
                                         cells[[2L]] |>
                                         rvest::html_element(css = "time") |>
                                         rvest::html_attr(name = "datetime") |>
                                         clock::date_parse(),
                                       
                                       # lists (multi-value cols)
                                       . == "remarks" ~
                                         remarks_list_col,
                                       
                                       . == "sources" ~
                                         list(list(text = col_text,
                                                   urls = urls,
                                                   html =
                                                     cells[[2L]] |>
                                                     xml2::xml_contents() |>
                                                     as.character() |>
                                                     paste0(collapse = ""))),
                                       . == "types" ~
                                         col_text |> stringr::str_split(pattern = "\\s*\u2192\\s*"),
                                       . == "adoption_requirements_de" ~
                                         col_text |> stringr::str_split(pattern = ",\\s*"),
                                       . == "files" ~
                                         cells[[2L]] |>
                                         rvest::html_elements(css = "a") |>
                                         purrr::map(\(x) {
                                           x |>
                                             rvest::html_attr(name = "href") |>
                                             url_sudd() |>
                                             tibble::tibble(description = rvest::html_text(x),
                                                            url = _)
                                         }) |>
                                         purrr::list_rbind() |>
                                         list(),
                                       . == "ids_sudd_simultaneous" ~
                                         urls |>
                                         stringr::str_extract(pattern = "(?<=[\\?&]id=)[\\w\\d]+") |>
                                         list(),
                                       
                                       ~ "PARSING ERROR; PLEASE DEBUG"
                                     ))
                  })
}

url_sudd <- function(x = "") {

  purrr::map_chr(x,
                 \(x) {
                   
                   if (!is.na(x) && stringr::str_detect(x, "https?:")) {
                     x
                   } else {
                     httr2::url_build(list(scheme = "https",
                                           hostname = "sudd.ch",
                                           path = x %|% ""))
                   }
                 })
}

this_pkg <- utils::packageName()

ballot_date_colnames <- c("supranational_entity_id",
                          "country_code",
                          "country_code_long",
                          "country_code_continual",
                          "country_name",
                          "country_name_long",
                          "subnational_entity_code",
                          "subnational_entity_name",
                          "municipality_name",
                          "level",
                          "date",
                          "week",
                          "month",
                          "quarter",
                          "year",
                          "decade",
                          "century",
                          "era",
                          "wave_of_democracy",
                          "is_former_country",
                          "un_country_code",
                          "un_region_tier_1_code",
                          "un_region_tier_1_name",
                          "un_region_tier_2_code",
                          "un_region_tier_2_name",
                          "un_region_tier_3_code",
                          "un_region_tier_3_name",
                          "un_subregion")

cli_theme <-
  cli::builtin_theme() |>
  purrr::list_modify(span.err = list(color = "red",
                                     `font-weight` = "bold"),
                     span.warn = list(color = "orange",
                                     `font-weight` = "bold"),
                     span.content = list(color = "mediumorchid"))

codebook_fragments <- c("institution-level-variables",
                        "referendum-level-variables",
                        "topics")

color_rdb_main <- "#3f4eff"

date_backup_rdb <- pal::path_mod_time("data-raw/backups/rdb.rds") |> clock::as_date()

neon_project <- "neon_rdb"
neon_project_id <- "curly-rain-52896163"

nocodb_base_title <- "Main"
nocodb_data_src_alias <- "RDB"

nocodb_col_metadata <- tibble::tribble(
  ~tbl_name,              ~col_name,     ~title,                 ~title_new,            ~uidt,                 ~meta.richMode, ~hidden,
  "referendum_types",     NA_character_, "actors",               "trigger_actor",       "LinkToAnotherRecord", NA,             FALSE,
  "referendums",          "attachments", NA_character_,          NA_character_,         "Attachment",          NA,             FALSE,
  NA_character_,          "url",         NA_character_,          NA_character_,         "URL",                 NA,             FALSE,
  NA_character_,          "description", NA_character_,          NA_character_,         NA_character_,         TRUE,           FALSE,
  NA_character_,          "label",       NA_character_,          NA_character_,         NA_character_,         TRUE,           FALSE,
  NA_character_,          "remarks",     NA_character_,          NA_character_,         NA_character_,         TRUE,           FALSE,
  "subnational_entities", NA_character_, "subnational_entities", NA_character_,         "LinkToAnotherRecord", NA,             TRUE
)

nocodb_reset_caution <- paste0("Beware that this results in **loss of all existing NocoDB-specific metadata** ",
                               "([comments](https://docs.nocodb.com/records/expand-record/#record-comment), ",
                               "[audit](https://docs.nocodb.com/records/expand-record/#record-audit) ",
                               "[logs](https://docs.nocodb.com/data-sources/actions-on-data-sources/#audit-logs) etc.).")

pg_db <- "rdb"
pg_port <- 5432L
pg_schema <- "public"
pg_client_min_messages <- c("DEBUG5", "DEBUG4", "DEBUG3", "DEBUG2", "DEBUG1", "LOG", "NOTICE", "WARNING", "ERROR")

s3_bucket_attachments <- "rdb-attachments"
s3_endpoint_url <- "https://s3.eu-central-003.backblazeb2.com"
s3_region <- stringr::str_extract(string = s3_endpoint_url,
                                  pattern = "^https://s3\\.(.*?)\\.",
                                  group = 1L)

sudd_years <-
  url_sudd("index.php") %>%
  xml2::read_html() %>%
  rvest::html_element(css = "select[id='first']") %>%
  rvest::html_elements("option") %>%
  rvest::html_attr("value") %>%
  as.integer()

sudd_max_year <- pal::safe_max(sudd_years)
sudd_min_year <- pal::safe_min(sudd_years)
rm(sudd_years)

tbl_metadata <-
  tibble::tribble(
    ~name,                          ~dm_color,      ~nocodb_display_col, ~nocodb_meta.icon, ~is_aux, ~is_admin,
    "actors",                       "#cf3dff",      "label",             "\U0001F3AD",      FALSE,   FALSE,
    "options",                      "#cf3dff",      "display",           "\u2611",          FALSE,   FALSE,
    "legal_instruments",            "#c2f0c2",      "display",           "\U0001F4DC",      FALSE,   FALSE,
    "legal_norms",                  "#64d864",      "display",           "\u2712",          FALSE,   FALSE,
    "referendum_types",             "#64d864",      "display",           "\U0001F3DB",      FALSE,   FALSE,
    "referendum_clusters",          "#b3b9ff",      "id",                "\U0001F347",      FALSE,   FALSE,
    "referendums",                  color_rdb_main, "display",           "\U0001F5F3",      FALSE,   FALSE,
    "referendum_types_legal_norms", "#c2f0c2",      NA_character_,       NA_character_,     FALSE,   FALSE,
    "referendum_types_referendums", "#c2f0c2",      NA_character_,       NA_character_,     FALSE,   FALSE,
    "topics_referendums",           "#b3b9ff",      NA_character_,       NA_character_,     FALSE,   FALSE,
    "referendum_titles",            "#b3b9ff",      "title",             "\U0001F4D5",      FALSE,   FALSE,
    "referendum_questions",         "#b3b9ff",      "question",          "\u2753",          FALSE,   FALSE,
    "referendum_urls",              "#b3b9ff",      "url",               "\U0001f517",      FALSE,   FALSE,
    "referendum_positions",         "#b3b9ff",      "display",           "\U0001F4E3",      FALSE,   FALSE,
    "referendum_votes",             "#b3b9ff",      "option_display",    "\U0001F9FE",      FALSE,   FALSE,
    "referendum_sub_votes",         "#b3b9ff",      "display",           "\U0001F9FE",      FALSE,   FALSE,
    "administrative_units",         "#ffcf3d",      "name",              "\U0001F512",      FALSE,   TRUE,
    "supranational_entities",       "#ffecb3",      "name",              "\U0001F512",      TRUE,    TRUE,
    "countries",                    "#ffecb3",      "name",              "\U0001F512",      TRUE,    TRUE,
    "subnational_entities",         "#ffecb3",      "name",              "\U0001F512",      TRUE,    TRUE,
    "municipalities",               "#ffecb3",      "name",              "\U0001F512",      TRUE,    TRUE,
    "languages",                    "#ffcf3d",      "name",              "\U0001F512",      FALSE,   TRUE,
    "topics",                       "#ffcf3d",      "name",              "\U0001F512",      FALSE,   TRUE,
    "nocodb_users",                 "#000000",      "nocodb_id",         "\U0001F512",      TRUE,    TRUE
  ) |>
  # add `desc` col separately (otherwise col vals exceed screen width too easily)
  dplyr::left_join(
    by = "name",
    y = tibble::tribble(
      ~name,                          ~desc,
      "actors",                       "entities acting in connection with referendums",
      "options",                      "referendum answer options",
      "legal_instruments",            "legal instruments covering the regulation of referendums",
      "legal_norms",                  "legal norms enabling referendums",
      "referendum_types",             "referendum types",
      "referendum_clusters",          "referendums clusters",
      "referendums",                  "***main table***",
      "referendum_types_legal_norms", "*junction table:* `referendum_types` \u2194 `legal_norms`",
      "referendum_types_referendums", "*junction table:* `referendum_types` \u2194 `referendums`",
      "topics_referendums",           "*junction table:* `topics` \u2194 `referendums`",
      "referendum_titles",            "referendum titles",
      "referendum_questions",         "referendum questions",
      "referendum_urls",              "referendum URLs",
      "referendum_positions",         "actor positions on referendums",
      "referendum_votes",             "votes cast in referendums",
      "referendum_sub_votes",         "votes cast in referendums by subnational entity",
      "administrative_units",         "administrative units on all political levels",
      "supranational_entities",       "administrative units on the supranational level",
      "countries",                    paste0("administrative units on the national level (conforming to the ISO ",
                                             "[3166-1](https://en.wikipedia.org/wiki/ISO_3166-1)/[3166-3](https://en.wikipedia.org/wiki/ISO_3166-3) ",
                                             "standards)"),
      "subnational_entities",         paste0("administrative units on the subnational level (conforming to the ",
                                             "[ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) standard)"),
      "municipalities",               "administrative units on the municipal level",
      "languages",                    "languages (conforming to the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) standard)",
      "topics",                       "political topics to classify referendums",
      "nocodb_users",                 "NocoDB *user identifer* \u2194 *name* mapping"
    )) |>
  assertr::assert(predicate = assertr::not_na,
                  name, desc) |>
  dplyr::relocate(desc,
                  .after = name) |>
  # add Unicode image variation selector
  dplyr::mutate(nocodb_meta.icon = dplyr::if_else(is.na(nocodb_meta.icon),
                                                  nocodb_meta.icon,
                                                  paste0(nocodb_meta.icon, "\ufe0f")))

# for renaming between C2D Services API and RDB
#                 old name                                               new name
var_names <- list(`_id`                                                = "id",
                  canton                                               = "subnational_entity_name",
                  municipality                                         = "municipality_name",
                  title.de                                             = "title_de",
                  title.en                                             = "title_en",
                  title.fr                                             = "title_fr",
                  context.states_no                                    = "subterritories_no",
                  context.states_yes                                   = "subterritories_yes",
                  total_electorate                                     = "electorate_total",
                  citizens_abroad                                      = "electorate_abroad",
                  context.votes_per_canton                             = "votes_per_subterritory",
                  context.national_council_yes                         = "lower_house_yes",
                  context.national_council_no                          = "lower_house_no",
                  context.national_council_abstentions                 = "lower_house_abstentions",
                  context.states_council_yes                           = "upper_house_yes",
                  context.states_council_no                            = "upper_house_no",
                  context.states_council_abstentions                   = "upper_house_abstentions",
                  context.recommendation                               = "position_government",
                  draft                                                = "is_draft",
                  created_on                                           = "created_at",
                  date_time_last_edited                                = "updated_at",
                  institution                                          = "type",
                  categories.official_status                           = "inst_legal_basis_type",
                  categories.legal_act_type                            = "inst_has_urgent_legal_basis",
                  categories.vote_result_status                        = "inst_is_binding",
                  categories.counter_proposal                          = "inst_is_counter_proposal",
                  categories.vote_venue                                = "inst_is_assembly",
                  categories.vote_trigger                              = "inst_trigger_type",
                  categories.vote_trigger_actor                        = "inst_trigger_actor",
                  categories.vote_trigger_state_level                  = "inst_trigger_actor_level",
                  categories.vote_trigger_number                       = "inst_trigger_threshold",
                  categories.vote_trigger_time                         = "inst_trigger_time_limit",
                  categories.vote_object                               = "inst_object_type",
                  categories.author_of_the_vote_object                 = "inst_object_author",
                  categories.hierarchy_of_the_legal_norm               = "inst_object_legal_level",
                  categories.degree_of_revision                        = "inst_object_revision_extent",
                  categories.action                                    = "inst_object_revision_modes",
                  categories.turnout_quorum                            = "inst_quorum_turnout",
                  categories.decision_quorum                           = "inst_quorum_approval",
                  categories.institutional_precondition                = "inst_has_precondition",
                  categories.institutional_precondition_decision_actor = "inst_precondition_actor",
                  categories.institutional_precondition_decision       = "inst_precondition_decision",
                  categories.special_topics                            = "inst_topics_only",
                  categories.excluded_topics                           = "inst_topics_excluded")

#                                  old name     new name
sub_var_names <- list(files = list(date       = "date_time_attached",
                                   object_key = "s3_object_key",
                                   size       = "file_size",
                                   deleted    = "is_deleted"))

# create additional formula-lists (mainly to be fed to `dplyr::case_match()`)
var_names_fms <- as_fm_list(var_names)
sub_var_names_fms <- purrr::map(sub_var_names,
                                \(x) as_fm_list(x))

#' Get RDB data model
#'
#' @inheritParams rfrnds
#' @param incl_admin_tbls Whether or not to include tables that are administered fully programmatically 
#'   (`r tbl_metadata |> dplyr::filter(is_admin) |> dplyr::pull("name") |> pal::enum_str(wrap = "\x60")`).
#' @param incl_aux_admin_tbls Whether or not to include the auxiliary administrative unit tables
#'   `r tbl_metadata |> dplyr::filter(is_aux) |> dplyr::pull("name") |> pal::enum_str(wrap = "\x60")`.
#'
#' @return `r pkgsnip::return_lbl("dm")`
#' @family admin
#' @export
#'
#' @examples
#' # visualize the whole RDB model
#' rdb::dm() |> dm::dm_draw(view_type = "all")
#' 
#' # download all RDB tables into local object (e.g. for later processing)
#' rdb_dm <- rdb::dm() |> dplyr::collect()
dm <- function(connection = connect(user = "rdb_admin",
                                    password = pg_role_pw("rdb_admin")),
               incl_admin_tbls = TRUE,
               incl_aux_admin_tbls = FALSE) {
  
  checkmate::assert_flag(incl_admin_tbls)
  checkmate::assert_flag(incl_aux_admin_tbls)
  
  tbl_metadata_subset <-
    tbl_metadata |>
    dplyr::filter(if (incl_admin_tbls) TRUE else !is_admin) |>
    dplyr::filter(if (incl_aux_admin_tbls) TRUE else !is_aux)
  
  tbl_metadata_subset |>
    dplyr::pull("name") |> 
    dm::dm_from_con(con = connection,
                    # NOTE: we have to explicitly set `table_names` in order to avoid a spurious "NA" table linked to everything else
                    table_names = _,
                    learn_keys = TRUE,
                    schema = pg_schema) |>
    dm::dm_set_colors(!!!magrittr::set_names(x = tbl_metadata_subset$name,
                                             value = tbl_metadata_subset$dm_color)) |>
    dm::dm_set_table_description(!!!magrittr::set_names(x = tbl_metadata_subset$name,
                                                        value = pal::strip_md(tbl_metadata_subset$desc)))
}

#' Get referendum data
#'
#' Downloads the referendum data from the Referendum Database (RDB). See the [`codebook`] for a detailed description of all variables.
#'
#' @inheritParams read_tbl
#' @param incl_drafts Whether or not to include database entries with _draft_ status.
#' @param use_cache `r pkgsnip::param_lbl("use_cache")`
#' @param max_cache_age `r pkgsnip::param_lbl("max_cache_age")`
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family data
#' @export
#'
#' @examples
#' # get all referendums (excl. drafts)
#' rdb::rfrnds()
rfrnds <- function(connection = connect(),
                   disconnect = TRUE,
                   incl_drafts = FALSE,
                   use_cache = TRUE,
                   max_cache_age = "1 week") {
  
  checkmate::assert_flag(incl_drafts)
  
  pkgpins::with_cache(
    expr = {
      
      read_tbl(tbl_name = "referendums",
               connection = connection,
               disconnect = disconnect) |>
        # parse NocoDB attachment col to sub-tibble
        dplyr::mutate(attachments = purrr::map(attachments,
                                               \(x) {
                                                 
                                                 if (is.na(x) || x == "[]") {
                                                   return(NULL)
                                                 }
                                                 
                                                 tibble::as_tibble(jsonlite::fromJSON(txt = x))
                                               })) |>
        dplyr::filter(is_draft %in% c(FALSE, incl_drafts))
    },
    pkg = this_pkg,
    from_fn = "rfrnds",
    incl_drafts,
    use_cache = use_cache,
    max_cache_age = max_cache_age
  )
}

#' Get *old* referendum data
#'
#' Downloads the latest backup of the old referendum data from the Referendum Database (RDB). See the [`codebook`] for a detailed description of all
#' variables.
#'
#' @inheritParams rfrnds
#' @param incl_archive Whether or not to include an `archive` column containing data from an earlier, obsolete state of the Referendum Database (RDB).
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family data
#' @keywords internal
#'
#' @examples
#' # get all referendums (excl. drafts)
#' rdb::rfrnds_old()
rfrnds_old <- function(is_draft = FALSE,
                       incl_archive = FALSE,
                       use_cache = TRUE,
                       max_cache_age = "1 week",
                       quiet = FALSE) {
  
  checkmate::assert_flag(is_draft,
                         null.ok = TRUE)
  checkmate::assert_flag(incl_archive)
  checkmate::assert_flag(quiet)
  
  result <- pkgpins::with_cache(
    expr = {
      
      if (!quiet) {
        pal::cli_progress_step_quick(msg = "Fetching latest RDB backup")
      }
      
      path_temp <- fs::file_temp(pattern = "rdb-", ext = "rds")
      utils::download.file(url = "https://gitlab.com/zdaarau/rpkgs/rdb/-/raw/master/data-raw/backups/rdb.rds?ref_type=heads&inline=false",
                           destfile = path_temp,
                           quiet = TRUE,
                           mode = "wb")
      
      readRDS(file = path_temp)
    },
    pkg = this_pkg,
    from_fn = "rfrnds_old",
    use_cache = use_cache,
    max_cache_age = max_cache_age
  )
  
  # exclude `archive` if requested
  if (!incl_archive) {
    result %<>% dplyr::select(-any_of("archive"))
  }
  
  # respect `is_draft`
  if (!is.null(is_draft)) {
    result %<>% dplyr::filter(is_draft == !!is_draft)
  }
  
  result
}

#' Get legal bases data
#'
#' Downloads the legal bases data from the Referendum Database (RDB). See the [`codebook`] for a detailed description of all variables.
#'
#' @inheritParams rfrnds
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family data
#' @export
#'
#' @examples
#' # get all legal bases
#' rdb::rfrnd_types()
rfrnd_types <- function(connection = connect(),
                        disconnect = TRUE,
                        incl_drafts = FALSE,
                        use_cache = TRUE,
                        max_cache_age = "1 week") {
  
  checkmate::assert_flag(incl_drafts)
  
  pkgpins::with_cache(
    expr = {
      
      read_tbl(tbl_name = "referendum_types",
               connection = connection,
               disconnect = disconnect) |>
        dplyr::filter(is_draft %in% c(FALSE, incl_drafts))
    },
    pkg = this_pkg,
    from_fn = "rfrnd_types",
    use_cache = use_cache,
    max_cache_age = max_cache_age
  )
}

#' Read in RDB table
#'
#' Fetches a table from the [RDB DBMS][connect]'s `r pal::wrap_chr(pg_schema, "\x60")` schema and returns it as a [tibble][tibble::tbl_df].
#'
#' @inheritParams pg_tbl_read
#' @param tbl_name `r pkgsnip::type("chr", 1)`
#'   Table name. One of
#'   `r pal::as_md_val_list(tbl_metadata$name)`
#'
#' @return `r pkgsnip::param_lbl("tibble")`
#' @family data
#' @export
#'
#' @examples
#' rdb::read_tbl("countries")
read_tbl <- function(tbl_name = tbl_metadata$name,
                     connection = connect(),
                     disconnect = TRUE) {
  
  tbl_name <- rlang::arg_match(tbl_name)
  
  pg_tbl_read(tbl_name = tbl_name,
              connection = connection,
              disconnect = disconnect)
}

#' Update RDB table
#'
#' Updates the specified RDB table with the provided data.
#'
#' @inheritParams pg_tbl_update
#' @inheritParams rfrnds
#'
#' @return `data`, invisibly.
#' @family admin
#' @export
update_tbl <- function(data,
                       tbl_name = tbl_metadata$name,
                       sweep = FALSE,
                       override_pk_sys_val = FALSE,
                       connection = connect(),
                       disconnect = TRUE) {
  
  tbl_name <- rlang::arg_match(tbl_name)
  checkmate::assert_flag(disconnect)
  
  # necessary to avoid error on first run of `connect()`
  force(connection)
  
  dplyr::tbl(src = connection,
             from = DBI::Id(schema = pg_schema,
                            table = tbl_name)) |>
    pg_tbl_update(data = data,
                  tbl_name = tbl_name,
                  sweep = sweep,
                  override_pk_sys_val = override_pk_sys_val,
                  connection = connection)
  
  if (disconnect) {
    DBI::dbDisconnect(conn = connection)
  }
  
  invisible(data)
}

#' Validate referendum data
#'
#' Performs various data validation steps to ensure there are no errors in the supplied `data`.
#'
#' @param data Referendum data to validate, as returned by [rfrnds()].
#' @param check_applicability_constraint Whether or not to check that no applicability constraints as defined in the [`codebook`] are violated.
#' @param check_id_sudd_prefix Whether or not to check that all [`id_sudd`](`r url_codebook("id_sudd")`) prefixes are valid.
#'
#' @return `data`, invisibly.
#' @family data
#' @keywords internal
validate_rfrnds <- function(data,
                            check_applicability_constraint = TRUE,
                            check_id_sudd_prefix = TRUE) {
  
  checkmate::assert_data_frame(data,
                               min.rows = 1L)
  checkmate::assert_subset(colnames(data),
                           choices = rfrnd_cols_order)
  checkmate::assert_flag(check_applicability_constraint)
  checkmate::assert_flag(check_id_sudd_prefix)
  
  # check columns
  cli_progress_id <- pal::cli_progress_step_quick(msg = "Checking basic column validity")
  
  assert_cols_valid(data = data,
                    type = "validate",
                    action = cli::cli_alert_warning,
                    cli_progress_id = cli_progress_id)
  
  # check applicability constraints
  if (check_applicability_constraint) {
    
    pal::cli_progress_step_quick(msg = "Asserting applicability constraints")
    
    var_names_violated <-
      data_codebook %>%
      dplyr::filter(variable_name %in% colnames(data)
                    & !is.na(applicability_constraint)) %$%
      purrr::map2_lgl(.x = magrittr::set_names(x = variable_name,
                                               value = variable_name),
                      .y = applicability_constraint,
                      .f = \(x, y) {
                        
                        data %>%
                          dplyr::filter(!eval(parse(text = y))) %$%
                          eval(as.symbol(x)) %>%
                          { is.na(.) | purrr::map_lgl(., is.null) } %>%
                          all()
                      }) %>%
      magrittr::extract(!.) %>%
      names()
    
    n_var_names_violated <- length(var_names_violated)
    
    if (n_var_names_violated) {
      
      cli::cli_progress_done(result = "failed")
      cli::cli_alert_warning("Applicability constraints are violated for {n_var_names_violated} variable{?s}:")
      
      paste0("{.var ", var_names_violated, "}") %>%
        magrittr::set_names(rep("x",
                                times = length(.))) %>%
        cli::cli_bullets()
      
      first_var_name_violated <- var_names_violated[1L]
      
      cli::cli({
        cli::cli_text("\nTo get the applicability constraint of e.g. {.var {first_var_name_violated}}, run:")
        cli::cli_text("")
        cli::cli_code(c("rdb::data_codebook %>%",
                        glue::glue("  dplyr::filter(variable_name == \"{first_var_name_violated}\") %$%"),
                        "  applicability_constraint"))
        cli::cli_text("")
        cli::cli_text("To inspect the entries in violation of the above applicability constraint, run:")
        cli::cli_text("")
        cli::cli_code(c("data %>%",
                        glue::glue("  dplyr::filter(rdb::data_codebook %>%\n",
                                   "                  dplyr::filter(variable_name == \"{first_var_name_violated}\") %$%\n",
                                   "                  applicability_constraint %>%\n",
                                   "                  parse(text = .) %>%\n",
                                   "                  eval() %>%\n",
                                   "                  magrittr::not()) %>%\n",
                                   "  dplyr::select(id, {first_var_name_violated})",
                                   .trim = FALSE)))
      })
    }
  }
  
  # check `id_sudd` prefix if requested
  if (check_id_sudd_prefix) {
    
    pal::cli_progress_step_quick(msg = "Validating {.var id_sudd} prefixes")
    
    if (!all(c("country_code", "id_sudd") %in% colnames(data))) {
      cli::cli_progress_done(result = "failed")
      cli::cli_abort("Columns {.var country_code} and {.var id_sudd} must be present in {.arg data}.")
    }
    
    # define allowed exceptions
    allowed_exceptions <- tibble::tribble(
      ~country_code, ~id_sudd_prefix,
      # Curacao
      "CW", "an",
      # Szeklerland, cf. https://sudd.ch/event.php?id=hu042008
      "RO", "hu"
    )
    
    # assemble target country codes
    country_codes <-
      data$country_code %>%
      as.character() %>%
      as.list()
    
    for (country_code in allowed_exceptions$country_code) {
      
      additional_country_codes <-
        allowed_exceptions %>%
        dplyr::filter(country_code == !!country_code) %$%
        id_sudd_prefix %>%
        stringr::str_to_upper()
      
      ix_country_codes <-
        country_codes %>%
        purrr::map_lgl(\(x) country_code %in% x) %>%
        which()
      
      for (i in ix_country_codes) {
        country_codes[[i]] <- unique(c(country_codes[[i]], additional_country_codes))
      }
    }
    
    # add dummy indicating if target country codes match
    # TODO: instead of modifying input data, print cli msg with all relevant info!
    data$matches_id_sudd_prefix <-
      data$id_sudd %>%
      stringr::str_extract(pattern = "^..") %>%
      stringr::str_to_upper() %>%
      purrr::map2_lgl(.y = country_codes,
                      .f = \(x, y) {
                        x %in% y
                      })
    
    data$matches_id_sudd_prefix[is.na(data$id_sudd)] <- NA
  }
  
  invisible(data)
}

#' Assert referendum variables are present
#'
#' Asserts that the input [is a data frame][checkmate::assert_data_frame] and that the specified variables are present. Depending on `var_names`, further
#' integrity checks are performed.
#'
#' @param data RDB referendum data as returned by [rfrnds()].
#' @param var_names Names of the variables to check. A character vector.
#'
#' @return `data`, invisibly.
#' @family data
#' @export
#'
#' @examples
#' rdb::rfrnds() |> rdb::assert_vars(var_names = "country_code")
#' 
#' try(
#'   tibble::tibble(country_code = "AN") |> rdb::assert_vars(var_names = "country_code")
#' )
assert_vars <- function(data,
                        var_names) {
  
  checkmate::assert_data_frame(data)
  
  var_names %>% purrr::walk(\(var_name) {
    
    msg_suffix <- switch(EXPR         = var_name,
                         country_code = " with ISO 3166-1 alpha-2 or ISO 3166-3 alpha-4 codes.",
                         "")
    
    if (!(var_name %in% colnames(data))) {
      cli::cli_abort(paste0("{.arg data} must contain a column {.var {var_name}}", msg_suffix))
    }
    
    # run additional content check
    assert_content <- switch(EXPR         = var_name,
                             country_code = \(x) {
                               
                               checkmate::assert_vector(x = x,
                                                        .var.name = "data$country_code")
                               check <- checkmate::check_subset(x = as.character(x),
                                                                choices = val_set$country_code)
                               if (!isTRUE(check)) {
                                 
                                 expired_codes <- intersect(as.character(x),
                                                            data_iso_3166_3$alpha_2_old)
                                 cli::cli_abort(paste0(
                                   "Assertion on {.var data$country_code} failed: ",
                                                       ifelse(length(expired_codes),
                                                              paste0("The following country codes have been deleted from ISO 3166-1 and were moved to ISO ",
                                                                     "3166-3 (former countries) instead: {.val {expired_codes}}"),
                                                              # escape curly braces from checkmate msg
                                                              stringr::str_replace_all(string = check,
                                                                                       pattern = "([\\{\\}])",
                                                                                       replacement = "\\1\\1"))))
                               }
                             },
                             \(x) TRUE)
    
    assert_content(data[[var_name]])
  })
  
  invisible(data)
}

#' Download file attachments
#'
#' Downloads file attachments from the Referendum Database (RDB). ... the `attachments` list column returned by [rfrnds()].
#'
#' @param data RDB referendum data as returned by [rfrnds()]. A data frame that at minimum contains the columns `id` and `attachments`.
#' @param path Path to the directory where the downloaded file(s) are to be written to.
#' @param filename_from_title Whether to use an attachment's `title` field value as the filename. Note that attachment titles are **not guaranteed to be
#'   unique**, i.e. there can be multiple file attachments with the same title (but differing content, of course). If `FALSE`, the referendum identifier plus a
#'   sequential number is used as an attachment's filename.
#' @param fileext_from_mimetype Whether to add a file extension suffix to the filename which is determined from the attachment's `mimetype` field.
#'
#' @return `data`, invisibly.
#' @family attachments
#' @export
#'
#' @examples
#' # get the first three referendums which contain attachments
#' d <-
#'   rdb::rfrnds() |>
#'   dplyr::filter(purrr::map_lgl(attachments, \(x) !is.null(x))) |>
#'   dplyr::filter(dplyr::row_number() %in% 1:3)
#'
#' # download the attachments to the current directory
#' d |> rdb::download_attachments()
#' 
#' # and delete them again
#' d$attachments |>
#'   purrr::map(\(x) x$title) |>
#'   unlist() |>
#'   fs::file_delete()
download_attachments <- function(data,
                                 path = ".",
                                 filename_from_title = FALSE,
                                 fileext_from_mimetype = !filename_from_title) {
  assert_vars(data = data,
              var_names = c("id", "attachments"))
  checkmate::assert_directory_exists(path,
                                     access = "rw")
  checkmate::assert_flag(filename_from_title)
  checkmate::assert_flag(fileext_from_mimetype)
  
  data |>
    dplyr::select("id", "attachments") |>
    purrr::pwalk(\(id, attachments) {
      
      assert_vars(data = attachments,
                  var_names = c("url", "title", "mimetype")) |>
        tibble::rowid_to_column() |>
        dplyr::select("url", "rowid", "title", "mimetype") |>
        purrr::pwalk(\(url, rowid, title, mimetype) utils::download.file(url = url,
                                                                         destfile = fs::path(path,
                                                                                             ifelse(filename_from_title,
                                                                                                    title,
                                                                                                    paste(id, rowid, sep = "_")),
                                                                                             ext = ifelse(fileext_from_mimetype,
                                                                                                          pal::mime_to_ext(mime_type = mimetype,
                                                                                                                           quiet = TRUE) %|% "",
                                                                                                          "")),
                                                                         mode = "wb",
                                                                         quiet = TRUE))
    })
  
  invisible(data)
}

#' Clean referendum attachments
#'
#' Deletes obsolete attachment files from the specified S3-compatible object storage bucket. An attachment is considered obsolete if it isn't linked to any
#' referendum in the RDB.
#'
#' @param s3_bucket Name of the S3-compatible object storage bucket where the referendum attachments reside.
#' @param s3_endpoint S3-compatible endpoint URL where `s3_bucket` is located.
#' @param s3_access_key S3-compatible access key ID with access to `s3_bucket`.
#' @param s3_access_secret S3-compatible access secret with access to `s3_bucket`.
#' @param run_dry Whether or not to display the files to be deleted on the console instead of actually deleting any file.
#'
#' @return A character vector of deleted file attachment URLs.
#' @family attachments
#' @family admin
#' @export
clean_attachment_bucket <- function(s3_bucket = s3_bucket_attachments,
                                    s3_endpoint = s3_endpoint_url,
                                    s3_access_key = pal::pkg_config_val("nocodb_s3_access_key"),
                                    s3_access_secret = pal::pkg_config_val("nocodb_s3_access_secret"),
                                    run_dry = TRUE) {
  
  checkmate::assert_string(s3_bucket)
  checkmate::assert_flag(run_dry)
  
  s3_auth(s3_endpoint = s3_endpoint,
          s3_access_key = s3_access_key,
          s3_access_secret = s3_access_secret)
  
  s3_prefix <- paste0("s3://", s3_bucket, "/")
  url_prefix <- paste0("https://", s3_bucket, ".", httr2::url_parse(s3_endpoint)$hostname, "/")
  
  all_attachments <-
    s3fs::s3_dir_ls(fs::path(s3_bucket, "nc/uploads"),
                    recurse = TRUE) |>
    fs::path_rel(start = s3_prefix)
  
  valid_attachments <-
    rfrnds(use_cache = FALSE,
           incl_drafts = TRUE) |>
    dplyr::pull("attachments") |>
    purrr::map(\(x) x$url) |>
    purrr::list_c(ptype = character()) |>
    xml2::url_unescape() |>
    fs::path_rel(start = url_prefix)
  
  invalid_attachments <- setdiff(x = all_attachments,
                                 y = valid_attachments)
  invalid_attachment_urls <- paste0(url_prefix, fs::path(fs::path_dir(invalid_attachments), xml2::url_escape(fs::path_file(invalid_attachments))),
                                    recycle0 = TRUE)
  
  if (length(invalid_attachments) > 0L) {
    
    if (run_dry) {
      cli::cli_alert_info("Files that would be deleted with {.code run_dry = FALSE}:")
      cli::cli_li(items = purrr::map_chr(invalid_attachment_urls,
                                         \(x) cli::format_inline("{.url {x}}")))
    } else {
      s3fs::s3_file_delete(path = paste0(s3_prefix, invalid_attachments,
                                         recycle0 = TRUE))
      # delete obsolete thumbnails
      patterns <-
        invalid_attachments |>
        fs::path_rel(start = "nc/uploads/") |>
        rex::escape()
      
      s3fs::s3_dir_ls(fs::path(s3_bucket, "nc/thumbnails"),
                      recurse = TRUE) |>
        stringr::str_subset(pattern = rex::rex(or(patterns))) |>
        s3fs::s3_file_delete()
    }
  }
  
  invisible(invalid_attachment_urls)
}

#' ISO 3166-1 data
#'
#' [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) data, corrected and extended by unofficial information for countries which are not covered by the ISO
#' standard yet. See also the [Differences between SCCAI 2019 and ISO
#' 3166-1:2013](https://www.statcan.gc.ca/en/subjects/standard/sccai/2019/sccai2019-iso3166-12013) for inspiration on name corrections.
#'
#' @format `r pkgsnip::return_lbl("tibble")`
#' @family aux_data
#' @export
#'
#' @examples
#' rdb::data_iso_3166_1
"data_iso_3166_1"

#' ISO 3166-2 data
#'
#' @description
#' [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) data, extended by
#' 
#' - unofficial information for subnational entities which ceased to exist before the ISO standard was first published in 1998 – and hence don't have an
#'   official ISO 3166-2 code assigned. Such unofficial codes are of the form `AB-CUSTOM-1`, `AB-CUSTOM-2`, etc., where `AB` is the official [ISO 3166-1 alpha-2
#'   country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) and `CUSTOM-1`, `CUSTOM-2` etc. are sequential subdivision codes. Note that these custom
#'   codes are assigned in random order and have no further meaning.
#'
#' - information on the period of validity. Due to lack of official revocation information in ISO 3166-2, we construct our own (delayed) `valid_from` and
#'   `valid_to` date columns based on detected changes in [`ISOcodes::ISO_3166_2`].
#'
#' @format `r pkgsnip::return_lbl("tibble")`
#' @family aux_data
#' @export
#'
#' @examples
#' rdb::data_iso_3166_2
"data_iso_3166_2"

#' ISO 3166-3 data
#'
#' [ISO 3166-3](https://en.wikipedia.org/wiki/ISO_3166-3) data, extended by some deduced information.
#'
#' @format `r pkgsnip::return_lbl("tibble")`
#' @family aux_data
#' @export
#'
#' @examples
#' rdb::data_iso_3166_3
"data_iso_3166_3"

#' ISO 639-1 data
#'
#' [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) data.
#'
#' @format `r pkgsnip::return_lbl("tibble")`
#' @family aux_data
#' @export
#'
#' @examples
#' rdb::data_iso_639_1
"data_iso_639_1"

#' Municipality data
#'
#' Municipality data...
#'
#' Currently, municipalities in the following countries are covered by this dataset:
#' 
#' - [Switzerland](https://en.wikipedia.org/wiki/Community_Identification_Number#Switzerland)
#'
#' @format `r pkgsnip::return_lbl("tibble")`
#' @family aux_data
#' @export
#'
#' @examples
#' rdb::data_municipalities
"data_municipalities"

#' Topic hierarchy
#'
#' A tibble reflecting the complete [referendum topics hierarchy](`r url_codebook("topics")`).
#'
#' @format `r pkgsnip::return_lbl("tibble")`
#' @family aux_data
#' @family topics
#' @export
#'
#' @examples
#' rdb::data_topics
"data_topics"

#' RDB Codebook
#'
#' A tibble containing the complete metadata of all [rfrnds()] variables. The codebook below is also available [online](`r url_codebook()`).
#'
#' # Codebook
#'
#' ```{r, child = "vignettes/codebook.Rmd"}
#' ```
#'
#' @format `r pkgsnip::return_lbl("tibble")`
#' @aliases codebook
#' @family metadata
#' @export
#'
#' @examples
#' rdb::data_codebook
"data_codebook"

#' Get set of possible *value labels* of referendum data variable
#'
#' Returns a character vector of value labels of a specific [rfrnds()] column, in the same order as [var_vals()], or of length `0` if `var_name`'s values are
#' not restricted to a predefined set or no value labels are defined in the [`codebook`].
#'
#' @param var_name Variable name present in [`data_codebook`] for which the labels are to be returned. A character scalar.
#' @param incl_affixes Whether or not to add the corresponding `value_label_prefix` and `value_label_suffix` to the returned labels.
#'
#' @return A character vector. Of length `0` if `var_name`'s values are not restricted to a predefined set or no value labels are defined in the
#'   [`codebook`].
#' @family metadata
#' @export
#'
#' @examples
#' rdb::val_lbls("result",
#'               incl_affixes = FALSE)
#' rdb::val_lbls("result")
#' 
#' # Convert the labels to sentence case with trailing dot
#' rdb::val_lbls("result") |> pal::sentenceify()
val_lbls <- function(var_name,
                     incl_affixes = TRUE) {
  
  var_name <- rlang::arg_match0(arg = var_name,
                                values = rfrnd_cols_order)
  
  metadata <- data_codebook |> dplyr::filter(variable_name == !!var_name | variable_name_unnested == !!var_name)
  result <- metadata$value_labels |> purrr::list_c(ptype = character())
  
  if (incl_affixes) {
    if (!is.na(metadata$value_label_prefix)) result <- paste(metadata$value_label_prefix, result)
    if (!is.na(metadata$value_label_suffix)) result <- paste(metadata$value_label_suffix, result)
  }
  
  result
}

#' Get *value scale* of referendum data variables
#'
#' Returns the value scale of the specified [rfrnds()] columns.
#'
#' @param var_names Variable name(s) present in [`data_codebook`] for which the value scale is to be returned. A character vector.
#'
#' @return A character scalar.
#' @family metadata
#' @export
#'
#' @examples
#' rdb::val_scale("level")
#' paste0("topics_tier_", 1:3) |> rdb::val_scale()
val_scale <- function(var_names) {
  
  var_name <- rlang::arg_match(arg = var_names,
                               values = rfrnd_cols_order,
                               multiple = TRUE)
  
  c(data_codebook$value_scale,
    data_codebook$value_scale)[match(x = var_names,
                                     table = c(data_codebook$variable_name,
                                               data_codebook$variable_name_unnested))]
}

#' Get set of possible *values* of referendum data variable
#'
#' Returns a vector of the possible predefined values a specific column in [rfrnds()] can hold. If the variable values aren't restricted to a predefined
#' set, `NULL` is returned.
#'
#' @param var_name Variable name present in [`data_codebook`]. A character scalar.
#'
#' @return
#' If `var_name`'s values are restricted to a predefined set and
#' - `var_name` is *not* of type list, a vector of the same type as `var_name`.
#' - `var_name` is of type list, a vector of the same type as the elements of `var_name`.
#'
#' Else `NULL`.
#' @family metadata
#' @export
#'
#' @examples
#' rdb::var_vals("result")
#' rdb::var_vals("id")
var_vals <- function(var_name) {
  
  var_name <- rlang::arg_match0(arg = var_name,
                                values = rfrnd_cols_order)
  data_codebook |>
    dplyr::filter(variable_name == !!var_name | variable_name_unnested == !!var_name) %$%
    variable_values |>
    unlist()
}

#' Get unnested variable names
#'
#' Returns the unnested analogue(s) of the specified variable name(s), which result from [unnesting][unnest_var]. For variable names that do *not* refer to
#' nested list columns, `var_names` is simply returned as-is.
#'
#' @inheritParams prettify_var_names
#'
#' @return A character vector of the same length as `var_names`.
#' @family metadata
#' @family unnest
#' @export
#'
#' @examples
#' rdb::var_name_unnested("inst_object_revision_modes")
#' rdb::var_name_unnested(paste0("topics_tier_", 1:3))
var_name_unnested <- function(var_names) {
  
  var_names <- rlang::arg_match(arg = var_names,
                                values = data_codebook$variable_name,
                                multiple = TRUE)
  data_codebook |>
    dplyr::filter(variable_name %in% !!var_names) %$%
    variable_name_unnested
}

#' Prettify referendum data variable names
#'
#' Converts referendum data variable names to their ready-for-publication version. Variable names that are unknown, i.e. not present in [`data_codebook`]), are
#' left untouched.
#'
#' @param var_names Variable name(s). Those not present in [`data_codebook`] remain untouched. A character vector.
#'
#' @return A character vector of the same length as `var_names`.
#' @family metadata
#' @family prettify
#' @export
#'
#' @examples
#' rdb::prettify_var_names("topics_tier_1")
#' 
#' # also supports unnested var names
#' rdb::prettify_var_names("topic_tier_1")
#'
#' # unknown var names are left untouched
#' rdb::prettify_var_names(var_names = c("topic_tier_1", "topic_tier_99"))
prettify_var_names <- function(var_names) {
  
  checkmate::assert_character(var_names)
  
  c(data_codebook$variable_name_print,
    data_codebook$variable_name_unnested_print)[match(x = var_names,
                                                      table = c(data_codebook$variable_name,
                                                                data_codebook$variable_name_unnested))] %|% var_names
}

#' List available topics
#'
#' Lists the set of available [referendum topics](`r url_codebook("topics")`) on the specified `tiers`.
#'
#' @param tiers Tiers to include topics from. An integerish vector.
#'
#' @return A character vector.
#' @family topics
#' @export
#'
#' @examples
#' rdb::topics(tiers = 1:2)
topics <- function(tiers = 1:3) {
  
  checkmate::assert_integerish(tiers,
                               lower = 1L,
                               upper = 3L,
                               any.missing = FALSE,
                               unique = TRUE)
  topic_set <- character()
  
  if (1L %in% tiers) {
    topic_set %<>% c(data_topics$topic_tier_1)
  }
  
  if (2L %in% tiers) {
    topic_set %<>% c(data_topics$topic_tier_2)
  }
  
  if (3L %in% tiers) {
    topic_set %<>% c(data_topics$topic_tier_3)
  }
  
  topic_set %>%
    setdiff(NA_character_) %>%
    unique()
}

#' Hierarchize topics
#'
#' Reconstructs the hierarchical relations between the three topic variables `topics_tier_1`, `topics_tier_2` and `topics_tier_3`. Can also be used to simply
#' determine the parent topic(s) of any topic.
#'
#' @param x The topics to hierarchize. Either a character vector of topics or a single-row data frame containing at least the columns `topics_tier_1`,
#'   `topics_tier_2` and `topics_tier_3`.
#'
#' @return `r pkgsnip::return_lbl("tibble_cols", cols = paste0("topic_tier_", 1:3))`
#' @family topics
#' @export
#'
#' @examples
#' rdb::hierarchize_topics("territorial questions")
#'
#' # hierarchize the topics of all Austrian referendums
#' rdb::rfrnds() |>
#'   dplyr::filter(country_code == "AT") |>
#'   dplyr::group_split(id) |>
#'   purrr::map(rdb::hierarchize_topics)
hierarchize_topics <- function(x) {
  
  test_char <- checkmate::test_character(x, any.missing = FALSE)
  
  if (!test_char) {
    
    topic_var_names <- paste0("topics_tier_", 1:3)
    test_df <- checkmate::test_data_frame(x,
                                          min.rows = 1L,
                                          max.rows = 1L)
    has_topic_vars <- all(topic_var_names %in% colnames(x))
    
    if (!test_df || !has_topic_vars) {
      cli::cli_abort(paste0("{.arg x} must be either a character vector of topics or a single-row data frame containing at least the columns ",
                            "{.field topics_tier_1}, {.field topics_tier_2} and {.field topics_tier_3}."))
    }
    
    x <- unlist(x[, topic_var_names],
                use.names = FALSE)
  }
  
  checkmate::assert_subset(x,
                           choices = c(topics_tier_1_, topics_tier_2_, topics_tier_3_),
                           empty.ok = TRUE)
  
  topics_tier_1 <- x[x %in% topics_tier_1_]
  topics_tier_2 <- x[x %in% topics_tier_2_]
  topics_tier_3 <- x[x %in% topics_tier_3_]
  inferred_topics_tier_1 <- infer_topics(topics = c(topics_tier_2, topics_tier_3),
                                         tier = 1L)
  inferred_topics_tier_2 <- infer_topics(topics = topics_tier_3,
                                         tier = 2L)
  non_parent_topics_tier_1 <- setdiff(topics_tier_1, inferred_topics_tier_1)
  non_parent_topics_tier_2 <- setdiff(topics_tier_2, inferred_topics_tier_2)
  
  # 0. initialize empty tibble
  result <- tibble::tibble(topic_tier_1 = character(),
                           topic_tier_2 = character(),
                           topic_tier_3 = character())
  
  # 1. add third-tier topics
  result <-
    topics_tier_3 %>%
    purrr::map(\(x) tibble::tibble(topic_tier_1 = infer_topics(topics = x,
                                                               tier = 1L),
                                   topic_tier_2 = infer_topics(topics = x,
                                                               tier = 2L),
                                   topic_tier_3 = x)) %>%
    purrr::list_rbind() %>%
    dplyr::bind_rows(result)
  
  # 2. add remaining second-tier topics
  result <-
    non_parent_topics_tier_2 %>%
    purrr::map(\(x) tibble::tibble(topic_tier_1 = infer_topics(topics = x,
                                                               tier = 1L),
                                   topic_tier_2 = x,
                                   topic_tier_3 = NA_character_)) %>%
    purrr::list_rbind() %>%
    dplyr::bind_rows(result)
  
  # 3. add remaining first-tier topics
  result %>%
    dplyr::bind_rows(tibble::tibble(topic_tier_1 = non_parent_topics_tier_1,
                                    topic_tier_2 = NA_character_,
                                    topic_tier_3 = NA_character_)) %>%
    # sort result
    dplyr::arrange(topic_tier_1, topic_tier_2, topic_tier_3)
}

#' Hierarchize topics (fast)
#'
#' Reconstructs the hierarchical relations between the three topic variables `topics_tier_1`, `topics_tier_2` and `topics_tier_3`. Other than
#' [hierarchize_topics()], this function assumes that the three topic variables are always *complete*, i.e. that no (grand)parent topics of lower-tier topics
#' are missing. This assumption is met by the data returned by [rfrnds()].
#'
#' @param topics_tier_1 First-tier topics. A character vector.
#' @param topics_tier_2 Second-tier topics. A character vector.
#' @param topics_tier_3 Third-tier topics. A character vector.
#'
#' @inherit hierarchize_topics return
#' @family topics
#' @export
#'
#' @examples
#' # hierarchize the topics of all Austrian referendums
#' rdb::rfrnds() |>
#'   dplyr::filter(country_code == "AT") |>
#'   dplyr::group_split(id) |>
#'   purrr::map(\(x) rdb::hierarchize_topics_fast(unlist(x$topics_tier_1),
#'                                                unlist(x$topics_tier_2),
#'                                                unlist(x$topics_tier_3)))
hierarchize_topics_fast <- function(topics_tier_1 = character(),
                                    topics_tier_2 = character(),
                                    topics_tier_3 = character()) {
  
  checkmate::assert_subset(topics_tier_1,
                           choices = topics_tier_1_)
  checkmate::assert_subset(topics_tier_2,
                           choices = topics_tier_2_)
  checkmate::assert_subset(topics_tier_3,
                           choices = topics_tier_3_)
  # add tier-3 hierarchy
  result <- data_topics[data_topics$topic_tier_3 %in% topics_tier_3, ]
  
  # add non-parent tier-2 hierarchy
  topics_tier_2 %<>% setdiff(result$topic_tier_2)
  result %<>% dplyr::bind_rows(unique(data_topics[data_topics$topic_tier_2 %in% topics_tier_2, 1:2]))
  
  # add non-parent tier-1 topics
  topics_tier_1 %<>% setdiff(result$topic_tier_1)
  result %>% dplyr::bind_rows(tibble::tibble(topic_tier_1 = topics_tier_1))
}

#' Infer higher-tier topics
#'
#' Determines the top-tier (`tier = 1L`) or second-tier (`tier = 2L`) topics corresponding to `topics` in the
#' [hierarchy][data_topics], i.e. either `topics` themselves or their (grand)parent topics.
#'
#' @param topics Topics from which the corresponding (grand)parent topics are to be determined. A factor or character vector.
#' @param tier Tier of the inferred topics. Either `1L` or `2L`.
#'
#' @return A character vector.
#' @family topics
#' @export
#'
#' @examples
#' rdb::infer_topics(topics = c("EU", "animal protection"),
#'                   tier = 1L)
#' rdb::infer_topics(topics = c("EU", "animal protection"),
#'                   tier = 2L)
#' 
#' # topics of different tiers can mixed in `topics`
#' rdb::infer_topics(topics = c("EU", "environment"),
#'                   tier = 2L)
#' 
#' # but `topics` of a higher tier than `tier` will be ignored
#' rdb::infer_topics(topics = "foreign policy",
#'                   tier = 2L)
infer_topics <- function(topics,
                         tier = 1L) {
  
  if (is.factor(topics)) topics <- as.character(topics)
  
  checkmate::assert_subset(topics,
                           choices = c(topics_tier_1_, topics_tier_2_, topics_tier_3_))
  checkmate::assert_int(tier,
                        lower = 1L,
                        upper = 2L)
  
  # inferred from lower-tier topics
  result <- data_topics[data_topics$topic_tier_2 %in% topics | data_topics$topic_tier_3 %in% topics, ]
  result %<>% .[[paste0("topic_tier_", tier)]]
  
  # plus top-tier topics
  if (tier == 1L) result %<>% c(topics[topics %in% topics_tier_1_])
  
  unique(result)
}

#' Nest topics hierarchically
#'
#' Takes a data frame with the three columns `r paste0("topic_tier_", 1:3) |> pal::enum_str(wrap = "\x60")` and transforms it into a nested data frame with the
#' two columns `name` and `parent_name`.
#'
#' @param data Political topics like [`data_topics`].
#'
#' @return `r pkgsnip::return_lbl("tibble_cols", cols = c("name", "parent_name"))`
#' @family topics
#' @export
#'
#' @examples
#' rdb::data_topics |> rdb::nest_topics()
nest_topics <- function(data) {
  
  assert_vars(data = data,
              var_names = paste0("topic_tier_", 1:3))
  
  # add tier-3 topics
  data |>
    dplyr::filter(!is.na(topic_tier_3)) |>
    dplyr::transmute(name = topic_tier_3,
                     parent_name = topic_tier_2) |>
    dplyr::bind_rows(
      # add tier-2 topics
      data |>
        dplyr::filter(!is.na(topic_tier_2)) |>
        dplyr::transmute(name = topic_tier_2,
                         parent_name = topic_tier_1) |>
        unique(),
      # add tier-1 topics
      tibble::tibble(name = unique(data$topic_tier_1),
                     parent_name = NA_character_)
    )
}

#' Add `is_former_country` flag to referendum data
#'
#' Augments `data` with an additional column `is_former_country` indicating whether or not the column `country_code` holds an [ISO 3166-3
#' alpha-4 code](https://en.wikipedia.org/wiki/ISO_3166-3) referring to a historical country which ceased to exist. `is_former_country` being `FALSE` means
#' `country_code` holds an [ISO 3166-1 alpha-2 code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) instead.
#'
#' @inheritParams add_world_regions
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family augment
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   rdb:::add_former_country_flag() |>
#'   dplyr::select(id,
#'                 starts_with("country_"),
#'                 is_former_country)
add_former_country_flag <- function(data) {
  
  # ensure minimal validity
  assert_vars(data = data,
              var_names = "country_code")
  data %>%
    dplyr::mutate(is_former_country = nchar(as.character(country_code)) > 2L) %>%
    # add var lbl
    labelled::set_variable_labels(.labels = var_lbls["is_former_country"])
}

#' Add continual country code to referendum data
#'
#' Augments `data` with an additional column `country_code_continual` holding the current or future [ISO 3166-1
#' alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code of the country where the referendum took place. If the country still exists,
#' `country_code_continual` is identical to `country_code`, otherwise it is the `country_code` of the successor country. If the country was succeeded by
#' multiple countries, the code of the largest one in terms of population is taken.
#'
#' @inheritParams add_world_regions
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family augment
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   rdb::add_country_code_continual() |>
#'   dplyr::select(id,
#'                 starts_with("country_"))
add_country_code_continual <- function(data) {
  
  # ensure minimal validity
  assert_vars(data = data,
              var_names = "country_code")
  
  data %>%
    dplyr::mutate(country_code_continual = factor(x = purrr::map2_chr(.x = as.character(country_code),
                                                                      .y = add_former_country_flag(data)$is_former_country,
                                                                      .f = \(x, y) {
                                                                        if (y) {
                                                                          data_iso_3166_3$alpha_2_new_main[data_iso_3166_3$alpha_4 == x]
                                                                        } else {
                                                                          x
                                                                        }
                                                                      }),
                                                  levels = val_set$country_code_continual,
                                                  ordered = FALSE)) %>%
    # add var lbl
    labelled::set_variable_labels(.labels = var_lbls["country_code_continual"])
}

#' Add long country code to referendum data
#'
#' Augments `data` with an additional column holding the current or former three-letter [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
#' code of the country in which the referendum took place (see [ISO 3166-3](https://en.wikipedia.org/wiki/ISO_3166-3_alpha-3) for former country codes).
#'
#' @inheritParams add_world_regions
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family augment
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   rdb:::add_country_code_long() |>
#'   dplyr::select(id,
#'                 starts_with("country_"))
add_country_code_long <- function(data) {
  
  # ensure minimal validity
  assert_vars(data = data,
              var_names = "country_code")
  data %>%
    # remove possibly existing long country code
    dplyr::select(-any_of("country_code_long")) %>%
    # add long country code
    dplyr::mutate(country_code_long = factor(x = purrr::map2_chr(.x = as.character(country_code),
                                                                 .y = add_former_country_flag(data)$is_former_country,
                                                                 .f = \(x, y) {
                                                                   if (y) {
                                                                     data_iso_3166_3$alpha_3[data_iso_3166_3$alpha_4 == x]
                                                                   } else {
                                                                     data_iso_3166_1$alpha_3[data_iso_3166_1$alpha_2 == x]
                                                                   }
                                                                 }),
                                             levels = val_set$country_code_long,
                                             ordered = FALSE)) %>%
    # ensure no NAs
    assertr::assert(predicate = assertr::not_na,
                    country_code_long) %>%
    order_rfrnd_cols() %>%
    # add var lbl
    labelled::set_variable_labels(.labels = var_lbls["country_code_long"])
}

#' Add short country name to referendum data
#'
#' Augments `data` with an additional column holding the common English name of the country in which the referendum took place.
#'
#' @inheritParams add_world_regions
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family augment
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   rdb:::add_country_name() |>
#'   dplyr::select(id,
#'                 starts_with("country_"))
add_country_name <- function(data) {
  
  # ensure minimal validity
  assert_vars(data = data,
              var_names = "country_code")
  data %>%
    # remove possibly existing country name
    dplyr::select(-any_of("country_name")) %>%
    # add country name
    dplyr::mutate(country_name = factor(x = purrr::map2_chr(.x = as.character(country_code),
                                                            .y = add_former_country_flag(data)$is_former_country,
                                                            .f = \(x, y) {
                                                              if (y) {
                                                                data_iso_3166_3$name_short[data_iso_3166_3$alpha_4 == x]
                                                              } else {
                                                                data_iso_3166_1$name_short[data_iso_3166_1$alpha_2 == x]
                                                              }
                                                            }),
                                        levels = val_set$country_name,
                                        ordered = FALSE)) %>%
    # ensure no NAs
    assertr::assert(predicate = assertr::not_na,
                    country_name) %>%
    order_rfrnd_cols() %>%
    # add var lbl
    labelled::set_variable_labels(.labels = var_lbls["country_name"])
}

#' Add long country name to referendum data
#'
#' Augments `data` with an additional column holding the official full English name(s) of the country in which the referendum took place.
#'
#' @inheritParams add_world_regions
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family augment
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   rdb:::add_country_name_long() |>
#'   dplyr::select(id,
#'                 starts_with("country_name"))
add_country_name_long <- function(data) {
  
  # ensure minimal validity
  assert_vars(data = data,
              var_names = "country_code")
  data %>%
    # remove possibly existing long country name
    dplyr::select(-any_of("country_name_long")) %>%
    # add long country name
    dplyr::mutate(country_name_long = factor(x = purrr::map2_chr(.x = as.character(country_code),
                                                                 .y = add_former_country_flag(data)$is_former_country,
                                                                 .f = \(x, y) {
                                                                   if (y) {
                                                                     data_iso_3166_3$name_long[data_iso_3166_3$alpha_4 == x]
                                                                   } else {
                                                                     data_iso_3166_1$name_long[data_iso_3166_1$alpha_2 == x]
                                                                   }
                                                                 }),
                                             levels = val_set$country_name_long,
                                             ordered = FALSE)) %>%
    # ensure no NAs
    assertr::assert(predicate = assertr::not_na,
                    country_name_long) %>%
    order_rfrnd_cols() %>%
    # add var lbl
    labelled::set_variable_labels(.labels = var_lbls["country_name_long"])
}

#' Add period to referendum data
#'
#' Augments `data` with an additional column holding the specified period in which the referendum took place. The new column is named after `period` and its
#' values are always of type integer.
#'
#' ```{r, child = "snippets/period_note.Rmd"}
#' ```
#'
#' @param data RDB referendum data as returned by [rfrnds()]. A data frame that at minimum contains the column `date`.
#' @param period Type of period to add. One of
#'   `r pal::fn_param_defaults(fn = add_period, param = "period") |> pal::wrap_chr("\x60") |> cli::ansi_collapse(sep2 = " or ", last = " or ")`.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family augment
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   rdb::add_period() |>
#'   dplyr::select(id, date, week)
#'
#' rdb::rfrnds() |>
#'   rdb::add_period("year") |>
#'   dplyr::select(id, date, year)
add_period <- function(data,
                       period = c("week", "month", "quarter", "year", "decade", "century")) {
  
  assert_vars(data = data,
              var_names = "date")
  period <- rlang::arg_match(period)
  
  # define necessary date transformations
  get_period <- switch(EXPR    = period,
                       week    = \(x) clock::as_iso_year_week_day(x) %>% clock::get_week(),
                       month   = \(x) clock::get_month(x),
                       quarter = \(x) clock::as_year_quarter_day(x) %>% clock::get_quarter(),
                       year    = \(x) clock::get_year(x),
                       decade  = \(x) (clock::get_year(x) %/% 10L) * 10L,
                       century = \(x) (clock::get_year(x) %/% 100L) * 100L)
  
  # define lbl parts
  period_lbl <- switch(EXPR    = period,
                       week    = glue::glue("{period} (1\u201353)"),
                       month   = glue::glue("{period} (1\u201312)"),
                       quarter = glue::glue("{period} (1\u20134)"),
                       period)
  data |>
    # add period
    dplyr::mutate(!!as.symbol(period) := get_period(date)) |>
    # harmonize col order
    order_rfrnd_cols() |>
    # add var lbl
    labelled::set_variable_labels(.labels = var_lbls[period])
}

#' Add turnout to referendum data
#'
#' @description
#' Augments `data` with an additional column `turnout` containing the voter turnout calculated as:
#'
#' \Sexpr[results=rd, stage=build]{
#'   katex::math_to_rd(tex = "\\\\frac{votes\\\\_yes+votes\\\\_no+votes\\\\_empty+votes\\\\_invalid}{electorate\\\\_total}",
#'                     ascii = "(votes_yes + votes_no + votes_empty + votes_invalid) / electorate_total",
#'                     displayMode = TRUE)
#' }
#'
#' @param data RDB referendum data as returned by [rfrnds()]. A data frame that at minimum contains the columns `electorate_total`, `votes_yes`, `votes_no`,
#'   `votes_empty` and `votes_invalid`.
#' @param rough Whether to fall back on a "rough" calculation of the turnout in case any of the variables `votes_empty` or `votes_invalid` is unknown (`NA`), or
#'   to be strict and return `NA` in such a case.
#' @param excl_dubious Whether or not to exclude obviously dubious turnout numbers (those > 1.0) by setting them to `NA`. Such numbers stem either from
#'   data errors or (officially) tampered numbers.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family augment
#' @export
#'
#' @examples
#' # rough turnout numbers
#' rdb::rfrnds() |>
#'   rdb::add_turnout() |>
#'   dplyr::select(id,
#'                 electorate_total,
#'                 starts_with("votes_"),
#'                 turnout)
#'
#' # strict turnout numbers
#' rdb::rfrnds() |>
#'   rdb::add_turnout(rough = FALSE) |>
#'   dplyr::select(id,
#'                 electorate_total,
#'                 starts_with("votes_"),
#'                 turnout)
add_turnout <- function(data,
                        rough = TRUE,
                        excl_dubious = TRUE) {
  
  assert_vars(data = data,
              var_names = c("electorate_total",
                            "votes_yes",
                            "votes_no",
                            "votes_empty",
                            "votes_invalid"))
  checkmate::assert_flag(rough)
  checkmate::assert_flag(excl_dubious)
  
  data %>%
    dplyr::rowwise() %>%
    dplyr::mutate(turnout = sum(votes_yes, votes_no, votes_empty, votes_invalid, na.rm = rough) / electorate_total) %>%
    dplyr::ungroup() %>%
    # set dubious turnout numbers to NA if requested
    dplyr::mutate(turnout = dplyr::if_else(excl_dubious & turnout > 1.0,
                                           NA_real_,
                                           turnout)) %>%
    # harmonize col order
    order_rfrnd_cols() %>%
    # add var lbl
    labelled::set_variable_labels(turnout = var_lbls[["turnout"]] %>% ifelse(test = rough,
                                                                             yes = stringr::str_replace(string = .,
                                                                                                        pattern = stringr::fixed("turnout"),
                                                                                                        replacement = "turnout (rough)"),
                                                                             no = .))
}

#' Add UN world regions to referendum data
#'
#' @description
#' Augments `data` with information about the [United Nations (UN) geoscheme](https://en.wikipedia.org/wiki/United_Nations_geoscheme) on three different
#' grouping tiers based on the [UN M49 area code hierarchy](https://en.wikipedia.org/wiki/UN_M49#Code_lists).
#' 
#' In total, eight different columns are added:
#' - `un_country_code`: UN M49 country code
#' - `un_region_tier_1_code`: UN tier-1 region's M49 area code
#' - `un_region_tier_1_name`: UN tier-1 region's English name
#' - `un_region_tier_2_code`: UN tier-2 region's M49 area code
#' - `un_region_tier_2_name`: UN tier-2 region's English name
#' - `un_region_tier_3_code`: UN tier-3 region's M49 area code
#' - `un_region_tier_3_name`: UN tier-3 region's English name
#' - `un_subregion`: Combinatiorial English UN subregion name which, except for Northern Europe, corresponds to the lowest `un_region_tier_*_name`.
#'
#' Tier-1 regions are the highest, i.e. most aggregated UN regions, commonly referred to as continents. Tier-2 regions are also known as "subregions" and tier-3
#' regions as "sub-subregions".
#'
#' Only part of all UN tier-2 regions are further divided into UN tier-3 regions, meaning that not all countries are part of a UN tier-3 region. If a country
#' doesn't belong to any UN tier-3 region, the corresponding `un_region_tier_3_*` values will simply be `NA`. The `un_subregion` column specifically addresses
#' this issue by providing a uniform combination of `un_region_tier_2_name` and `un_region_tier_3_name`.
#'
#' @param data RDB referendum data as returned by [rfrnds()]. A data frame that at minimum contains the column `country_code` (with [ISO 3166-1
#'   alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-3 alpha-4](https://en.wikipedia.org/wiki/ISO_3166-3) codes).
#' @param add_un_country_code Whether or not to also add a column `un_country_code` holding the UN M49 code of the country in which the referendum took place.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family augment
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   rdb::add_world_regions() |>
#'   dplyr::select(id,
#'                 starts_with("country_"),
#'                 starts_with("un_"))
add_world_regions <- function(data,
                              add_un_country_code = TRUE) {
  # ensure minimal validity
  assert_vars(data = data,
              var_names = "country_code")
  checkmate::assert_flag(add_un_country_code)
  
  has_country_code_continual <- "country_code_continual" %in% colnames(data)
  
  # add UN regions to input data
  data %<>%
    # temporarily add required base var `country_code_continual` if necessary
    add_country_code_continual() %>%
    # remove possibly existing UN region vars
    dplyr::select(-any_of(setdiff(colnames(un_regions),
                                  "country_code"))) %>%
    # add UN regions
    dplyr::left_join(y = un_regions,
                     by = c(country_code_continual = "country_code")) %>%
    # ensure every row got at least a UN tier-1 region assigned
    assertr::assert(predicate = assertr::not_na,
                    un_region_tier_1_code) %>%
    # harmonize col order
    order_rfrnd_cols() %>%
    # add var lbl
    labelled::set_variable_labels(.labels = purrr::keep_at(x = var_lbls,
                                                           at = col_names_un))
  # drop vars if necessary/requested
  if (!has_country_code_continual) {
    data %<>% dplyr::select(-country_code_continual)
  }
  if (!add_un_country_code) {
    data %<>% dplyr::select(-un_country_code)
  }
  
  data
}

#' Add various URLs to referendum data
#'
#' Augments `data` with additional columns holding URLs of the specified `types`. The new columns will be named after `types`, prefixed with `url_`, so
#' `types = "sudd"` will add the column `url_sudd` etc.
#'
#' @param data RDB referendum data as returned by [rfrnds()]. A data frame that at minimum contains the column `id_sudd` for `types = "sudd"` and the columns
#'   `country_code`, `level` and `id_official` for `types = "swissvotes"`.
#' @param types Type(s) of URLs to add. One or more of
#'   `r pal::fn_param_defaults(fn = add_urls, param = "types") |> pal::wrap_chr("\x60") |> cli::ansi_collapse(sep2 = " or ", last = " or ")`.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family augment
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   dplyr::filter(country_code == "CH" & level == "national") |>
#'   rdb::add_urls() |>
#'   dplyr::select(id,
#'                 country_code,
#'                 level,
#'                 starts_with("id_"),
#'                 starts_with("url_"))
add_urls <- function(data,
                     types = c("sudd", "swissvotes")) {
  
  types <- rlang::arg_match(arg = types,
                            multiple = TRUE)
  
  if ("sudd" %in% types) {
    
    assert_vars(data = data,
                var_names = "id_sudd")
    
    data %<>% dplyr::mutate(url_sudd = dplyr::if_else(is.na(id_sudd),
                                                      NA_character_,
                                                      url_sudd(glue::glue("event.php?id={id_sudd}"))))
  }
  
  if ("swissvotes" %in% types) {
    
    assert_vars(data = data,
                var_names = c("country_code",
                              "level",
                              "id_official"))
    
    data %<>% dplyr::mutate(url_swissvotes = dplyr::if_else(country_code == "CH" & level == "national" & !is.na(id_official),
                                                            paste0("https://swissvotes.ch/vote/", id_official), # nolint: paste_linter
                                                            NA_character_))
  }
  
  data
}

#' Transform to ballot-date-level observations
#'
#' Transforms referendum-level observations to ones on the level of ballot date and jurisdiction via [nesting][tidyr::nest] of referendum-level columns. The
#' individual values of all the referendums on a specific ballot date in a specific jurisdiction are preserved in a list column named `rfrnd_data`.
#'
#' @param data RDB referendum data as returned by [rfrnds()]. A data frame that at minimum contains the column `date`.
#' @param cols_to_retain Additional non-standard columns to be preserved as top-level columns instead of being nested in the list column `rfrnd_data`. They
#'   mustn't vary within ballot-date-level observations. `r pkgsnip::param_lbl("tidy_select_support")`
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family transform
#' @export
#'
#' @examples
#' # standard RDB columns are retained as far as possible
#' rdb::rfrnds() |>
#'   rdb::as_ballot_dates()
#' 
#' # non-standard columns must be explicitly specified in order to be retained
#' data_rdb <-
#'   rdb::rfrnds() |>
#'     rdb::add_world_regions() |>
#'     dplyr::mutate(region_custom =
#'                     factor(x = dplyr::if_else(country_code == "CH",
#'                                               "Switzerland & Liechtenstein",
#'                                               un_region_tier_1_name),
#'                            levels = c("Switzerland & Liechtenstein",
#'                                       levels(un_region_tier_1_name))) |>
#'                     forcats::fct_relevel("Switzerland & Liechtenstein",
#'                                          after = 3L) |>
#'                     forcats::fct_recode("rest of Europe" = "Europe"))
#'
#' data_rdb |> rdb::as_ballot_dates() |> colnames()
#' data_rdb |> rdb::as_ballot_dates(cols_to_retain = region_custom) |> colnames()
#'
#' # non-standard columns to retain must actually be retainable
#' try(
#'   data_rdb |> rdb::as_ballot_dates(cols_to_retain = title_en)
#' )
as_ballot_dates <- function(data,
                            cols_to_retain = NULL) {
  
  checkmate::assert_data_frame(data)
  defused_cols_to_retain <- rlang::enquo(cols_to_retain)
  ix_cols_to_retain <- tidyselect::eval_select(expr = defused_cols_to_retain,
                                               data = data)
  names_cols_to_retain <- names(ix_cols_to_retain)
  
  # ensure date col is present
  if (!("date" %in% colnames(data))) {
    cli::cli_abort("Unable to transform to ballot-date-level data since no {.var {date}} column is present in {.arg data}.")
  }
  
  # nest data
  cols_to_nest <-
    data |>
    colnames() |>
    setdiff(c(ballot_date_colnames,
              names_cols_to_retain))
  
  result <- data |> tidyr::nest(rfrnd_data = any_of(cols_to_nest))
  
  # ensure `cols_to_retain` don't vary within ballot dates
  n_rows_nested <-
    data |>
    dplyr::summarise(n = dplyr::n(),
                     .by = any_of(ballot_date_colnames)) |>
    dplyr::pull("n")
  
  if (!identical(purrr::map_int(result$rfrnd_data,
                                nrow),
                 n_rows_nested)) {
    
    cli::cli_abort(paste0("Retaining the additional non-standard {cli::qty(length(ix_cols_to_retain))} column{?s} {.var {names_cols_to_retain}} while ",
                          "converting to ballot-date-level observations is impossible because {?(some of)} {?this/these} column{?s} var{?ies/y} within ballot ",
                          "dates."))
  }
  
  result
}

#' Unnest multi-value variable
#'
#' Unnests a multi-value variable of type list to long format. Multi-value variables can contain more than one value per observation and thus break with the
#' [tidy-data convention](https://tidyr.tidyverse.org/articles/tidy-data.html). This function allows to conveniently expand `data` to contain a single `var`
#' value per observation only, thereby increasing the number of observations (i.e. rows).
#'
#' @param data RDB referendum data as returned by [rfrnds()]. A data frame that at minimum contains the column specified in `var`.
#' @param var `data` column to unnest. One of the multi-value variables:
#' `r data_codebook |> dplyr::filter(is_multi_valued) %$% variable_name |> pal::wrap_chr(wrap = "\x60") |> pal::as_md_list()`
#'   
#' `r pkgsnip::param_lbl("tidy_select_support")`
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family transform
#' @family unnest
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   rdb::unnest_var(topics_tier_2)
unnest_var <- function(data,
                       var) {
  
  # tidy selection and arg check
  checkmate::assert_data_frame(data)
  defused_var <- rlang::enquo(var)
  i_var <- tidyselect::eval_select(expr = defused_var,
                                   data = data)
  name_var <- names(i_var)
  n_var <- length(i_var)
  
  if (n_var > 1L) {
    cli::cli_abort("Only {.emph one} {.arg var} can be unnested at a time, but {.val {n_var}} were provided.")
  }
  
  name_var <- rlang::arg_match0(arg = name_var,
                                arg_nm = "var",
                                values =
                                  data_codebook |>
                                  dplyr::filter(is_multi_valued) %$%
                                  variable_name)
  
  name_var_unnested <- var_name_unnested(name_var)
  
  data |>
    tidyr::unnest_longer(col = all_of(name_var),
                         values_to = name_var_unnested,
                         keep_empty = TRUE,
                         ptype = character()) |>
    dplyr::mutate(!!as.symbol(name_var_unnested) := factor(x = !!as.symbol(name_var_unnested),
                                                           levels = var_vals(name_var),
                                                           ordered = val_scale(name_var) %in% c("ordinal_ascending", "ordinal_descending")))
}

#' Count number of referendums
#'
#' Counts the number of RDB referendums, optionally by additional columns specified via `by`.
#'
#' @param data RDB referendum data as returned by [rfrnds()]. A data frame that at minimum contains the columns specified in `by` (if any).
#' @param by Optional `data` column(s) to group by before counting number of referendums. `r pkgsnip::param_lbl("tidy_select_support")`
#' @param complete_fcts Whether or not to complete the result with implicitly missing combinations of those columns specified in `by` which are of type factor.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family transform
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   rdb::n_rfrnds(by = level)
#'
#' # count ballot dates instead of referendums
#' rdb::rfrnds() |>
#'   rdb::as_ballot_dates() |>
#'   rdb::n_rfrnds(by = level)
n_rfrnds <- function(data,
                     by = NULL,
                     complete_fcts = TRUE) {
  # arg checks
  checkmate::assert_data_frame(data)
  checkmate::assert_flag(complete_fcts)
  
  # tidy selection
  defused_by <- rlang::enquo(by)
  ix_by <- tidyselect::eval_select(expr = defused_by,
                                   data = data)
  names_by <- names(ix_by)
  
  result <-
    data |>
    dplyr::group_by(!!!rlang::syms(names_by)) |>
    dplyr::summarise(n = dplyr::n(),
                     .groups = "drop")
  
  if (complete_fcts) {
    result %<>% tidyr::complete(!!!rlang::syms(names_by),
                                fill = list(n = 0L))
  }
  
  result
}

#' Count number of referendums per period
#'
#' Counts the number of RDB referendums per desired period, optionally by additional columns specified via `by`.
#'
#' ```{r, child = "snippets/period_note.Rmd"}
#' ```
#'
#' @inheritParams n_rfrnds
#' @param data RDB referendum data as returned by [rfrnds()]. A data frame that at minimum contains the column specified in `period` or the column `date` (to
#'   compute the [period column][add_period]), plus the one(s) specified via `by` (if any).
#' @param period Type of period to count referendums by. One of
#'   `r pal::fn_param_defaults(fn = add_period, param = "period") |> pal::wrap_chr("\x60") |> cli::ansi_collapse(sep2 = " or ", last = " or ")`.
#' @param fill_gaps Whether or not to add zero-value rows to the result for `period` gaps in `data`.
#' @param period_floor Lower `period` limit up to which gaps are filled. If `NULL`, the lower limit is set to the minimum of `period` present in `data`. Only
#'   relevant if `fill_gaps = TRUE` and `period` is set to a unique timespan type (`"year"`, `"decade"` or `"century"`).
#' @param period_ceiling Upper `period` limit up to which gaps are filled. If `NULL`, the upper limit is set to the maximum of `period` present in `data`. Only
#'   relevant if `fill_gaps = TRUE` and `period` is set to a unique timespan type (`"year"`, `"decade"` or `"century"`).
#' @param descending Whether to sort the resulting table by `period` in descending or in ascending order.
#'
#' @inherit add_period details
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family transform
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   rdb::n_rfrnds_per_period()
#'
#' rdb::rfrnds() |>
#'   rdb::n_rfrnds_per_period(by = level)
#' 
#' # without filling gaps
#' rdb::rfrnds() |>
#'   rdb::n_rfrnds_per_period(by = level,
#'                            fill_gaps = FALSE)
#'
#' # per decade and by multiple columns
#' rdb::rfrnds() |>
#'   rdb::n_rfrnds_per_period(by = c(level, type),
#'                            period = "decade")
#'
#' # count ballot dates instead of referendums
#' rdb::rfrnds() |>
#'   rdb::as_ballot_dates() |>
#'   rdb::n_rfrnds_per_period()
n_rfrnds_per_period <- function(data,
                                by = NULL,
                                period = c("week", "month", "quarter", "year", "decade", "century"),
                                fill_gaps = TRUE,
                                period_floor = NULL,
                                period_ceiling = NULL,
                                descending = FALSE) {
  # arg checks
  checkmate::assert_data_frame(data)
  period <- rlang::arg_match(period)
  checkmate::assert_flag(fill_gaps)
  checkmate::assert_int(period_floor,
                        null.ok = TRUE)
  checkmate::assert_int(period_ceiling,
                        null.ok = TRUE)
  checkmate::assert_flag(descending)
  
  # tidy selection
  defused_by <- rlang::enquo(by)
  ix_by <- tidyselect::eval_select(expr = defused_by,
                                   data = data)
  names_by <- names(ix_by)
  
  # add period col if necessary
  if (!(period %in% colnames(data))) {
    data %<>% add_period(period = period)
  }
  
  result <-
    data |>
    dplyr::group_by(!!!rlang::syms(names_by), !!as.symbol(period)) |>
    dplyr::summarise(n = dplyr::n(),
                     .groups = "drop")
  # fill gaps
  # (only if input data (and thus result) is non-empty since otherwise we can't infer a sensible period range for year/decade/century)
  if (fill_gaps && nrow(result)) {
    
    # define sensible min/max period vals
    is_recurring_period <- period %in% c("week", "month", "quarter")
    period_step <- switch(EXPR = period,
                          century = 100L,
                          decade = 10L,
                          1L)
    period_min <- period |> pal::when(is.null(period_floor) && !is_recurring_period ~ pal::safe_min(data[[.]]),
                                      !is_recurring_period ~ period_floor,
                                      ~ 1L)
    period_max <- period |> pal::when(is.null(period_ceiling) && !is_recurring_period ~ pal::safe_max(data[[.]]),
                                      !is_recurring_period ~ period_ceiling,
                                      . == "week" ~ 53L,
                                      . == "month" ~ 12L,
                                      . == "quarter" ~ 4L)
    period_seq <- seq(from = (period_min %/% period_step) * period_step,
                      to = period_max,
                      by = period_step)
    result %<>%
      # reduce to results `>= period_floor` and `<= period_ceiling`
      dplyr::filter(!!as.symbol(period) %in% period_seq) %>%
      # convert period col to fct, so `tidyr::complete()` knows the missing vals
      dplyr::mutate(!!as.symbol(period) := factor(x = !!as.symbol(period),
                                                  levels = period_seq,
                                                  ordered = TRUE)) %>%
      tidyr::complete(!!!rlang::syms(names_by), !!as.symbol(period),
                      fill = list(n = 0L)) %>%
      # convert period col back to int
      dplyr::mutate(!!as.symbol(period) := as.integer(as.character(!!as.symbol(period))))
  }
  
  result |> dplyr::arrange(if (descending) dplyr::desc(!!as.symbol(period)) else !!as.symbol(period))
}

#' Prettify referendum data column names
#'
#' Renames referendum data column names to be ready for publication. Useful e.g. to create tables or visualizations.
#'
#' Note that
#' - column names unknown to this function are not changed.
#' - column *labels* are [removed][labelled::remove_var_label] so they aren't inadvertently used instead of the column *names* (i.a. relevant for [gt][gt::gt]
#'   [>= 0.9.0](https://gt.rstudio.com/news/index.html#minor-improvements-and-bug-fixes-0-9-0)).
#'
#' @param data RDB referendum data as returned by [rfrnds()].
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family transform
#' @family prettify
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   rdb::prettify_col_names()
prettify_col_names <- function(data) {
  
  data |>
    dplyr::rename_with(.cols = everything(),
                       .fn = prettify_var_names) |>
    # we remove the var lbls so gt doesn't automatically pick them up instead of the column names
    # cf. https://gt.rstudio.com/news/index.html#minor-improvements-and-bug-fixes-0-9-0
    labelled::remove_var_label()
}

#' Referendum share per period stacked area chart
#'
#' Creates a [Plotly stacked area chart](https://plotly.com/r/filled-area-plots/#stacked-area-chart-with-cumulative-values) that visualizes the share of
#' referendums per period, grouped by another column.
#'
#' ```{r, child = "snippets/period_note.Rmd"}
#' ```
#'
#' @param data RDB referendum data as returned by [rfrnds()]. A data frame that at minimum contains the column specified in `period` or the column `date` (to
#'   compute the [period column][add_period]), plus the column specified in `by`.
#' @param by `data` column to group by before counting number of referendums. `r pkgsnip::param_lbl("tidy_select_support")`
#' @param period Type of period to count referendums by. One of
#'   `r pal::fn_param_defaults(fn = add_period, param = "period") |> pal::wrap_chr("\x60") |> cli::ansi_collapse(sep2 = " or ", last = " or ")`.
#'
#' @return `r pkgsnip::param_lbl("plotly_obj")`
#' @family visualize
#' @export
#'
#' @examples
#' rdb::rfrnds(quiet = TRUE,
#'             max_cache_age = "1 year") |>
#'   rdb::plot_rfrnd_share_per_period(by = "level")
plot_rfrnd_share_per_period <- function(data,
                                        by,
                                        period = c("week", "month", "quarter", "year", "decade", "century")) {
  period <- rlang::arg_match(period)
  
  # add period col if necessary
  if (!(period %in% colnames(data))) {
    data %<>% add_period(period = period)
  }
  
  # tidy selection
  defused_by <- rlang::enquo(by)
  i_by <- tidyselect::eval_select(expr = defused_by,
                                  data = data)
  n_by <- length(i_by)
  name_by <- names(i_by)
  
  # ensure `x` is < 2
  if (n_by > 1L) {
    cli::cli_abort("Only {.emph one} column can be specified in {.arg by}, but {.val {n_by}} were provided.")
  }
  
  data %>%
    # calculate freqs
    dplyr::group_by(!!as.symbol(name_by), !!as.symbol(period)) %>%
    dplyr::summarise(n = dplyr::n(),
                     .groups = "drop") %>%
    # plot
    plot_share_per_period(x = name_by,
                          period = period)
}

#' Topic segmentation sunburst chart
#'
#' Creates a [Plotly sunburst chart](https://plotly.com/r/sunburst-charts/) that visualizes the hierarchical segmentation of referendum topic occurences.
#'
#' A *topic lineage* is the hierarchical compound of a `topic_tier_1` and optionally a grandchild `topic_tier_3` and/or a child `topic_tier_2`.
#'
#' Note that topics can be assigned on any tier to referendums (i.e. in one case, a `topic_tier_1` plus a child `topic_tier_2` is assigned, and in another case
#' only a `topic_tier_1` without any further child topic).
#'
#' Furthermore, it should be noted that not every `topic_tier_2` has potential child `topic_tier_3`s. See the [full topic hierarchy](`r url_codebook("topics")`)
#' for details.
#'
#' @param data RDB referendum data as returned by [rfrnds()]. A data frame that at minimum contains the columns `topics_tier_1`, `topics_tier_2` and
#'   `topics_tier_3`.
#' @param method Applied method to count the number of topic occurences. One of
#'   - **`"per_rfrnd"`**: All *referendums* have the same weight. For a referendum with n different topics of the same tier, every topic is counted 1/n.
#'   - **`"per_topic_lineage"`**: All *topic lineages* have the same weight. For a referendum with n different topics of the same tier, every topic is fully
#'     counted, meaning that e.g. a referendum with three different tier-3 topics has a tripled impact on the result compared to a referendum that only has a
#'     single one. Noticeably faster than `"per_rfrnd"`.
#'   - **`"naive"`**: Naive procedure which doesn't properly reflect topic proportions on tier 2 and 3. Based on the (wrong) assumptions that a) all referendums
#'     have the same number of topic lineages assigned and b) topics are not deduplicated per tier. By far the fastest method, though.
#'
#' @return `r pkgsnip::param_lbl("plotly_obj")`
#' @family visualize
#' @export
#'
#' @examples
#' # count each referendum equally
#' rdb::rfrnds() |>
#'   rdb::plot_topic_segmentation(method = "per_rfrnd")
#'
#' # count each topic lineage equally
#' rdb::rfrnds() |>
#'   rdb::plot_topic_segmentation(method = "per_topic_lineage")
#'
#' # naive count (way faster, but with misleading proportions on tier 2 and 3)
#' rdb::rfrnds() |>
#'   rdb::plot_topic_segmentation(method = "naive")
plot_topic_segmentation <- function(data,
                                    method = c("per_rfrnd", "per_topic_lineage", "naive")) {
  
  method <- rlang::arg_match(method)
  rlang::check_installed("plotly",
                         reason = pal::reason_pkg_required())
  is_naive <- method == "naive"
  
  # assemble necessary data structure
  if (is_naive) {
    
    ## naively
    data_plot <-
      dplyr::bind_rows(
        data$topics_tier_1 %>%
          topic_frequency(tier = 1L) %>%
          dplyr::mutate(parent_topic = ""),
        data$topics_tier_2 %>%
          topic_frequency(tier = 2L) %>%
          dplyr::mutate(parent_topic = purrr::map_chr(.x = as.character(topic),
                                                      .f = \(x) infer_topics(x,
                                                                             tier = 1L))),
        data$topics_tier_3 %>%
          topic_frequency(tier = 3L) %>%
          dplyr::mutate(parent_topic = purrr::map_chr(.x = as.character(topic),
                                                      .f = \(x) infer_topics(x,
                                                                             tier = 2L)))
      ) %>%
      dplyr::rename(value = "n")
    
  } else {
    
    is_per_rfrnd <- method == "per_rfrnd"
    data_plot <- data %>% dplyr::select(starts_with("topics_tier_"))
    
    ### per rfrnd, i.e. in fractional numbers
    if (is_per_rfrnd) {
      
      data_plot %<>%
        purrr::pmap(~ hierarchize_topics_fast(unlist(..1),
                                              unlist(..2),
                                              unlist(..3)) %>%
                      dplyr::mutate(value = 1.0 / nrow(.))) %>%
        purrr::list_rbind()
      
      ### per topic lineage
    } else {
      
      data_plot %<>%
        purrr::pmap(~ hierarchize_topics_fast(unlist(..1),
                                              unlist(..2),
                                              unlist(..3))) %>%
        purrr::list_rbind() %>%
        dplyr::mutate(value = 1.0)
    }
    
    data_plot <-
      dplyr::bind_rows(
        data_plot %>%
          dplyr::group_by(topic_tier_1) %>%
          dplyr::summarise(value = sum(value)) %>%
          dplyr::mutate(topic = topic_tier_1,
                        parent_topic = "",
                        value,
                        .keep = "none"),
        data_plot %>%
          dplyr::group_by(topic_tier_2) %>%
          dplyr::summarise(value = sum(value)) %>%
          dplyr::mutate(topic = topic_tier_2,
                        parent_topic =
                          topic %>%
                          purrr::map_chr(\(x) {
                            if (is.na(x)) {
                              NA_character_
                            } else {
                              infer_topics(topics = x,
                                           tier = 1L)
                            }}),
                        value,
                        .keep = "none"),
        data_plot %>%
          dplyr::group_by(topic_tier_3) %>%
          dplyr::summarise(value = sum(value)) %>%
          dplyr::mutate(topic = topic_tier_3,
                        parent_topic =
                          topic %>%
                          purrr::map_chr(\(x) {
                            if (is.na(x)) {
                              NA_character_
                            } else {
                              infer_topics(topics = x,
                                           tier = 2L)
                            }}),
                        value,
                        .keep = "none")
      ) %>%
      dplyr::filter(!is.na(topic))
    
    ### add NA rows filling the gaps
    data_plot %<>%
      dplyr::filter(parent_topic != "") %>%
      dplyr::group_by(parent_topic) %>%
      dplyr::summarise(value_total = sum(value),
                       .groups = "drop") %>%
      dplyr::mutate(topic = "<i>not defined</i>",
                    value = purrr::map2_dbl(.x = value_total,
                                            .y = parent_topic,
                                            .f = \(x, y) {
                                              data_plot %>%
                                                dplyr::filter(topic == y) %$%
                                                value %>%
                                                checkmate::assert_number() %>%
                                                magrittr::subtract(x)
                                            }),
                    parent_topic,
                    .keep = "none") %>%
      dplyr::bind_rows(data_plot, .) %>%
      dplyr::mutate(id = ifelse(topic == "<i>not defined</i>",
                                paste0("NA_", parent_topic),
                                topic))
  }
  
  # create plot
  plotly::plot_ly(data = data_plot,
                  type = "sunburst",
                  labels = ~topic,
                  parents = ~parent_topic,
                  ids = if (is_naive) ~topic else ~id,
                  values = ~value,
                  branchvalues = ifelse(is_naive,
                                        "remainder",
                                        "total"),
                  insidetextorientation = "radial")
}

#' Topic share per period stacked area chart
#'
#' Creates a [Plotly stacked area chart](https://plotly.com/r/filled-area-plots/#stacked-area-chart-with-cumulative-values) that visualizes the share of
#' referendum topic occurences per period.
#'
#' ```{r, child = "snippets/period_note.Rmd"}
#' ```
#'
#' @param data RDB referendum data as returned by [rfrnds()]. A data frame that at minimum contains the column `topics_tier_#` of the specified `tier`.
#' @param tier Tier of the topics variable to plot. `1L`, `2L` or `3L`.
#' @param period Type of period to count topics by. One of
#'   `r pal::fn_param_defaults(fn = add_period, param = "period") |> pal::wrap_chr("\x60") |> cli::ansi_collapse(sep2 = " or ", last = " or ")`.
#' @param weight_by_n_rfrnds Whether or not to weight topic occurences by number of referendums. If `TRUE`, for a referendum with n different topics of the same
#'   `tier`, every topic is counted 1/n.
#'
#' @return `r pkgsnip::param_lbl("plotly_obj")`
#' @family visualize
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   rdb::plot_topic_share_per_period(period = "decade")
plot_topic_share_per_period <- function(data,
                                        tier = 1L,
                                        period = c("week", "month", "quarter", "year", "decade", "century"),
                                        weight_by_n_rfrnds = TRUE) {
  checkmate::assert_int(tier,
                        lower = 1L,
                        upper = 3L)
  period <- rlang::arg_match(period)
  checkmate::assert_flag(weight_by_n_rfrnds)
  
  # add period col if necessary
  if (!(period %in% colnames(data))) {
    data %<>% add_period(period = period)
  }
  
  # ensure topics var is present
  var_name_topics <- glue::glue("topics_tier_{tier}")
  var_name_topic <- var_name_unnested(var_name_topics)
  
  if (!(var_name_topics %in% colnames(data))) {
    cli::cli_abort("Required column {.var {var_name_topics}} is missing from {.arg data}.")
  }
  
  data |>
    # add proper count var
    dplyr::mutate(count = if (weight_by_n_rfrnds) 1.0 / lengths(!!as.symbol(var_name_topics)) else 1.0) |>
    # unnest topics var
    unnest_var(var = var_name_topics) |>
    # calculate freqs
    dplyr::group_by(!!as.symbol(period), !!as.symbol(var_name_topic)) |>
    dplyr::summarise(n = sum(count),
                     .groups = "drop") |>
    # plot
    plot_share_per_period(x = var_name_topic,
                          period = period)
}

#' Period streamgraph
#'
#' Creates a ggplot2 [streamgraph](https://en.wikipedia.org/wiki/Streamgraph) based on [ggstream::geom_stream()] using the specified `period` as time
#' resolution.
#'
#' @inheritParams n_rfrnds_per_period
#' @param by `data` column to group by before counting number of referendums.
#' @param stacking Stacking type. One of
#'   - `"mirror"` to stack absolute values symmetrically around the zero line on the x-axis.
#'   - `"ridge"` to stack absolute values from the zero line on the x-axis upwards.
#'   - `"proportional"` to stack relative values that add up to 100 %.
#' @param bandwidth Kernel density estimation bandwidth. A numeric scalar.
#' @param y_lim Optional Y axis range limit. Only relevant if `stacking` is one of `"mirror"` or `"ridge"`. The limit applies to the upper side if
#'   `stacking = "ridge"` and to both sides if `stacking = "mirror"`. A numeric scalar equal to or greater than zero.
#' @param color_palette Color palette function that when called with a single integer argument returns that many color codes.
#' @param prune_legend Whether or not to drop `by` factor levels which don't occur in `data` from the legend. Only has an effect if `by` is of type factor.
#'
#' @return `r pkgsnip::return_lbl("ggplot2_obj")`
#' @family visualize
#' @export
#'
#' @examples
#' data_rdb <- rdb::rfrnds()
#'
#' rdb::ggplot_streamgraph(data = data_rdb,
#'                         by = topics_tier_1,
#'                         period = "year")
#'
#' # you can specify a different color palette
#' rdb::ggplot_streamgraph(data = data_rdb,
#'                         by = topics_tier_1,
#'                         period = "year",
#'                         color_palette = viridisLite::viridis)
#'
#' # by default, only factor levels which occur in data are included in the legend
#' data_rdb |>
#'   dplyr::filter(country_code == "AT") |>
#'   rdb::ggplot_streamgraph(by = topics_tier_1,
#'                           period = "decade")
#'
#' # but you can include *all* factor levels in the legend if you want to
#' data_rdb |>
#'   dplyr::filter(country_code == "AT") |>
#'   rdb::ggplot_streamgraph(by = topics_tier_1,
#'                           period = "decade",
#'                           prune_legend = FALSE)
ggplot_streamgraph <- function(data,
                               by,
                               period = c("week", "month", "quarter", "year", "decade", "century"),
                               stacking = c("mirror", "ridge", "proportional"),
                               bandwidth = 0.75,
                               y_lim = NULL,
                               color_palette = viridisLite::turbo,
                               prune_legend = TRUE) {
  
  stacking <- rlang::arg_match(stacking)
  checkmate::assert_number(bandwidth)
  checkmate::assert_number(y_lim,
                           lower = 0.0,
                           finite = TRUE,
                           null.ok = TRUE)
  checkmate::assert_function(color_palette)
  checkmate::assert_flag(prune_legend)
  rlang::check_installed("ggplot2",
                         reason = pal::reason_pkg_required())
  rlang::check_installed("ggstream",
                         reason = pal::reason_pkg_required())
  rlang::check_installed("scales",
                         reason = pal::reason_pkg_required())
  rlang::check_installed("viridisLite",
                         reason = pal::reason_pkg_required())
  ix_by <- tidyselect::eval_select(expr = rlang::enquo(by),
                                   data = data)
  names_by <- names(ix_by)
  name_by <- names_by
  n_by <- length(ix_by)
  
  if (n_by > 1L) {
    cli::cli_abort("Only {.emph one} data column can be specified in {.arg by}, but {.val {n_by}} were provided.")
  }
  
  # unnest list col if necessary
  if (is.list(data[[ix_by]])) {
    data %<>% unnest_var(var = tidyselect::all_of(names_by))
    name_by <- var_name_unnested(names_by)
  }
  
  result <- n_rfrnds_per_period(data = data,
                                period = period,
                                by = !!as.symbol(name_by))
  
  # create stable color mapping based on lvls of `by`
  # TODO: this probably could be removed and we could instead pass on a *discrete fill scale* fn (e.g. `\(...) viridis::scale_fill_viridis(..., discrete = T)`)
  #       to `ggplot2::scale_fill_discrete(type = )` once the below mentioned issue #23 is resolved
  if (is.factor(data[[name_by]])) {
    vals_by <- levels(data[[name_by]])
  } else {
    vals_by <- sort(unique(data[[name_by]]))
  }
  colors_by <- color_palette(length(vals_by))
  names(colors_by) <- vals_by
  
  # we need to remove zero-n rows (plus the corresponding colors) since ggstream doesn't handle them properly
  # TODO: remove this workaround once [issue #23](https://github.com/davidsjoberg/ggstream/issues/23) is fixed
  ## if we prune the legend, we need to prune the fill colors, too (otherwise, colors aren't matched properly)
  if (prune_legend) {
    colors_by %<>% magrittr::extract(names(.) %in% unique(result[[name_by]][result$n > 0L]))
  }
  result %<>%
    dplyr::group_by(!!as.symbol(name_by)) %>%
    dplyr::group_modify(\(d, k) if (sum(d$n) > 0L) d else d[0L, ]) %>%
    dplyr::ungroup()
  
  result <-
    ggplot2::ggplot(data = result,
                    mapping = ggplot2::aes(x = !!as.symbol(period),
                                           y = n,
                                           fill = !!as.symbol(name_by))) +
    ggstream::geom_stream(type = stacking,
                          n_grid = 10000L,
                          show.legend = TRUE,
                          bw = bandwidth) +
    ggplot2::scale_fill_discrete(type = colors_by,
                                 name = prettify_var_names(name_by),
                                 drop = prune_legend) +
    ggplot2::xlab(ggplot2::element_blank()) +
    ggplot2::ylab(ggplot2::element_blank())
  
  if (stacking == "ridge" && !is.null(y_lim)) {
    result <- result + ggplot2::coord_cartesian(ylim = c(0.0, y_lim),
                                                default = TRUE)
    
  } else if (stacking == "mirror") {
    
    if (!is.null(y_lim)) {
      result <- result + ggplot2::coord_cartesian(ylim = c(-y_lim, y_lim),
                                                  default = TRUE)
    }
    
    # make y scale absolute in both directions
    result <- result + ggplot2::scale_y_continuous(labels = \(x) abs(x))
    
  } else if (stacking == "proportional") {
    result <- result + ggplot2::scale_y_continuous(labels = scales::label_percent(suffix = "\u2009%"))
  }
  
  result
}

#' Tabulate number of referendums
#'
#' Creates a ready-to-print [gt][gt::gt] table with the number of referendums, optionally counted `by` up to three additional variables.
#'
#' The first variable specified in `by` will be reflected in additional rows in the resulting table, i.e. expand it vertically. The second and third variables
#' will be reflected in additional columns, i.e. expand it horizontally.
#'
#' @inheritParams n_rfrnds
#' @param by Up to three additional `data` columns to group by before counting number of referendums. `r pkgsnip::param_lbl("tidy_select_support")`
#' @param n_rows Maximum number of rows to be included in the resulting table. All the rows exceeding that limit are replaced by a single row of ellipses. An
#'   integer scalar or `Inf` for an unlimited number of rows.
#' @param order How to order the rows of the resulting table. One of
#'   - `"ascending"` to sort in ascending order by the number of referendums,
#'   - `"descending"` to sort in descending order by the number of referendums, or
#'   - `NULL` to leave the sorting unchanged.
#' @param incl_row_head Whether or not to include a row heading with the [prettified][prettify_var_names] name of the first `by` variable.
#' @param incl_col_head Whether or not to include column headings (in the table's [stub][gt::tab_stubhead]) with the [prettified][prettify_var_names] names of
#'   the second and third `by` variables.
#' @param add_total_row Whether or not to add a summary row at the very end of the table containing column totals. If `NULL`, a total row is added only if
#'   at least one column is provided in `by`.
#' @param add_total_col Whether or not to add a summary column at the very end of the table containing row totals. If `NULL`, a total column is added only if
#'   multiple columns are provided in `by`.
#' @param lbl_total_row Label of the summary row containing column totals. Only relevant if `add_total_row = TRUE`. A character scalar. [gt::md()] or
#'   [gt::html()] can be used to format the label text.
#' @param lbl_total_col Label of the summary column containing row totals. Only relevant if `add_total_col = TRUE`. A character scalar. [gt::md()] or
#'   [gt::html()] can be used to format the label text.
#'
#' @return `r pkgsnip::return_lbl("gt_obj")`
#' @family tabulate
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   rdb::tbl_n_rfrnds()
#'
#' # grouped by a single column
#' rdb::rfrnds() |>
#'   rdb::tbl_n_rfrnds(by = level)
#'
#' # grouped by two columns
#' rdb::rfrnds() |>
#'   rdb::tbl_n_rfrnds(by = c(type, level))
#'
#' # grouped by three columns
#' rdb::rfrnds() |>
#'   rdb::tbl_n_rfrnds(by = c(country_name, level, type),
#'                     n_rows = 10L,
#'                     order = "descending")
#'
#' # count ballot dates instead of referendums
#' rdb::rfrnds() |>
#'   rdb::as_ballot_dates() |>
#'   rdb::tbl_n_rfrnds(by = c(country_name, level),
#'                     n_rows = 10L,
#'                     order = "descending")
# nolint start: cyclocomp_linter
tbl_n_rfrnds <- function(data,
                         by = NULL,
                         complete_fcts = TRUE,
                         n_rows = Inf,
                         order = NULL,
                         incl_row_head = TRUE,
                         incl_col_head = TRUE,
                         add_total_row = NULL,
                         add_total_col = NULL,
                         lbl_total_row = gt::md("**Total**"),
                         lbl_total_col = gt::md("**Total**")) {
  
  if (!isTRUE(is.infinite(n_rows))) {
    checkmate::assert_int(n_rows,
                          lower = 1L)
  }
  if (!is.null(order)) {
    rlang::arg_match0(arg = order,
                      values = c("ascending", "descending"))
  }
  checkmate::assert_flag(incl_row_head)
  checkmate::assert_flag(incl_col_head)
  checkmate::assert_flag(add_total_row,
                         null.ok = TRUE)
  checkmate::assert_flag(add_total_col,
                         null.ok = TRUE)
  checkmate::assert_string(lbl_total_row)
  checkmate::assert_string(lbl_total_col)
  rlang::check_installed("gt",
                         version = "0.9.0",
                         reason = pal::reason_pkg_required())
  
  ix_by <- tidyselect::eval_select(expr = rlang::enquo(by),
                                   data = data)
  n_by <- length(ix_by)
  has_by <- n_by > 0L
  has_by_rest <- n_by > 1L
  
  if (n_by > 3L) {
    cli::cli_abort("At most {.emph three} data columns can be specified in {.arg by}, but {.val {n_by}} were provided.")
  }
  
  if (is.null(add_total_row)) {
    add_total_row <- has_by
  }
  
  if (is.null(add_total_col)) {
    add_total_col <- has_by_rest
  }
  
  by_colname_1st <- names(ix_by[1L]) %|% ":no_by"
  by_colnames_rest <- names(ix_by[-1L])
  
  result <-
    data |>
    n_rfrnds(by = {{ by }},
             complete_fcts = complete_fcts) |>
    dplyr::mutate(dplyr::across(where(is.factor),
                                \(x) forcats::fct_na_value_to_level(f = x,
                                                                    level = "N/A"))) |>
    pal::when(has_by_rest ~ tidyr::pivot_wider(data = .,
                                               names_from = by_colnames_rest,
                                               names_sort = TRUE,
                                               values_from = n),
              ~ .) |>
    dplyr::mutate(`:total` = rowSums(x = dplyr::pick(-any_of(by_colname_1st)),
                                     na.rm = TRUE),
                  dplyr::across(everything(),
                                \(x) tidyr::replace_na(data = x,
                                                       replace = 0L))) |>
    pal::when(isTRUE(order == "descending") ~ dplyr::arrange(.data = .,
                                                             -`:total`),
              isTRUE(order == "ascending") ~ dplyr::arrange(.data = .,
                                                            `:total`),
              ~ .) |>
    pal::when(!add_total_col ~ dplyr::select(.data = .,
                                             -`:total`),
              ~ .)
  total_n <-
    result |>
    dplyr::select(-any_of(by_colname_1st)) |>
    purrr::map_int(\(x) sum(x, na.rm = TRUE))
    
  chop_rows <- n_rows < nrow(result)
  
  if (chop_rows) {
    
    result %<>%
      utils::head(n = n_rows) %>%
      # add placeholder/ellipsis row
      dplyr::mutate(dplyr::across(everything(),
                                  as.character)) %>%
      rbind("\u2026")
  }
  
  # NOTE: if we chop rows (and have multiple n cols), it's impossible to create our total row using `gt::grand_summary_rows()` since its `fns` arg only
  #       receives column content, no metadata; thus we create the total row manually
  if (add_total_row && chop_rows) {
    result %<>% rbind(c(lbl_total_row, total_n))
  }
  
  result %<>% gt::gt(rowname_col = ifelse(has_by,
                                          by_colname_1st,
                                          "rowname"),
                     process_md = TRUE)
  
  if (incl_row_head && has_by) {
    result %<>% gt::tab_row_group(label =
                                    by_colname_1st |>
                                    prettify_var_names() |>
                                    pal::wrap_chr(wrap = "*") |>
                                    gt::md(),
                                  rows = tidyselect::everything(),
                                  id = by_colname_1st)
  }
  
  if (add_total_col) {
    result %<>% gt::cols_label(`:total` = lbl_total_col)
  }
    
  if (add_total_row) {
    if (chop_rows) {
      result %<>% gt::tab_style(style = gt::cell_borders(sides = "top",
                                                         color = "#D3D3D3",
                                                         style = "double",
                                                         weight = gt::px(6L)),
                                locations = list(gt::cells_body(rows = n_rows + 2L),
                                                 gt::cells_stub(rows = n_rows + 2L)))
      
    } else {
      result %<>% gt::grand_summary_rows(fns = list(id = "total", label = "DUMMY") ~ sum(., na.rm = TRUE),
                                         fmt = ~ gt::fmt_integer(., sep_mark = ""))
      
      # TODO: remove this workaround and replace `"DUMMY"` with `lbl_total_row` above as soon as [#1295](https://github.com/rstudio/gt/issues/1295)
      #       is fixed.
      result$`_summary`[[1L]]$fns$total$label <- lbl_total_row
    }
  }
  
  if (incl_col_head && has_by_rest) {
    result %<>%
      gt::tab_stubhead(label =
                         by_colnames_rest |>
                         prettify_var_names() |>
                         pal::wrap_chr(wrap = "*") |>
                         paste0(collapse = "<br><br>") |>
                         gt::md()) %>%
      gt::tab_style(style = gt::cell_text(align = "right",
                                          v_align = "middle"),
                    locations = gt::cells_stubhead())
  }
  
  result |>
    gt::tab_spanner_delim(delim = "_",
                          split = "last") |>
    # right-align cols; required since they're of type chr if we chopped rows
    gt::cols_align(align = "right",
                   columns = -tidyselect::any_of(by_colname_1st)) |>
    # hide table header if there are less than two `by` cols
    pal::when(!has_by_rest ~ gt::tab_options(data = .,
                                             column_labels.hidden = TRUE),
              ~ .)
}
# nolint end

#' Tabulate number of referendums per period
#'
#' Creates a ready-to-print [gt][gt::gt] table with the number of referendums per period, optionally counted `by` up to two additional columns.
#'
#' ```{r, child = "snippets/period_note.Rmd"}
#' ```
#'
#' @inheritParams n_rfrnds_per_period
#' @inheritParams tbl_n_rfrnds
#' @param by Up to two additional `data` columns to group by before counting number of referendums. `r pkgsnip::param_lbl("tidy_select_support")`
#' @param squeeze_zero_rows Whether or not to compress consecutive zero-sum rows into single period span rows.
#' @param add_total_col Whether or not to add a summary column at the very end of the table containing row totals. If `NULL`, a total column is added only if
#'   `by` is non-empty.
#'
#' @return `r pkgsnip::return_lbl("gt_obj")`
#' @family tabulate
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   rdb::tbl_n_rfrnds_per_period(period = "decade")
#'
#' # grouped by a single additional column
#' rdb::rfrnds() |>
#'   rdb::tbl_n_rfrnds_per_period(by = level,
#'                                period = "decade")
#'
#' # grouped by two addtional columns
#' rdb::rfrnds() |>
#'   rdb::tbl_n_rfrnds_per_period(by = c(level, type),
#'                                period = "decade")
#'
#' # count ballot dates instead of referendums
#' rdb::rfrnds() |>
#'   rdb::as_ballot_dates() |>
#'   rdb::tbl_n_rfrnds_per_period(period = "decade")
tbl_n_rfrnds_per_period <- function(data,
                                    by = NULL,
                                    period = c("week", "month", "quarter", "year", "decade", "century"),
                                    fill_gaps = TRUE,
                                    period_floor = NULL,
                                    period_ceiling = NULL,
                                    squeeze_zero_rows = TRUE,
                                    descending = TRUE,
                                    add_total_row = TRUE,
                                    add_total_col = NULL,
                                    lbl_total_row = gt::md("**Total**"),
                                    lbl_total_col = lbl_total_row) {
  
  period <- rlang::arg_match(period)
  checkmate::assert_flag(squeeze_zero_rows)
  checkmate::assert_flag(add_total_row)
  checkmate::assert_flag(add_total_col,
                         null.ok = TRUE)
  checkmate::assert_string(lbl_total_row)
  checkmate::assert_string(lbl_total_col)
  rlang::check_installed("gt",
                         version = "0.9.0",
                         reason = pal::reason_pkg_required())
  
  ix_by <- tidyselect::eval_select(expr = rlang::enquo(by),
                                   data = data)
  n_by <- length(ix_by)
  has_by <- n_by > 0L
  
  if (n_by > 2L) {
    cli::cli_abort("At most {.emph two} additional data columns can be specified in {.arg by}, but {.val {n_by}} were provided.")
  }
  
  if (is.null(add_total_col)) {
    add_total_col <- has_by
  }
  
  by_names_print <- ifelse(has_by,
                           names(ix_by) %>%
                             prettify_var_names() %>%
                             pal::wrap_chr(wrap = "*") %>%
                             paste0(collapse = "<br><br>"),
                           "")
  data_to_plot <-
    data %>%
    n_rfrnds_per_period(period = period,
                        by = {{ by }},
                        fill_gaps = fill_gaps,
                        period_floor = period_floor,
                        period_ceiling = period_ceiling,
                        descending = descending) %>%
    dplyr::mutate(dplyr::across(where(is.factor),
                                \(x) forcats::fct_na_value_to_level(f = x,
                                                                    level = "N/A"))) %>%
    pal::when(has_by ~ tidyr::pivot_wider(data = .,
                                          names_from = {{ by }},
                                          names_sort = TRUE,
                                          values_from = n),
              ~ .) %>%
    pal::when(add_total_col ~ dplyr::mutate(.data = .,
                                            `:total` = rowSums(x = dplyr::pick(-!!as.symbol(period)),
                                                               na.rm = TRUE)),
              ~ .) %>%
    dplyr::mutate(dplyr::across(everything(),
                                \(x) tidyr::replace_na(data = x,
                                                       replace = 0L)))
  
  # squeeze consecutive all-0 rows into single row if requested
  ix <- integer()
  ix_rm <- integer()
  
  if (squeeze_zero_rows) {
    
    for (i in pal::safe_seq_len(nrow(data_to_plot))) {
      
      if (data_to_plot %>%
          dplyr::select(-any_of(c(period, ":total"))) %>%
          magrittr::extract(i, ) %>%
          sum() %>%
          magrittr::equals(0L)) {
        
        ix %<>% c(i)
        
      } else {
        if (length(ix) > 1L) {
          
          data_to_plot[ix[1L], period] <- paste0(data_to_plot[ix[length(ix)], period], "\u2013", data_to_plot[ix[1L], period])
          ix_rm %<>% c(ix[-1L])
        }
        ix <- integer()
      }
    }
    
    if (length(ix) > 1L) {
      data_to_plot[ix[1L], period] <- paste0(data_to_plot[ix[length(ix)], period], "\u2013", data_to_plot[ix[1L], period])
      ix_rm %<>% c(ix[-1L])
    }
  }
  
  # add "s" to decade/century period values
  if (period %in% c("decade", "century")) {
    data_to_plot[[period]] %<>% stringr::str_replace_all(pattern = "(\\d+)",
                                                         replacement = "\\1s")
  }
  
  data_to_plot %>%
    dplyr::filter(!(dplyr::row_number() %in% ix_rm)) %>%
    gt::gt(rowname_col = period) %>%
    pal::when(add_total_col ~ gt::cols_label(.data = .,
                                             `:total` = lbl_total_col),
              ~ .) %>%
    pal::when(add_total_row ~ {
      
      result <- gt::grand_summary_rows(data = .,
                                       fns = list(label = "DUMMY", id = "total") ~ sum(., na.rm = TRUE),
                                       fmt = ~ gt::fmt_integer(., sep_mark = ""))
      
      # TODO: remove this workaround and replace `"DUMMY"` with `lbl_total_row` above as soon as [#1295](https://github.com/rstudio/gt/issues/1295) is fixed.
      result$`_summary`[[1L]]$fns$total$label <- lbl_total_row
      
      result
    },
              ~ .) %>%
    gt::tab_spanner_delim(delim = "_",
                          split = "last") %>%
    gt::tab_stubhead(label = gt::md(by_names_print)) %>%
    gt::tab_style(style = gt::cell_text(align = "right",
                                        v_align = "middle"),
                  locations = gt::cells_stubhead())
}

#' Connect to RDB DBMS
#'
#' Connects to RDB's database management system, a PostgreSQL server managed by [neon.tech](https://neon.tech/).
#'
#' @param dbname Name of the RDB PostgreSQL database. Defaults to `r pal::as_md_vals(pg_db)`.
#' @param host `r pkg_config |> dplyr::filter(key == "pg_host") |> dplyr::pull("description")`
#' @param user `r pkg_config |> dplyr::filter(key == "pg_user") |> dplyr::pull("description")`
#' @param password `r pkg_config |> dplyr::filter(key == "pg_password") |> dplyr::pull("description")`
#' @param sslmode PostgreSQL connection parameter that determines whether or with what priority a secure TLS connection is negotiated with the server. See the
#'   [official documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNECT-SSLMODE) for more information about the supported
#'   keywords.
#'
#' @return `r pkgsnip::return_lbl("dbi_connection")` This object is used to communicate with the database engine.
#' @family admin
#' @export
#'
#' @examples
#' con <- rdb::connect()
#' 
#' con |> DBI::dbListTables()
connect <- function(dbname = pg_db,
                    host = pal::pkg_config_val("pg_host"),
                    user = pal::pkg_config_val("pg_user"),
                    password = pal::pkg_config_val("pg_password"),
                    sslmode = "verify-full") {
  
  DBI::dbConnect(drv = RPostgres::Postgres(),
                 dbname = dbname,
                 host = host,
                 port = pg_port,
                 user = user,
                 password = password,
                 sslmode = sslmode,
                 sslrootcert = fs::path_package(package = this_pkg,
                                                "certs/ISRG_Root_X1.pem"))
}

#' Update RDB `referendums` table
#'
#' Updates the RDB's `referendums` table with `data`. By default, rows not contained in `data` are kept.
#'
#' @inheritParams rfrnds
#' @inheritParams pg_tbl_update
#' @param data New or updated referendum data. A [tibble][tibble::tbl_df] that must contain a [`r pk("referendums")`](`r url_codebook("id")`) column
#'   identifying the referendums to be updated plus any additional columns containing the new values to update the corresponding database fields with.
#'
#' @return `data`, invisibly.
#' @family admin
#' @export
update_rfrnds <- function(data,
                          sweep = FALSE,
                          connection = connect(),
                          disconnect = TRUE) {
  
  checkmate::assert_flag(disconnect)
  
  # necessary to avoid error on first run of `connect()`
  force(connection)
  
  # convert `attachments` list col to JSON strings
  data %<>% dplyr::mutate(dplyr::across(.cols = any_of("attachments"),
                                        .fns = \(col) purrr::map_chr(col,
                                                                     \(x) {
                                                                       
                                                                       if (is.null(x) || nrow(x) == 0L) {
                                                                         return(NA_character_)
                                                                       }
                                                                       
                                                                       jsonlite::toJSON(x = x)
                                                                     })))
  dplyr::tbl(src = connection,
             from = DBI::Id(schema = pg_schema,
                            table = "referendums")) |>
    pg_tbl_update(data = data,
                  tbl_name = "referendums",
                  sweep = sweep,
                  connection = connection)
  
  if (disconnect) {
    DBI::dbDisconnect(conn = connection)
  }
  
  invisible(data)
}

#' Delete referendums from the RDB
#'
#' Deletes `data` from the RDB's `referendums` table.
#'
#' @inheritParams rfrnds
#' @param data Referendum data to be deleted. A [tibble][tibble::tbl_df] that at least must contain the column
#'   `r pk("referendums") |> pal::wrap_chr("\x60")`.
#'
#' @return The updated `referendums` table data as a [tibble][tibble::tbl_df], invisibly.
#' @family admin
#' @family data
#' @export
delete_rfrnds <- function(data,
                          connection = connect(),
                          disconnect = TRUE) {
  
  checkmate::assert_flag(disconnect)
  
  # necessary to avoid error on first run of `connect()`
  force(connection)
  
  result <-
    dplyr::tbl(src = connection,
               from = DBI::Id(schema = pg_schema,
                              table = "referendums")) |>
    pg_tbl_del(data = data,
               pk_col_names = pg_pk(tbl_name = "referendums",
                                    connection = connection))
  if (disconnect) {
    DBI::dbDisconnect(conn = connection)
  }
  
  invisible(result)
}

#' Update RDB `administrative_units` table
#'
#' Updates the RDB's `administrative_units` table with data combined from the `supranational_entities`, `countries`, `subnational_entities` and `municipalities`
#' tables.
#'
#' @inheritParams update_rfrnds
#'
#' @return The newly written `administrative_units` table data as a [tibble][tibble::tbl_df], invisibly.
#' @family admin
#' @export
update_administrative_units <- function(sweep = TRUE,
                                        connection = connect(),
                                        disconnect = TRUE) {
  # update source tbls
  update_countries(sweep = sweep,
                   connection = connection,
                   disconnect = FALSE)
  update_subnational_entities(sweep = sweep,
                              connection = connection,
                              disconnect = FALSE)
  update_municipalities(sweep = sweep,
                        connection = connection,
                        disconnect = FALSE)
  # update target tbl
  dplyr::bind_rows(
    # add countries
    read_tbl("countries") |>
      dplyr::transmute(id = code,
                       name,
                       level = "national",
                       type = "country",
                       parent_id = NA_character_),
    # add supranational entities
    # NONE YET
    # add subnational entities
    read_tbl("subnational_entities") |>
      dplyr::transmute(id = code,
                       name,
                       level = "subnational",
                       type = tolower(type),
                       parent_id = parent_code %|% stringr::str_extract(code, "^\\w+")),
    # add municipalities
    read_tbl("municipalities") |>
      dplyr::transmute(id,
                       name,
                       level = "municipal",
                       type = "municipality",
                       # NOTE: municipalities also have an *immediate* subnational entity parent (usually district), which we currently don't capture; this
                       #       shouldn't pose a problem since there are no legal instruments on these intermediate levels AFAIK
                       parent_id = subnational_entity_code)
  ) |>
    update_tbl(tbl_name = "administrative_units",
               sweep = sweep,
               connection = connection,
               disconnect = disconnect)
}

#' Update RDB `countries` table
#'
#' Updates the RDB's `countries` table with the data from [`data_iso_3166_1`] and [`data_iso_3166_3`].
#'
#' @inheritParams update_rfrnds
#'
#' @return The newly written `countries` table data as a [tibble][tibble::tbl_df], invisibly.
#' @family admin
#' @keywords internal
update_countries <- function(sweep = TRUE,
                             connection = connect(),
                             disconnect = TRUE) {
  
  data_iso_3166_1 |>
    dplyr::select(code = alpha_2,
                  name = name_short,
                  name_long) |>
    dplyr::bind_rows(dplyr::select(.data = data_iso_3166_3,
                                   code = alpha_4,
                                   name = name_short,
                                   name_long)) |>
    update_tbl(tbl_name = "countries",
               sweep = sweep,
               connection = connection,
               disconnect = disconnect)
}

#' Update RDB `subnational_entities` table
#'
#' Updates the RDB's `subnational_entities` table with the data from [`data_iso_3166_2`].
#'
#' @inheritParams update_rfrnds
#'
#' @return [`data_iso_3166_2`], invisibly.
#' @family admin
#' @keywords internal
update_subnational_entities <- function(sweep = TRUE,
                                        connection = connect(),
                                        disconnect = TRUE) {
  update_tbl(data = data_iso_3166_2,
             tbl_name = "subnational_entities",
             sweep = sweep,
             connection = connection,
             disconnect = disconnect)
}

#' Update RDB `municipalities` table
#'
#' Updates the RDB's `municipalities` table with the data from [`data_municipalities`].
#'
#' @inheritParams update_rfrnds
#'
#' @return [`data_municipalities`], invisibly.
#' @family admin
#' @keywords internal
update_municipalities <- function(sweep = TRUE,
                                  connection = connect(),
                                  disconnect = TRUE) {
  data_municipalities |>
    dplyr::mutate(id = NA_character_) |>
    update_tbl(tbl_name = "municipalities",
               sweep = sweep,
               connection = connection,
               disconnect = disconnect)
}

#' Update RDB `languages` table
#'
#' Updates the RDB's `languages` table with the data from [`data_iso_639_1`].
#'
#' @inheritParams update_rfrnds
#'
#' @return [`data_iso_639_1`], invisibly.
#' @family admin
#' @export
update_langs <- function(sweep = TRUE,
                         connection = connect(),
                         disconnect = TRUE) {
  
  update_tbl(data = data_iso_639_1,
             tbl_name = "languages",
             sweep = sweep,
             connection = connection,
             disconnect = disconnect)
}

#' Update RDB `topics` table
#'
#' Updates the RDB's `languages` table with the data from [`nest_topics(data_topics)`][nest_topics].
#'
#' @inheritParams update_rfrnds
#'
#' @return [`nest_topics(data_topics)`][data_topics], invisibly.
#' @family admin
#' @family topics
#' @export
update_topics <- function(sweep = TRUE,
                          connection = connect(),
                          disconnect = TRUE) {
  
  update_tbl(data = nest_topics(data_topics),
             tbl_name = "topics",
             sweep = sweep,
             connection = connection,
             disconnect = disconnect)
}

#' Update RDB `nocodb_users` table
#'
#' Updates the RDB's `nocodb_users` table with the current [user data][nocodb::users] from the specified NocoDB server.
#'
#' @inheritParams nocodb::users
#' @inheritParams update_rfrnds
#'
#' @return The newly written `nocodb_users` table data as a [tibble][tibble::tbl_df], invisibly.
#' @family admin
#' @export
update_nocodb_users <- function(origin = pal::pkg_config_val("nocodb_origin"),
                                sweep = FALSE,
                                connection = connect(),
                                disconnect = TRUE) {
  
  email <- pal::pkg_config_val("nocodb_email")
  password <- pal::pkg_config_val("nocodb_password")
  
  data_nocodb_users <- nocodb::users(origin = origin,
                                     email = email,
                                     password = password)
  ids_present <-
    read_tbl(tbl_name = "nocodb_users",
             connection = connection,
             disconnect = FALSE) |>
    dplyr::pull(nocodb_id)
  
  data_nocodb_users |>
    dplyr::filter(!(id %in% ids_present)) |>
    dplyr::select(nocodb_id = id,
                  name = display_name) |>
    update_tbl(tbl_name = "nocodb_users",
               sweep = sweep,
               connection = connection,
               disconnect = disconnect)
}

#' Back up RDB
#'
#' Fetches the complete RDB data – excluding fully programmatically administered tables – as a [`dm::dm`] object that also includes relationship information
#' (primary and foreign keys) and writes it to an [`.rds`][saveRDS] file.
#'
#' @inheritParams pg_tbl_read
#' @param path Path to write the RDB backup `.rds` file to.
#' @param overwrite Whether or not to overwrite an existing file under `path`.
#'
#' @return An object of type [`dm::dm`], invisibly.
#' @family admin
#' @export
backup_rdb <- function(path = "rdb_dm.rds",
                       overwrite = TRUE,
                       connection = connect(user = "rdb_admin",
                                            password = pg_role_pw("rdb_admin")),
                       disconnect = TRUE) {
  
  checkmate::assert_path_for_output(path,
                                    overwrite = overwrite,
                                    extension = "rds")
  checkmate::assert_flag(disconnect)
  
  dm_bkp <-
    dm(connection = connection,
               incl_admin_tbls = FALSE) |>
    dm_excl_gen_always_cols() |>
    dplyr::collect() %T>%
    saveRDS(file = path)
  
  if (disconnect) {
    DBI::dbDisconnect(conn = connection)
  }
  
  invisible(dm_bkp)
}

#' Restore RDB
#'
#' Restores RDB data – excluding fully programmatically administered tables – from a [`dm::dm`] object that is expected to include relationship information
#' (primary and foreign keys).
#'
#' @inheritParams pg_tbl_read
#' @param dm RDB data and relationships (primary and foreign keys) as a [`dm::dm`] object.
#' @param sweep Whether or not to also sweep existing RDB data, i.e. delete rows that are not contained in `dm`'s tables.
#'
#' @return `dm`, invisibly.
#' @family admin
#' @export
restore_rdb <- function(dm = readRDS(file = "rdb_dm.rds"),
                        sweep = FALSE,
                        connection = connect(),
                        disconnect = TRUE) {
  assert_dm(dm)
  
  tbl_names_todo <-
    tbl_metadata |>
    dplyr::filter(!is_admin) |>
    dplyr::pull(name)
  
  tbl_names_done <- character()
  
  tbl_deps_left <-
    dm |>
    dm::dm_select_tbl(!!tbl_names_todo) |>
    dm_excl_gen_always_cols() |>
    dm::dm_get_all_fks() |>
    dplyr::group_by(child_table) |>
    dplyr::summarise(parent_tbls = list(unique(parent_table)))
  
  while (length(tbl_names_todo) > 0L) {
    
    tbl_names_next <- setdiff(tbl_names_todo,
                              tbl_deps_left$child_table)
    # restore next tbls
    tbl_names_next |>
      purrr::walk(\(tbl_name) update_tbl(data = dm[[tbl_name]],
                                         tbl_name = tbl_name,
                                         sweep = sweep,
                                         override_pk_sys_val = TRUE,
                                         connection = connection,
                                         disconnect = FALSE))
    tbl_names_done %<>% c(tbl_names_next)
    tbl_names_todo %<>% setdiff(y = tbl_names_next)
    tbl_deps_left %<>% dplyr::filter(purrr::map_lgl(parent_tbls, \(x) any(x %in% tbl_names_todo)))
  }
  
  if (disconnect) {
    DBI::dbDisconnect(conn = connection)
  }
  
  invisible(dm)
}

#' Reset RDB
#'
#' Resets the RDB NocoDB server, optionally including the whole RDB PostgreSQL database and/or tables.
#'
#' @inheritParams nocodb::update_app_settings
#' @inheritParams rfrnds
#' @param origin_nocodb NocoDB server [origin](https://developer.mozilla.org/docs/Glossary/Origin). A character scalar.
#' @param hostname_pg PostgreSQL server hostname. A character scalar.
#' @param reset_db Whether or not to first fully recreate the RDB PostgreSQL database using [pg_reset_db()] and [pg_init_db()]. If `FALSE`, only the RDB
#'   PostgreSQL tables are recreated.
#' @param reset_tbls Whether or not to recreate the RDB PostgreSQL tables.
#' @param ask Whether or not to ask for confirmation before proceeding. Only relevant if run [interactively][interactive].
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `origin_nocodb`, invisibly.
#' @family admin
#' @family nocodb
#' @export
#'
#' @examples
#' \dontrun{
#' # reset production PGSQL DB branch and NocoDB instance
#' rdb::reset_rdb(reset_db = TRUE)
#'
#' # reset testing PGSQL DB branch and NocoDB instance
#' rdb::reset_rdb(origin_nocodb = Sys.getenv("R_RDB_NOCODB_ORIGIN_TESTING"),
#'                hostname_pg = Sys.getenv("R_RDB_PG_HOST_TESTING"),
#'                reset_db = TRUE)}
# nolint start: cyclocomp_linter
reset_rdb <- function(origin_nocodb = pal::pkg_config_val("nocodb_origin"),
                      hostname_pg = pal::pkg_config_val("pg_host"),
                      reset_db = FALSE,
                      reset_tbls = reset_db,
                      ask = TRUE,
                      disconnect = TRUE,
                      quiet = FALSE) {
  
  checkmate::assert_string(origin_nocodb)
  checkmate::assert_flag(reset_db)
  checkmate::assert_flag(reset_tbls)
  checkmate::assert_flag(ask)
  checkmate::assert_flag(disconnect)
  checkmate::assert_flag(quiet)
  
  if (reset_db && !reset_tbls) {
    cli::cli_abort("{.arg reset_tbls} cannot be {.val FALSE} when {.arg reset_db} is {.val TRUE}.")
  }
  
  # if run interactively, ask for confirmation before continuing
  if (ask && interactive()) {
    cli::cli_alert_warning(paste0("{.strong CAUTION!}\nContinuing completely resets ",
                                  ifelse(reset_tbls,
                                         paste0("the RDB PostgreSQL ",
                                                ifelse(reset_db,
                                                       "database including all ",
                                                       ""),
                                                "tables and "),
                                         ""),
                                  "the RDB NocoDB server {.field {origin_nocodb}}. This results in loss of all ",
                                  ifelse(reset_tbls,
                                         "existing PostgreSQL data as well as ",
                                         ""),
                                  "NocoDB-specific metadata (comments, audit logs etc.).\n\n"))
    if (!yesno::yesno2("Are you sure you want to continue?")) {
      return(invisible(origin_nocodb))
    }
  }
  
  email <- pal::pkg_config_val("nocodb_email")
  password <- pal::pkg_config_val("nocodb_password")
  
  # back up RDB data if necessary ----
  if (reset_tbls) {
    # we write `dm_bkp` to disk in order to be prepared for any failures in between
    path_rdb_backup <- "tmp_rdb_dm_bkp.rds"
    rdb_dm <- backup_rdb(path = path_rdb_backup,
                         overwrite = TRUE,
                         connection = connect(host = hostname_pg,
                                              user = "rdb_admin",
                                              password = pg_role_pw("rdb_admin")),
                         disconnect = TRUE)
  }
  
  # reset PGSQL DB ----
  if (reset_db) {
    
    if (!quiet) {
      pal::cli_progress_step_quick("Recreating PostgreSQL database")
    }
    pg_reset_db(connection = connect(dbname = "postgres",
                                     host = hostname_pg,
                                     user = "rdb_admin",
                                     password = pg_role_pw("rdb_admin")),
                disconnect = TRUE)
    
    # restart Neon compute endpoints (otherwise the read-only one becomes inaccessible sometimes)
    endpoint_id <- hostname_to_ep(hostname_pg)
    endpoint_id_ro <- hostname_to_ep(pal::pkg_config_val_default(key = "pg_host"))
    ## restart RW endpoint before RO one
    restart_neon_ep(project_id = neon_project_id,
                    endpoint_id = endpoint_id)
    ## only restart the RO endpoint for *production* (testing branch has no RO endpoint)
    ## NOTE: 2nd condition is kinda hacky, i.e. not really correct, but works for our case (strict correctness would mean comparing against `pg_host` which we
    ##       cannot do here since we don't make the RW endpoints public)
    if (endpoint_id_ro != endpoint_id && origin_nocodb == pal::pkg_config_val_default(key = "nocodb_origin")) {
      restart_neon_ep(project_id = neon_project_id,
                      endpoint_id = endpoint_id_ro)
    }
    
    # NOTE: we can only establish a reusable `connection` *after* possible DB deletion just above
    connection <- connect(host = hostname_pg,
                          user = "rdb_admin",
                          password = pg_role_pw("rdb_admin"))
    pg_init_db(connection = connection,
               disconnect = FALSE)
    
  } else if (reset_tbls) {
    
    if (!quiet) {
      pal::cli_progress_step_quick("Dropping existing PostgreSQL tables")
    }
    connection <- connect(host = hostname_pg,
                          user = "rdb_admin",
                          password = pg_role_pw("rdb_admin"))
    pg_drop_tbls(tbl_names = tbl_metadata$name,
                 connection = connection,
                 disconnect = FALSE)
  }
  
  # reset PGSQL tbls ----
  if (reset_tbls) {
    
    if (!quiet) {
      pal::cli_progress_step_quick("Initializing auxiliary PostgreSQL tables")
    }
    pg_init_aux_tbls(connection = connection,
                     disconnect = FALSE)
    
    if (!quiet) {
      pal::cli_progress_step_quick("Initializing main PostgreSQL tables")
    }
    pg_init_main_tbls(connection = connection,
                      disconnect = FALSE)
  }
  
  # reset NocoDB base ----
  if (!quiet) {
    pal::cli_progress_step_quick("Resetting NocoDB base")
  }
  reset_nocodb(origin = origin_nocodb,
               ask = FALSE,
               quiet = TRUE)
  
  Sys.sleep(1.0)
  
  if (reset_tbls) {
    # add meta cols ----
    if (!quiet) {
      pal::cli_progress_step_quick("Adding PostgreSQL meta columns via NocoDB API")
    }
    create_nocodb_tbl_cols(origin = origin_nocodb)
    
    # run post-NocoDB PGSQL steps ----
    if (!quiet) {
      pal::cli_progress_step_quick("Altering PostgreSQL meta columns")
    }
    pg_post_nocodb(connection = connection,
                   disconnect = FALSE)
    
    # populate PGSQL tbls ----
    if (!quiet) {
      pal::cli_progress_step_quick("Populating auxiliary PostgreSQL tables")
    }
    update_administrative_units(connection = connection,
                                disconnect = FALSE)
    update_langs(connection = connection,
                 disconnect = FALSE)
    update_topics(connection = connection,
                  disconnect = FALSE)
    pg_add_default_data(connection = connection,
                        disconnect = FALSE)
    ## restore RDB data ----
    restore_rdb(dm = rdb_dm,
                sweep = FALSE,
                connection = connection,
                disconnect = FALSE)
    unlink(path_rdb_backup)
  }
  
  # sync NocoDB data src ----
  if (!quiet) {
    pal::cli_progress_step_quick("Synchronizing NocoDB data source with external PostgreSQL schema")
  }
  id_base <- nocodb::base_id(title = nocodb_base_title,
                             origin = origin_nocodb,
                             email = email,
                             password = password)
  id_data_src <- nocodb::data_src_id(alias = nocodb_data_src_alias,
                                     id_base = id_base,
                                     origin = origin_nocodb,
                                     email = email,
                                     password = password)
  
  nocodb::sync_data_src_eagerly(id_data_src = id_data_src,
                                id_base = id_base,
                                origin = origin_nocodb,
                                email = email,
                                password = password,
                                wait_max = 30L,
                                wait_resync = 7.0)
  # config NocoDB tbls ----
  if (!quiet) {
    pal::cli_progress_step_quick("Configuring NocoDB tables")
  }
  config_nocodb_tbls(origin = origin_nocodb,
                     quiet = quiet)
  
  # prohibit further schema changes from NocoDB
  nocodb::update_data_src(id_data_src = id_data_src,
                          is_schema_readonly = TRUE,
                          id_base = id_base,
                          origin = origin_nocodb,
                          email = email,
                          password = password)
  
  # trigger PostgREST schema cache reload ----
  if (!quiet) {
    # pal::cli_progress_step_quick("Notifying PostgREST server about schema changes")
    pal::cli_progress_step_quick("Restarting PostgREST server to cause schema cache reload")
  }
  # notify_postgrest(connection = connection,
  #                  disconnect = FALSE)
  restart_postgrest(quiet = TRUE)
  
  # disconnect PGSQL ----
  if (reset_tbls && disconnect) {
    DBI::dbDisconnect(conn = connection)
  }
  
  invisible(origin_nocodb)
}
# nolint end

#' Restart Neon.tech PostgreSQL endpoint
#'
#' Restarts the Neon.tech PostgreSQL [compute endpoint](https://neon.tech/docs/reference/glossary#compute-endpoint) via the
#' [`/projects/{project_id}/endpoints/{endpoint_id}/restart` API endpoint](https://api-docs.neon.tech/reference/restartprojectendpoint).
#'
#' @inheritParams pal::req_cached
#' @param project_id Neon.tech project identifier. A character scalar.
#' @param endpoint_id Neon.tech compute endpoint identifier. A character scalar.
#' @param api_key [API key](https://neon.tech/docs/manage/api-keys) with sufficient access to the Neon.tech `project_id`.
#'
#' @return The HTTP response body as a list.
#' @family neon
#' @family admin
#' @keywords internal
restart_neon_ep <- function(project_id = neon_project_id,
                            endpoint_id = hostname_to_ep(pal::pkg_config_val("pg_host")),
                            api_key = pal::pkg_config_val("neon_api_key"),
                            max_tries = 3L) {
  
  checkmate::assert_string(project_id)
  checkmate::assert_string(endpoint_id)
  checkmate::assert_string(api_key)
  checkmate::assert_count(max_tries,
                          positive = TRUE)
  
  result <- tryCatch(expr =
                       httr2::request(base_url = glue::glue("https://console.neon.tech/api/v2/projects/{project_id}/endpoints/{endpoint_id}/restart")) |>
                       httr2::req_method(method = "POST") |>
                       httr2::req_user_agent(string = "rdb R package (https://rdb.rpkg.dev)") |>
                       httr2::req_headers(authorization = paste("Bearer", api_key)) |>
                       httr2::req_retry(max_tries = max_tries) |>
                       httr2::req_error(body = \(resp) httr2::resp_body_json(resp)$message) |>
                       httr2::req_perform() |>
                       httr2::resp_body_json(),
                     httr2_http_423 = \(cnd) {
                       # infinitely retry with 1s wait in case of HTTP 423 status
                       # cf. https://community.neon.tech/t/project-already-has-running-operations-scheduling-of-new-ones-is-prohibited/242/2
                       Sys.sleep(1.0)
                       restart_neon_ep(project_id = project_id,
                                       endpoint_id = endpoint_id,
                                       api_key = api_key,
                                       max_tries = max_tries)
                     })
  invisible(result)
}

#' Create NocoDB tables
#'
#' @description
#' `r lifecycle::badge("deprecated")` in favor of [create_nocodb_tbl_cols()].
#'
#' Creates all the PostgreSQL database tables that must be first created *once* in NocoDB after the PostgreSQL database has been added as external data source
#' (e.g. via [reset_nocodb()]) to let NocoDB register the necessary metadata for the `created_by` and `updated_by` columns (so they are properly auto-filled by
#' NocoDB later on).
#'
#' After running `create_nocodb_tbls()`, the created tables are supposed to be recreated outside of NocoDB via [pg_init_main_tbls()].
#'
#' @inheritParams nocodb::data_src_id
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about the newly created tables")`
#' @family nocodb
#' @family admin
#' @keywords internal
create_nocodb_tbls <- function(origin = pal::pkg_config_val("nocodb_origin")) {
  
  email <- pal::pkg_config_val("nocodb_email")
  password <- pal::pkg_config_val("nocodb_password")
  id_base <- nocodb::base_id(title = nocodb_base_title,
                             origin = origin,
                             email = email,
                             password = password)
  id_data_src <- nocodb::data_src_id(alias = nocodb_data_src_alias,
                                     id_base = id_base,
                                     origin = origin,
                                     email = email,
                                     password = password)
  tbl_names <- tbl_metadata$name
  
  i_existing_tbl_names <-
    nocodb::tbls(id_base = id_base,
                 origin = origin,
                 email = email,
                 password = password) |>
    pal::when(nrow(.) == 0L ~ integer(),
              ~ which(tbl_names %in% .$table_name))
  
  if (length(i_existing_tbl_names) > 0L) {
    cli::cli_abort("The following tables to be created already exist: {.val {tbl_names[i_existing_tbl_names]}}")
  }
  
  tbl_names |>
    purrr::map(\(tbl_name) nocodb::create_data_src_tbl(id_data_src = id_data_src,
                                                       name = tbl_name,
                                                       title = tbl_name,
                                                       cols = list(list(column_name = "foobar",
                                                                        title = "foobar",
                                                                        dt = "text",
                                                                        dtx = "text",
                                                                        nrqd = FALSE,
                                                                        rqd = TRUE,
                                                                        ck = FALSE,
                                                                        pk = TRUE,
                                                                        un = FALSE,
                                                                        ai = FALSE,
                                                                        uidt = "LongText")),
                                                       id_base = id_base,
                                                       origin = origin,
                                                       email = email,
                                                       password = password)) |>
    purrr::list_rbind()
}

#' Create NocoDB table meta columns
#'
#' Adds the PostgreSQL meta columns `created_by`, `updated_by`, `created_at` and `updated_at` to all RDB tables via NocoDB's API.
#'
#' @inheritParams nocodb::data_src_id
#'
#' @return `origin`, invisibly.
#' @family nocodb
#' @family admin
#' @keywords internal
create_nocodb_tbl_cols <- function(origin = pal::pkg_config_val("nocodb_origin")) {
  
  email <- pal::pkg_config_val("nocodb_email")
  password <- pal::pkg_config_val("nocodb_password")
  id_base <- nocodb::base_id(title = nocodb_base_title,
                             origin = origin,
                             email = email,
                             password = password)
  tbl_metadata |>
    dplyr::filter(name %in% nocodb::tbls(id_base = id_base,
                                         include_m2m = TRUE,
                                         origin = origin,
                                         email = email,
                                         password = password)$table_name) |>
    dplyr::pull("name") |>
    purrr::walk(\(name) {
      
      id_tbl <- nocodb::tbl_id(name = name,
                               id_base = id_base,
                               origin = origin,
                               email = email,
                               password = password)
      nocodb::create_tbl_col(id_tbl = id_tbl,
                             column_name = "created_by",
                             uidt = "CreatedBy",
                             dt = "text",
                             origin = origin,
                             email = email,
                             password = password)
      nocodb::create_tbl_col(id_tbl = id_tbl,
                             column_name = "updated_by",
                             uidt = "LastModifiedBy",
                             dt = "text",
                             origin = origin,
                             email = email,
                             password = password)
      nocodb::create_tbl_col(id_tbl = id_tbl,
                             column_name = "created_at",
                             uidt = "CreatedTime",
                             origin = origin,
                             email = email,
                             password = password)
      nocodb::create_tbl_col(id_tbl = id_tbl,
                             column_name = "updated_at",
                             uidt = "LastModifiedTime",
                             origin = origin,
                             email = email,
                             password = password)
    })
  
  invisible(origin)
}

#' Configure NocoDB tables
#'
#' @description
#' Configures the RDB tables on the specified NocoDB server. Currently, this includes:
#' 
#' - Setting the correct display value columm for all tables via [nocodb::set_display_vals()].
#' - Setting the proper metadata for all tables via [nocodb::set_tbl_metadata()].
#' - Setting the proper visibility rules (UI ACL) for the default view of all tables via [nocodb::update_base_ui_acl()].
#'
#' @inheritParams nocodb::set_tbl_metadata
#'
#' @return `origin`, invisibly.
#' @family nocodb
#' @family admin
#' @keywords internal
config_nocodb_tbls <- function(origin = pal::pkg_config_val("nocodb_origin"),
                               quiet = FALSE) {
  
  email <- pal::pkg_config_val("nocodb_email")
  password <- pal::pkg_config_val("nocodb_password")
  id_base <- nocodb::base_id(title = nocodb_base_title,
                             origin = origin,
                             email = email,
                             password = password)
  # set display vals
  data <-
    tbl_metadata |>
    dplyr::rename_with(.cols = starts_with("nocodb_"),
                       .fn = \(x) stringr::str_remove(string = x,
                                                      pattern = "^nocodb_"))
  nocodb::set_display_vals(data = data,
                           id_base = id_base,
                           origin = origin,
                           email = email,
                           password = password,
                           quiet = quiet)
  # set tbl metadata
  data |>
    # NOTE: we exclude junction tbls since they are hidden in NocoDB and its API
    dplyr::filter(!is.na(display_col)) |>
    nocodb::set_tbl_metadata(id_base = id_base,
                             origin = origin,
                             email = email,
                             password = password,
                             quiet = quiet)
  
  # set visibility rules for default tbl views (hide aux tbls for all roles below `creator`)
  data |>
    dplyr::filter(is_aux) |>
    dplyr::pull(name) |>
    purrr::walk(\(tbl_name) nocodb::update_base_ui_acl(id_tbl_view = nocodb::tbl_view_id(id_tbl = nocodb::tbl_id(name = tbl_name,
                                                                                                                 id_base = id_base,
                                                                                                                 origin = origin,
                                                                                                                 email = email,
                                                                                                                 password = password),
                                                                                         type = "default",
                                                                                         origin = origin,
                                                                                         email = email,
                                                                                         password = password),
                                                       editor = TRUE,
                                                       id_base = id_base,
                                                       origin = origin,
                                                       email = email,
                                                       password = password,
                                                       quiet = quiet))
  invisible(origin)
}

#' Reset NocoDB
#'
#' Completely re-creates the connection settings and `r pal::wrap_chr(nocodb_base_title, "\x60")` base and adds the RDB team's user accounts on the specified
#' NocoDB server. `r nocodb_reset_caution`
#'
#' @inheritParams nocodb::update_app_settings
#' @param ask Whether or not to ask for confirmation before deleting the existing RDB NocoDB base. Only relevant if run [interactively][interactive].
#' @param save_user_mapping Whether or not to add NocoDB's current user data to the `nocodb_users` table via [update_nocodb_users()] before resetting it.
#'
#' @return `origin`, invisibly.
#' @family nocodb
#' @family admin
#' @keywords internal
# nolint start: cyclocomp_linter
reset_nocodb <- function(origin = pal::pkg_config_val("nocodb_origin"),
                         ask = TRUE,
                         save_user_mapping = TRUE,
                         quiet = TRUE) {
  
  checkmate::assert_flag(ask)
  checkmate::assert_flag(save_user_mapping)
  checkmate::assert_flag(quiet)
  rlang::check_installed("yesno",
                         reason = pal::reason_pkg_required())
  
  email <- pal::pkg_config_val("nocodb_email")
  password <- pal::pkg_config_val("nocodb_password")
  
  # delete possibly existing base
  bases <- nocodb::bases(origin = origin,
                         email = email,
                         password = password)
  
  if (nrow(bases) > 0L && nocodb_base_title %in% bases$title) {
    
    # if run interactively, ask for confirmation before continuing
    if (ask && interactive()) {
      cli::cli_alert_warning(paste0("{.strong CAUTION!}\nContinuing completely wipes the existing {.val {nocodb_base_title}} base on the NocoDB server ",
                                    "{.field {origin}}. This results in loss of all existing NocoDB-specific metadata (comments, audit logs etc.).\n\n"))
      if (!yesno::yesno2("Are you sure you want to continue?")) {
        return(invisible(origin))
      }
    }
    
    # update `nocodb_users` PGSQL tbl with latest data if requested
    if (save_user_mapping) {
      update_nocodb_users(origin = origin,
                          sweep = FALSE,
                          disconnect = TRUE)
    }
    
    bases |>
      dplyr::filter(title == !!nocodb_base_title) |>
      dplyr::pull("id") |>
      nocodb::delete_base(origin = origin,
                          email = email,
                          password = password)
  }
  
  ## log out to avoid stale auth token
  nocodb::sign_out(origin = origin,
                   email = email,
                   password = password,
                   quiet = quiet)
  
  # create new base
  id_base <-
    nocodb::create_base(title = nocodb_base_title,
                        color = color_rdb_main,
                        show_null_and_empty_in_filter = TRUE,
                        origin = origin,
                        email = email,
                        password = password) |>
    dplyr::pull("id")
  
  Sys.sleep(3.0)
  
  # add PGSQL data source
  nocodb::create_data_src(alias = nocodb_data_src_alias,
                          type = "pg",
                          connection = list(sslmode = "verify-full",
                                            user = "nocodb",
                                            password = pg_role_pw("nocodb"),
                                            database = pg_db,
                                            host = pal::pkg_config_val("pg_host"),
                                            port = 5432L,
                                            ssl = list(ca = "",
                                                       cert = "",
                                                       key = "")),
                          inflection_column = "none",
                          inflection_table = "none",
                          is_schema_readonly = FALSE,
                          is_data_readonly = FALSE,
                          enabled = TRUE,
                          id_base = id_base,
                          origin = origin,
                          email = email,
                          password = password)
  Sys.sleep(1.0)
  
  # ensure data src was created succcessfully
  id_data_src <-
    nocodb::data_srcs(id_base = id_base,
                      origin = origin,
                      email = email,
                      password = password) |>
    dplyr::filter(type == "pg" & alias == !!nocodb_data_src_alias) |>
    dplyr::pull("id")
  
  n_data_srcs <- length(id_data_src)
  
  if (n_data_srcs == 0L) {
    
    cli::cli_abort(message = "Creating external PostgreSQL data source on NocoDB failed for unknown reason. Please investigate.",
                   .internal = TRUE)
    
  } else if (n_data_srcs > 1L) {
    cli::cli_abort(message = paste0("Multiple external PostgreSQL data sources of type {.field pg} with alias {.val {nocodb_data_src_alias}} found on NocoDB ",
                                    "server. Please investigate."),
                   .internal = TRUE)
  }
  
  Sys.sleep(3.0)
  
  # sync PGSQL data source
  nocodb::sync_data_src_eagerly(id_data_src = id_data_src,
                                id_base = id_base,
                                origin = origin,
                                email = email,
                                password = password,
                                wait_max = 30L,
                                wait_resync = 7.0)
  
  # disable default SQLite data source
  nocodb::data_srcs(id_base = id_base,
                    origin = origin,
                    email = email,
                    password = password) |>
    dplyr::filter(type == "sqlite3" & is_meta) |>
    purrr::chuck("id") |>
    nocodb::update_data_src(enabled = FALSE,
                            id_base = id_base,
                            origin = origin,
                            email = email,
                            password = password)
  
  # set current user's display name (derived from e-mail address)
  email |>
    stringr::str_extract(pattern = "(.+?)@",
                         group = 1L) |>
    stringr::str_replace_all(pattern = stringr::fixed("."),
                             replacement = " ") |>
    stringr::str_to_title() |>
    nocodb::update_user(origin = origin,
                        email = email,
                        password = password)
  
  # add user accounts if necessary
  path_users_ref <- pal::pkg_config_val("nocodb_user_account_csv_file")
  
  if (!is.null(path_users_ref) && fs::file_exists(path_users_ref)) {
    
    users_ref <- readr::read_csv(file = path_users_ref,
                                 col_types = "c")
    pal::assert_cols(data = users_ref,
                     cols = c("name", "email", "password", "role"),
                     obj_name = "nocodb_user_account_csv_file")
    base_users <- nocodb::base_users(id_base = id_base,
                                     origin = origin,
                                     email = email,
                                     password = password)
    users_to_create <- users_ref |> dplyr::filter(!(email %in% base_users$email))
    
    # create missing users
    if (nrow(users_to_create) > 0L) {
      
      if (!quiet) {
        cli::cli_h1("Adding missing NocoDB user accounts")
      }
      
      # temporarily allow sign-up without invitation to avoid sending e-mails
      nocodb::update_app_settings(invite_only_signup = FALSE,
                                  origin = origin,
                                  email = email,
                                  password = password,
                                  quiet = quiet)
      users_to_create |>
        dplyr::rename_with(.cols = everything(),
                           .fn = \(x) paste0("user_", x)) |>
        purrr::pwalk(\(user_name, user_email, user_password, ...) {
          
          nocodb::sign_up_user(user_email = user_email,
                               user_password = user_password,
                               origin = origin,
                               email = email,
                               password = password)
          result <- nocodb::update_user(display_name = user_name,
                                        origin = origin,
                                        email = user_email,
                                        password = user_password)
          # user e-mail validation benefit is unclear, but we do it anyways
          nocodb::validate_user_email(verification_token = result$email_verification_token,
                                      origin = origin,
                                      quiet = quiet)
        })
      
      # trigger NocoDB internal state update
      nocodb::users(origin = origin,
                    email = email,
                    password = password)
    }
    
  } else {
    cli::cli_alert_warning(paste0("The package configuration option {.field nocodb_user_account_csv_file} is not set to a CSV file path, thus no user accounts",
                                  " were created."))
  }
  
  # update base user roles
  if (exists("users_ref")) {
    users_ref |>
      dplyr::rename_with(.cols = everything(),
                         .fn = \(x) paste0("user_", x)) |>
      purrr::pwalk(\(user_email, user_role, ...) {
        nocodb::update_base_user(user_email = user_email,
                                 role = user_role,
                                 id_base = id_base,
                                 origin = origin,
                                 email = email,
                                 password = password,
                                 quiet = quiet)
      })
  }
  
  # disable sign-up without invitation
  nocodb::update_app_settings(invite_only_signup = TRUE,
                              origin = origin,
                              email = email,
                              password = password,
                              quiet = quiet)
  invisible(origin)
}
# nolint end

#' Purge NocoDB
#'
#' Stops the `fly_app` NocoDB instance, purges NocoDB's internal database (the Litestream replication stored under `{s3_bucket}/nocodb`) and then restarts the
#' NocoDB instance, thereby resetting it to factory settings. `r nocodb_reset_caution`
#'
#' @inheritParams clean_attachment_bucket
#' @inheritParams reset_rdb
#' @param fly_app Fly.io app name.
#' @param s3_bucket Name of the S3-compatible object storage bucket to which NocoDB's internal SQLite database is replicated to via Litestream.
#'
#' @return `fly_app`, invisibly.
#' @family nocodb
#' @family admin
#' @keywords internal
#'
#' @examples
#' \dontrun{
#' # purge NocoDB production instance
#' rdb:::purge_nocodb()
#'
#' # purge NocoDB testing instance
#' rdb:::purge_nocodb(fly_app = "rdb-nocodb-testing")}
purge_nocodb <- function(fly_app = "rdb-nocodb",
                         s3_bucket = fly_app,
                         s3_endpoint = s3_endpoint_url,
                         s3_access_key = pal::pkg_config_val("nocodb_s3_access_key"),
                         s3_access_secret = pal::pkg_config_val("nocodb_s3_access_secret"),
                         ask = TRUE,
                         quiet = FALSE) {
  
  checkmate::assert_string(fly_app)
  checkmate::assert_string(s3_bucket)
  checkmate::assert_flag(ask)
  checkmate::assert_flag(quiet)
  pal::assert_cli(cmd = "flyctl")
  
  app_flag <- glue::glue("--app={fly_app}")
  s3_url <- glue::glue("s3://{s3_bucket}/nocodb")
  out <- ifelse(quiet,
                FALSE,
                "")
  
  # if run interactively, ask for confirmation before continuing
  if (ask && interactive()) {
    cli::cli_alert_warning(paste0("{.strong CAUTION!}\nContinuing completely resets the NocoDB server running as Fly app {.field {fly_app}}. This results",
                                  " in loss of all existing NocoDB-specific metadata (comments, audit logs etc.).\n\n"))
    if (!yesno::yesno2("Are you sure you want to continue?")) {
      return(invisible(fly_app))
    }
  }
  
  # define local fns
  fly_app_status <- function() {
    system2(command = "flyctl",
            args = c("status", "--json", app_flag),
            stdout = TRUE) |>
    jsonlite::fromJSON()
  }
  
  fly_machine_config <- function(machine_id) {
    system2(command = "flyctl",
            args = c("machine", "status", "--display-config", app_flag, machine_id),
            stdout = TRUE) |>
      # extract JSON data
      paste(collapse = " ") |>
      stringr::str_extract(pattern = "\\{.+\\}") |>
      cli::ansi_strip() |>
      jsonlite::fromJSON()
  }
  
  # get Fly app status
  data_app_status <- fly_app_status()
  
  # extract 1st machine ID
  machine_id <- data_app_status$Machines$id[1L]
  
  # get Fly machine config
  data_machine_config <- fly_machine_config(machine_id)
  machine_autostart <- data_machine_config$services$autostart[1L]
  
  # temporarily disable machine autostart if necessary
  if (machine_autostart) {
    system2(command = "flyctl",
            args = c("machine", "update", "--autostart=false", "--skip-start", "--yes", app_flag, machine_id),
            stdout = out,
            stderr = out)
  }
  
  # stop running machine
  if (data_app_status$Machines$state[1L] != "stopped") {
    system2(command = "flyctl",
            args = c("machine", "stop", app_flag, machine_id),
            stdout = out,
            stderr = out)
  }
  
  # delete NocoDB Litestream data from S3 bucket
  s3_auth(s3_endpoint = s3_endpoint,
          s3_access_key = s3_access_key,
          s3_access_secret = s3_access_secret)
  
  s3fs::s3_dir_delete(path = s3_url)
  
  # wait until deletion has fully propagated
  repeat {
    
    s3_files <- s3fs::s3_dir_ls(path = s3_url,
                                recurse = TRUE)
    
    if (length(s3_files) == 0L) {
      break
    }
    
    Sys.sleep(1.0)
  }
  
  # reenable machine autostart (implicitly restarts machine)
  if (machine_autostart) {
    system2(command = "flyctl",
            args = c("machine", "update", "--autostart=true", "--skip-start", "--yes", app_flag, machine_id),
            stdout = out,
            stderr = out)
  }
  
  # restart Fly app if necessary
  Sys.sleep(1.0)
  data_app_status <- fly_app_status()
  
  if (data_app_status$Status != "deployed" || data_app_status$Machines$state[1L] != "started") {
    system2(command = "flyctl",
            args = c("apps", "restart", fly_app),
            stdout = out,
            stderr = out)
  }
  
  invisible(fly_app)
}

#' Notify RDB PostgREST about schema changes
#'
#' Sends a `reload schema` message on the `pgrst` PostgreSQL [notification channel](https://www.postgresql.org/docs/16/sql-notify.html), which triggers the RDB
#' PostgREST server to [reload its schema cache](https://postgrest.org/en/latest/references/schema_cache.html#schema-cache-reloading).
#' 
#' Note that `notify_postgrest()` only works if the PostgREST server is actively `LISTEN`ing on the `pgrst` channel, which [requires a connection to a
#' read-write PostgreSQL instance](https://postgrest.org/en/v12/references/listener.html#listener-on-read-replicas).
#'
#' @inheritParams rfrnds
#'
#' @return `NULL`, invisibly.
#' @family postgrest
#' @family admin
#' @keywords internal
notify_postgrest <- function(connection = connect(),
                             disconnect = TRUE) {
  
  checkmate::assert_flag(disconnect)
  
  DBI::dbWithTransaction(conn = connection,
                         code = DBI::dbClearResult(DBI::dbSendStatement(statement = DBI::SQL("NOTIFY pgrst, 'reload schema';"),
                                                                        conn = connection)))
  if (disconnect) {
    DBI::dbDisconnect(conn = connection)
  }
  
  invisible(NULL)
}

#' Restart RDB PostgREST server
#'
#' Restarts the RDB PostgREST server VM (a [Fly.io](https://fly.io/docs/) app), which causes a [schema cache
#' reload](https://postgrest.org/en/latest/references/schema_cache.html#schema-cache-reloading).
#'
#' `restart_postgrest()` serves as an alternative to [notify_postgrest()] when the PostgREST server is not `LISTEN`ing on the `pgrst` channel (e.g. because it
#' is not [connected to a read-write PostgreSQL instance](https://postgrest.org/en/v12/references/listener.html#listener-on-read-replicas)).
#'
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `NULL`, invisibly
#' @family postgrest
#' @family admin
#' @keywords internal
restart_postgrest <- function(api_token = pal::pkg_config_val("fly_io_api_token"),
                              quiet = FALSE) {
  
  checkmate::assert_flag(quiet)
  pal::assert_cli("flyctl")
  
  out <- ifelse(quiet,
                FALSE,
                "")
  
  system2(command = "flyctl",
          args = c("apps", "restart", "rdb-postgrest", "--access-token", pal::wrap_chr(api_token, wrap = "'")),
          stdout = out,
          stderr = out)
  
  invisible(NULL)
}

#' List referendum territories from [sudd.ch](https://sudd.ch/)
#'
#' Lists [all referendum territories from sudd.ch](https://sudd.ch/list.php?mode=allareas), which means each `country_name_de` together with all the associated
#' `territory_name_de`, their search URL and their number of occurrences.
#'
#' Note that the values in the `territory_name_de` column returned by this function can differ from those in the `territory_name_de` column of
#' [sudd_rfrnds()] and [list_sudd_rfrnds()]. The latter is often more extensive and usually includes the `country_name_de` (in parentheses) for
#' subnational referendums.
#'
#' @inheritSection sudd_rfrnds About [sudd.ch](https://sudd.ch/)
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family sudd
#' @export
#'
#' @examples
#' rdb::list_sudd_territories()
list_sudd_territories <- function() {
  
  rows <-
    httr2::request(base_url = url_sudd("list.php")) |>
    httr2::req_method(method = "GET") |>
    httr2::req_url_query(mode = "allareas") |>
    httr2::req_retry(max_tries = 3L) |>
    httr2::req_perform() |>
    httr2::resp_body_string() |>
    xml2::read_html() |>
    rvest::html_elements(css = "main table tr") |>
    purrr::map(\(x) rvest::html_elements(x,
                                         css = "td"))
  
  col_1 <- rows |> purrr::map(\(x) magrittr::extract2(x, 1L))
  col_2 <- rows |> purrr::map(\(x) if (length(x) > 1L) x[[2L]] else xml2::as_xml_document(list()))
  col_3 <- rows |> purrr::map(\(x) if (length(x) > 2L) x[[3L]] else xml2::as_xml_document(list()))
  
  tibble::tibble(country_name_de = purrr::map_chr(col_1, rvest::html_text),
                 territory_name_de = purrr::map_chr(col_2, rvest::html_text),
                 filter_url = purrr::map_chr(col_2,
                                             \(x) {
                                               if (length(x) > 0L) {
                                                 x |>
                                                   rvest::html_element(css = "a") |>
                                                   rvest::html_attr(name = "href") |>
                                                   url_sudd()
                                               } else {
                                                 NA_character_
                                               }
                                             }),
                 n = purrr::map_chr(col_3, rvest::html_text)) |>
    dplyr::mutate(country_name_de = dplyr::if_else(stringr::str_detect(string = country_name_de,
                                                                       pattern = "^\\s*$"),
                                                   NA_character_,
                                                   country_name_de)) |>
    tidyr::fill(country_name_de,
                .direction = "down") |>
    dplyr::filter(!dplyr::if_all(c(territory_name_de, n),
                                 is.na))
}

#' List referendum titles from [sudd.ch](https://sudd.ch/)
#'
#' Lists [all referendum titles from sudd.ch](https://sudd.ch/list.php?mode=alltopics), together with their search URLs and number of occurrences.
#'
#' @inheritSection sudd_rfrnds About [sudd.ch](https://sudd.ch/)
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family sudd
#' @export
#'
#' @examples
#' rdb::list_sudd_titles() |> dplyr::filter(n > 1)
list_sudd_titles <- function() {
  
  rows <-
    httr2::request(base_url = url_sudd("list.php")) |>
    httr2::req_method(method = "GET") |>
    httr2::req_url_query(mode = "alltopics") |>
    httr2::req_retry(max_tries = 3L) |>
    httr2::req_perform() |>
    httr2::resp_body_string() |>
    xml2::read_html() |>
    rvest::html_elements(css = "main table tr") |>
    purrr::map(\(x) rvest::html_elements(x,
                                         css = "td"))
  
  col_1 <- rows |> purrr::map(\(x) magrittr::extract2(x, 1L))
  col_2 <- rows |> purrr::map(\(x) magrittr::extract2(x, 2L))
  
  tibble::tibble(title_de = col_1 |> purrr::map_chr(rvest::html_text),
                 filter_url = col_1 |> purrr::map_chr(\(x) {
                   x |>
                     rvest::html_element(css = "a") |>
                     rvest::html_attr(name = "href") |>
                     url_sudd()
                 }),
                 n = col_2 |> purrr::map_chr(rvest::html_text))
}

#' List referendum data from [sudd.ch](https://sudd.ch/)
#'
#' @description
#' Lists the referendum data from [sudd.ch](https://sudd.ch/) in various ways its [`list.php`](https://sudd.ch/list.php) endpoint allows. The output of this
#' function can be directly fed to [sudd_rfrnds()].
#'
#' @inheritSection sudd_rfrnds About [sudd.ch](https://sudd.ch/)
#' @param mode The listing mode. One of
#' - `"by_date"`: Lists [all referendums in the sudd.ch database **by `date`**](https://sudd.ch/list.php?mode=allrefs), together with their `id_sudd`,
#'   `country_code`, `territory_name_de` and `title_de`. Specifying the sorting order of the results via the `order` parameter is supported.
#' - `"by_mod_date"`: Lists [all referendums in the sudd.ch database **by `date_last_edited`**](https://sudd.ch/list.php?mode=moddate), together with their
#'   `id_sudd`, `country_code`, `territory_name_de`, `date` and `title_de`.
#' - `"filter"`: Allows to provide additional arguments (via the `filter` parameter) that limit the results accordingly. Specifying the sorting order of the
#'   results via the `order` parameter is supported.
#' - `"random"`: Lists the `id_sudd` of five randomly selected referendums, together with their `country_code`.
#' @param order The sorting order of the results. Only relevant if `mode` is either `"by_date"` or `"filter"`.
#' @param filter A list with valid filtering arguments. Only relevant if `mode = "filter"`. The supported filtering arguments include
#' - `territory_name_de`: A string that must be (partially) matched by the referendums' `territory_name_de`. Matching is case-insensitive and no [fuzzy
#'   matching](https://en.wikipedia.org/wiki/Approximate_string_matching) is supported.
#' - `title_de`: A string that must be (partially) matched by the referendums' `title_de`. Matching is case-insensitive and no [fuzzy
#'   matching](https://en.wikipedia.org/wiki/Approximate_string_matching) is supported.
#' - `year_min`: The lower year limit of the referendums' `date`. A positive integer.
#' - `year_max`: The upper year limit of the referendums' `date`. A positive integer.
#' @param use_cache `r pkgsnip::param_lbl("use_cache")`
#' @param max_cache_age `r pkgsnip::param_lbl("max_cache_age")`
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return A [tibble][tibble::tbl_df] containing at least an `id_sudd` column.
#' @family sudd
#' @export
#'
#' @examples
#' # list all referendums by modification date (takes a while)
#' \dontrun{
#' rdb::list_sudd_rfrnds(mode = "by_mod_date")}
#' 
#' # list all referendums whose title matches "AHV"
#' rdb::list_sudd_rfrnds(mode = "filter",
#'                       filter = list(title_de = "AHV"),
#'                       quiet = TRUE)
#' 
#' # get sudd.ch referendum data from all referendums in 2020
#' rdb::list_sudd_rfrnds(mode = "filter",
#'                       filter = list(year_min = 2020,
#'                                     year_max = 2020),
#'                       quiet = TRUE) |>
#'   rdb::sudd_rfrnds(quiet = TRUE)
list_sudd_rfrnds <- function(mode = c("by_date",
                                      "by_mod_date",
                                      "filter",
                                      "random"),
                             order = c("ascending",
                                       "descending"),
                             filter = list(territory_name_de = NULL,
                                           title_de = NULL,
                                           year_min = NULL,
                                           year_max = NULL),
                             use_cache = TRUE,
                             max_cache_age = "1 week",
                             quiet = FALSE) {
  # check args
  mode <- rlang::arg_match(mode)
  order <-
    rlang::arg_match(order) %>%
    dplyr::case_match(.x = .,
                      "ascending"  ~ "asc",
                      "descending" ~ "desc",
                      .default = .)
  checkmate::assert_flag(quiet)
  
  # do not cache `mode = "random"`
  if (mode == "random") use_cache <- FALSE
  
  pkgpins::with_cache(expr = {
    
    checkmate::assert_list(filter,
                           names = "unique")
    
    checkmate::assert_subset(names(filter),
                             choices = c("territory_name_de",
                                         "title_de",
                                         "year_min",
                                         "year_max"))
    
    checkmate::assert_string(filter$territory_name_de,
                             null.ok = TRUE)
    checkmate::assert_string(filter$title_de,
                             null.ok = TRUE)
    has_filter <-
      filter %>%
      purrr::map_lgl(is.null) %>%
      all() %>%
      magrittr::not()
    
    if (has_filter && mode != "filter") {
      cli::cli_alert_warning("{.arg filter} is ignored because {.arg mode} is set to {.val {mode}}.")
    }
    
    filter$year_min <- checkmate::assert_int(filter$year_min,
                                             lower = sudd_min_year,
                                             upper = sudd_max_year,
                                             null.ok = TRUE,
                                             coerce = TRUE)
    filter$year_max <- checkmate::assert_int(filter$year_max,
                                             lower = filter$year_min %||% sudd_min_year,
                                             upper = sudd_max_year,
                                             null.ok = TRUE,
                                             coerce = TRUE)
    
    is_year_missing <- purrr::map_lgl(c(filter$year_min, filter$year_max), is.null) %>% { any(.) && !all(.) }
    
    if (is_year_missing) {
      filter$year_min <- filter$year_min %||% sudd_min_year
      filter$year_max <- filter$year_max %||% sudd_max_year
    }
    
    if (mode == "filter" && all(purrr::map_lgl(filter, is.null))) {
      cli::cli_abort("At least one filtering argument must be provided in {.arg filter} when {.arg mode = \"filter\"}.")
    }
    
    names(filter) %<>% dplyr::case_match(.x = .,
                                         "territory_name_de" ~ "area",
                                         "title_de"          ~ "topic",
                                         "year_min"          ~ "first",
                                         "year_max"          ~ "last",
                                         .default = .)
    # assemble query params
    query <- c(list(mode = mode %>% dplyr::case_match(.x = .,
                                                      "by_date"     ~ "allrefs",
                                                      "by_mod_date" ~ "moddate",
                                                      .default = .))[mode != "filter"],
               list(sense = order)[mode %in% c("by_date", "filter")],
               filter[mode == "filter"])
    
    # retrieve and parse data
    url <- url_sudd("list.php")
    
    if (!quiet) {
      pal::cli_progress_step_quick(msg = "Fetching raw HTML data from {.url {url}}")
    }
    
    html <-
      httr2::request(base_url = url) |>
      httr2::req_method(method = "GET") |>
      httr2::req_url_query(!!!query) |>
      httr2::req_retry(max_tries = 3L) |>
      httr2::req_perform() |>
      httr2::resp_body_string() |>
      xml2::read_html()
    
    if (!quiet) {
      pal::cli_progress_step_quick(msg = "Parsing and tidying raw HTML data")
    }
    
    if (mode == "random") {
      
      result <-
        html %>%
        rvest::html_elements(css = "main ul li a") %>%
        rvest::html_attr(name = "href") %>%
        stringr::str_extract(pattern = "(?<=id=)[\\w\\d]+") %>%
        tibble::tibble(id_sudd = .)
      
    } else {
      
      rows <-
        html %>%
        rvest::html_element(css = "main table") %>%
        rvest::html_children() %>%
        purrr::map(rvest::html_elements,
                   css = "td")
      
      col_1 <- rows %>% purrr::map(magrittr::extract2, 1L)
      col_2 <- rows %>% purrr::map(magrittr::extract2, 2L)
      col_3 <- rows %>% purrr::map(magrittr::extract2, 3L)
      col_4 <- rows %>% purrr::map(magrittr::extract2, 4L)
      
      result <-
        tibble::tibble(id_sudd = purrr::map_chr(col_4,
                                                \(x) {
                                                  x %>%
                                                    rvest::html_element(css = "a") %>%
                                                    rvest::html_attr(name = "href") %>%
                                                    stringr::str_extract(pattern = "(?<=[\\?&]id=)[\\w\\d]+")
                                                }),
                       territory_name_de = purrr::map_chr(col_2, rvest::html_text),
                       !!!(col_3 %>% purrr::map_chr(rvest::html_text) %>% parse_sudd_date_de()),
                       title_de = purrr::map_chr(col_4, rvest::html_text)) %>%
        # add `date`
        dplyr::mutate(date = clock::date_build(year = year,
                                               month = month,
                                               day = day,
                                               invalid = "NA")) %>%
        dplyr::relocate(date,
                        .before = year)
      
      if (mode == "by_mod_date") {
        
        result %<>%
          tibble::add_column(date_last_edited =
                               col_1 %>%
                               purrr::map_chr(\(x) {
                                 x %>%
                                   rvest::html_element(css = "time") %>%
                                   rvest::html_attr(name = "datetime")
                               }) %>%
                               clock::date_parse()) %>%
          tidyr::fill(date_last_edited,
                      .direction = "down")
      }
    }
    
    result %>%
      # derive vars from `id_sudd`
      dplyr::bind_cols(.$id_sudd |>
                         purrr::map(parse_sudd_id) |>
                         purrr::list_rbind()) %>%
      dplyr::select(id_sudd,
                    starts_with("country_"),
                    is_former_country,
                    starts_with("subnational_entity_"),
                    everything())
  },
  pkg = this_pkg,
  from_fn = "list_sudd_rfrnds",
  mode,
  order,
  filter,
  use_cache = use_cache,
  max_cache_age = max_cache_age)
}

#' Get referendum data from [sudd.ch](https://sudd.ch/)
#'
#' Downloads referendum data from [sudd.ch](https://sudd.ch/).
#'
#' # About [sudd.ch](https://sudd.ch/)
#'
#' **sudd** stands for _**Su**chmaschine für **d**irekte **D**emokratie_ (German) and is operated by [Beat Müller](mailto:beat@sudd.ch). Its database content is
#' licensed under [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA
#' 4.0)](https://creativecommons.org/licenses/by-nc-sa/4.0/).
#'
#' @param ids_sudd The referendum identifiers assigned by [sudd.ch](https://sudd.ch/). Either as a character vector or a data frame containing a column
#'   `id_sudd`. `NA`s are ignored.
#' @param use_cache `r pkgsnip::param_lbl("use_cache")`
#' @param max_cache_age `r pkgsnip::param_lbl("max_cache_age")`
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `r pkgsnip::return_lbl("tibble")` The column names are aligned with those of [rfrnds()] as closely as possible.
#' @family sudd
#' @importFrom rlang :=
#' @export
#'
#' @examples
#' rdb::rfrnds() |>
#'   dplyr::filter(country_code == "AT") |>
#'   rdb::sudd_rfrnds()
sudd_rfrnds <- function(ids_sudd,
                        use_cache = TRUE,
                        max_cache_age = "1 week",
                        quiet = FALSE) {
  
  checkmate::assert_flag(quiet)
  
  if (purrr::pluck_depth(ids_sudd) > 1L) {
    
    if (!("id_sudd" %in% colnames(ids_sudd))) {
      cli::cli_abort(paste0("{.arg ids_sudd} must be either a character vector of valid sudd.ch referendum identifiers or a data frame with a column of such",
                            " named {.var id_sudd}."))
    }
    
    ids_sudd <- ids_sudd$id_sudd
  }
  
  ids_sudd <-
    checkmate::assert_character(ids_sudd,
                                all.missing = FALSE) %>%
    magrittr::extract(!is.na(.))
  
  pkgpins::with_cache(expr = {
    
    ids_sudd %>%
      purrr::map(.f = \(x) sudd_rfrnd(x),
                 .progress = if (quiet) FALSE else "Scraping referendum data from sudd.ch") %>%
      purrr::list_rbind() %>%
      # properly parse `date`
      dplyr::bind_cols(.$date |>
                         purrr::map(parse_sudd_date) |>
                         purrr::list_rbind()) %>%
      dplyr::mutate(date = clock::date_build(year = year,
                                             month = month,
                                             day = day,
                                             invalid = "NA")) %>%
      # add `id_sudd`
      tibble::add_column(id_sudd = ids_sudd,
                         .before = 1L) %>%
      # derive vars from `id_sudd`
      dplyr::bind_cols(ids_sudd |>
                         purrr::map(parse_sudd_id) |>
                         purrr::list_rbind()) %>%
      # reorder columns
      dplyr::relocate(id_sudd,
                      country_code,
                      country_name,
                      is_former_country,
                      subnational_entity_code,
                      territory_name_de,
                      any_of(c("territory_type_de",
                               "date",
                               "year",
                               "month",
                               "day",
                               "title_de",
                               "question_type_de",
                               "types",
                               "result_de",
                               "result_status_de",
                               "adoption_requirements_de",
                               "electorate_total",
                               "electorate_abroad",
                               "polling_cards",
                               "votes_total",
                               "votes_empty",
                               "votes_void",
                               "votes_invalid",
                               "votes_valid",
                               "votes_yes",
                               "votes_no")),
                      matches("^votes_(option_\\d+|(counter_)?proposal)(_(total|empty|void|invalid|valid|yes|no))?$"),
                      any_of("votes_option_none"),
                      matches("^$"),
                      any_of(c("subterritories",
                               "subterritories_yes",
                               "subterritories_no",
                               "files",
                               "remarks",
                               "sources",
                               "ids_sudd_simultaneous",
                               "date_last_edited")))
  },
  pkg = this_pkg,
  from_fn = "sudd_rfrnds",
  ids_sudd,
  use_cache = use_cache,
  max_cache_age = max_cache_age)
}

#' `r this_pkg` package configuration metadata
#'
#' A [tibble][tibble::tbl_df] with metadata of all possible `r this_pkg` package configuration options. See [pal::pkg_config_val()] for more information.
#'
#' @format `r pkgsnip::return_lbl("tibble_cols", cols = colnames(pkg_config))`
#' @export
#'
#' @examples
#' rdb::pkg_config
"pkg_config"
