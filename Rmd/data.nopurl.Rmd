---
editor_options:
  chunk_output_type: console
---

NOTES:

-   This file is *not* included in the [source package](https://r-pkgs.org/package-structure-state.html#source-package) because of the [`.nopurl` suffix in the
    filename](https://rpkg.dev/pkgpurl/reference/purl_rmd.html#-rmd-files-excluded-from-purling).

-   The chunks below have to be manually executed in order to regenerate the package data.

# Internal data

NOTES:

-   Although the datasets below are saved as ["internal data" in `R/sysdata.rda`](https://r-pkgs.org/data.html#data-sysdata), some of them are still exported
    and documented (in the main `.Rmd` document), something [not explicitly
    mentioned](https://coolbutuseless.github.io/2018/12/10/r-packages-internal-and-external-data/) in the book [R
    Packages](https://r-pkgs.org/data.html#data-data).

## `data_tags`

```{r, purl = FALSE}
data_tags <-
  # download file from private CCM Design repo
  pal::gh_text_file(owner = "ccmdesign",
                    name = "c2d-app",
                    rev = "master",
                    path = "ch.c2d/web/themes.json") %>%
  jsonlite::fromJSON(flatten = FALSE) %>%
  tibble::as_tibble() %>%
  # create tidy data version
  dplyr::rename(tag_tier_1 = name,
                tag_tier_2 = children) %>%
  tidyr::unnest_longer(col = tag_tier_2) %$%
  dplyr::bind_cols(tag_tier_1 = tag_tier_1,
                   tag_tier_2) %>%
  dplyr::rename(tag_tier_2 = name,
                tag_tier_3 = children) %>%
  # ensure consistent col subtypes
  dplyr::mutate(tag_tier_3 = tag_tier_3 %>% purrr::map(~ { if (is.list(.x)) character() else .x })) %>%
  tidyr::unnest_longer(col = tag_tier_3)
```

## `months_de`

```{r, purl = FALSE}
pal::assert_pkg("clock")

months_de <-
  1:12 %>%
  magrittr::set_names(clock::clock_labels_lookup("de")$month) %>%
  as.list()
```

## `var_lbls`

NOTES:

-   `var_lbls` is assigned here because when inlined, it somehow breaks `devtools::run_examples()` during pkg check ("C stack usage (...) is too close to the
    limit"); maybe too large fn stack? (modifying `pal::strip_md()` to minimize the fn stack was tried but didn't help)

```{r, purl = FALSE}
var_lbls <-
  data_codebook$variable_label %>%
  pal::strip_md() %>%
  as.list() %>%
  magrittr::set_names(value = data_codebook$variable_name)
```

## Write data

Save all the small data objects as a single internal file `R/sysdata.rda`. Note that when documenting them, they must be explicitly `@export`ed to be available
to package users.

```{r}
usethis::use_data(data_tags,
                  months_de,
                  var_lbls,
                  internal = TRUE,
                  overwrite = TRUE,
                  compress = "xz",
                  version = 3L)
```

# Exported data

NOTES:

-   When used internally, other than internal data, exported data must always be referred to by its explicit namespace, i.e. e.g. `c2d::data_codebook`.

## `data_codebook`

TODO:

-   Once the toml\* package is finished, use it instead to do the stuff below more generically.

NOTES:

-   In the following cases, a variable's prototype (`ptype`) has to be explicitly set in the raw `codebook.Rmd`:

    -   It's a floating point number. -\> Set `ptype = "numeric()"`.
    -   It's a complex number. -\> Set `ptype = "complex()"`.
    -   It's non-basic data type, i.e. a structure like a date. Set `ptype` to the proper value like `ptype = "vctrs::new_date()"`.

```{r}
data_codebook <- {
  
  pal::assert_pkg("assertr")
  codebook <- c2d:::read_toml("data-raw/c2d_codebook.toml")
  
  c(codebook$`01_main`$item,
    codebook$`02_institutional`$`01_status`$item,
    codebook$`02_institutional`$`02_trigger`$item,
    codebook$`02_institutional`$`03_object`$item,
    codebook$`02_institutional`$`04_other`$item) %>%
    purrr::map_dfr(~ tibble::tibble(variable_name = .x$variable_name %||% NA_character_,
                                    variable_label = .x$variable_label %||% NA_character_,
                                    is_multi_valued = .x$is_multi_valued %||% FALSE,
                                    is_nested = .x$is_nested %||% FALSE,
                                    applicability_constraint = .x$applicability_constraint %||% NA_character_,
                                    variable_values = list(.x$variable_values %||% character()),
                                    value_label_prefix = .x$value_label_prefix %||% NA_character_,
                                    value_labels = list(.x$value_labels %||% character()),
                                    value_label_suffix = .x$value_label_suffix %||% NA_character_,
                                    value_default = list(.x$value_default),
                                    value_scale = .x$value_scale %||% NA_character_,
                                    ptype =
                                      .x$ptype %>%
                                      purrr::when(!is.null(.) ~ eval(parse(text = .)),
                                                  ~ .) %>%
                                      list())) %>%
    # infer missing prototypes
    dplyr::mutate(ptype = purrr::pmap(.l = list(variable_name,
                                                is_multi_valued,
                                                is_nested,
                                                variable_values,
                                                value_labels,
                                                value_scale,
                                                ptype),
                                      .f = function(variable_name,
                                                    is_multi_valued,
                                                    is_nested,
                                                    variable_values,
                                                    value_labels,
                                                    value_scale,
                                                    ptype) {
                                        
                                        value_scale %>%
                                          purrr::when(!is.null(ptype) ~
                                                        ptype,
                                                      . == "undefined" || is_multi_valued || is_nested ~
                                                        list(),
                                                      . == "binary" && (length(value_labels) == 0L || all(is.logical(unlist(variable_values)))) ~
                                                        logical(),
                                                      . %in% c("nominal") && length(value_labels) == 0L ~
                                                        character(),
                                                      . %in% c("nominal", "binary", "ordinal_ascending", "ordinal_descending") ~
                                                        factor(levels = variable_values,
                                                               ordered = . %in% c("ordinal_ascending", "ordinal_descending")),
                                                      . %in% c("interval", "ratio") ~
                                                        integer())
                                      })) %>%
    # integrity checks
    assertr::assert(predicate = assertr::not_na,
                    variable_name,
                    variable_label,
                    value_scale,
                    is_multi_valued,
                    is_nested,
                    ptype)
}
```

## Write data

Save all the bigger data objects to separate files under `data/*.rda`. Note that when documenting them, they mustn't be explicitly `@export`ed since they're
already automatically exported and thus available to package users.

```{r}
usethis::use_data(data_codebook,
                  internal = FALSE,
                  overwrite = TRUE,
                  compress = "xz",
                  version = 3L)
```
