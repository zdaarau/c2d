---
editor_options:
  chunk_output_type: console
---

NOTES:

-   This file is *not* included in the [source package](https://r-pkgs.org/package-structure-state.html#source-package) because of the [`.nopurl` suffix in the
    filename](https://rpkg.dev/pkgpurl/reference/purl_rmd.html#-rmd-files-excluded-from-purling).

-   The chunks below have to be manually executed in order to regenerate the package data.

# Exported data

NOTES:

-   When used internally, other than internal data, exported data must always be referred to by its explicit namespace, i.e. e.g. `c2d::data_codebook`.

## Write data

Save all the bigger data objects to separate files under `data/*.rda`. Note that when documenting them, they mustn't be explicitly `@export`ed since they're
already automatically exported and thus available to package users.

```{r}
# usethis::use_data(,
#                   internal = FALSE,
#                   overwrite = TRUE,
#                   compress = "xz",
#                   version = 3L)
```

# Internal data

NOTES:

-   Although the datasets below are saved as ["internal data" in `R/sysdata.rda`](https://r-pkgs.org/data.html#data-sysdata), some of them are still exported
    and documented (in the main `.Rmd` document), something [not explicitly
    mentioned](https://coolbutuseless.github.io/2018/12/10/r-packages-internal-and-external-data/) in the book [R
    Packages](https://r-pkgs.org/data.html#data-data).

## `data_codebook`

TODO:

-   Once the toml\* package is finished, use it instead to do the stuff below more generically.

NOTES:

-   In the following cases, a variable's prototype (`ptype`) has to be explicitly set in the raw `codebook.Rmd`:

    -   It's a floating point number. -\> Set `ptype = "numeric()"`.
    -   It's a complex number. -\> Set `ptype = "complex()"`.
    -   It's non-basic data type, i.e. a structure like a date. Set `ptype` to the proper value like `ptype = "vctrs::new_date()"`.

```{r}
data_codebook <- {
  
  codebook <- c2d:::read_toml("data-raw/c2d_codebook.toml")
  
  c(codebook$`01_main`$item,
    codebook$`02_institutional`$`01_status`$item,
    codebook$`02_institutional`$`02_trigger`$item,
    codebook$`02_institutional`$`03_object`$item,
    codebook$`02_institutional`$`04_other`$item) %>%
    purrr::map_dfr(~ tibble::tibble(variable_name = .x$variable_name %||% NA_character_,
                                    variable_name_print = .x$variable_name_print %||% NA_character_,
                                    variable_label = .x$variable_label %||% NA_character_,
                                    is_multi_valued = .x$is_multi_valued %||% FALSE,
                                    is_nested = .x$is_nested %||% FALSE,
                                    applicability_constraint = .x$applicability_constraint %||% NA_character_,
                                    variable_values = list(.x$variable_values %||% character()),
                                    value_label_prefix = .x$value_label_prefix %||% NA_character_,
                                    value_labels = list(.x$value_labels %||% character()),
                                    value_label_suffix = .x$value_label_suffix %||% NA_character_,
                                    value_default = list(.x$value_default),
                                    value_scale = .x$value_scale %||% NA_character_,
                                    ptype =
                                      .x$ptype %>%
                                      purrr::when(!is.null(.) ~ eval(parse(text = .)),
                                                  ~ .) %>%
                                      list(),
                                    derived_from =
                                      .x$derived_from %>%
                                      purrr::when(is.null(.) ~ list(character()),
                                                  is.character(.) ~ list(.),
                                                  ~ .),
                                    gen_fn = .x$gen_fn %||% NA_character_,
                                    is_opt = .x$is_opt %||% FALSE)) %>%
    # infer missing prototypes
    dplyr::mutate(ptype = purrr::pmap(.l = list(variable_name,
                                                is_multi_valued,
                                                is_nested,
                                                variable_values,
                                                value_labels,
                                                value_scale,
                                                ptype),
                                      .f = function(variable_name,
                                                    is_multi_valued,
                                                    is_nested,
                                                    variable_values,
                                                    value_labels,
                                                    value_scale,
                                                    ptype) {
                                        
                                        value_scale %>%
                                          purrr::when(!is.null(ptype) ~
                                                        ptype,
                                                      . == "undefined" || is_multi_valued || is_nested ~
                                                        list(),
                                                      . == "binary" && (length(value_labels) == 0L || all(is.logical(unlist(variable_values)))) ~
                                                        logical(),
                                                      . %in% c("nominal") && length(value_labels) == 0L ~
                                                        character(),
                                                      . %in% c("nominal", "binary", "ordinal_ascending", "ordinal_descending") ~
                                                        factor(levels = variable_values,
                                                               ordered = . %in% c("ordinal_ascending", "ordinal_descending")),
                                                      . %in% c("interval", "ratio") ~
                                                        integer())
                                      })) %>%
    # integrity checks
    ## not NA
    assertr::assert(predicate = assertr::not_na,
                    variable_name,
                    variable_name_print,
                    variable_label,
                    value_scale,
                    is_multi_valued,
                    is_nested,
                    ptype,
                    is_opt) %>%
    ## not empty string
    assertr::assert(predicate = function(x) if (x == "") FALSE else TRUE,
                    variable_name,
                    variable_name_print,
                    variable_label,
                    value_scale)
}
```

## `data_iso_3166_1`

ISO 3166-1 data extended by unofficial information for countries which are not covered by the ISO standard yet.

```{r}
data_iso_3166_1 <-
  ISOcodes::ISO_3166_1 %>%
  tibble::as_tibble() %>%
  dplyr::add_row(Alpha_2 = "XK",
                 Alpha_3 = "XKS",
                 Numeric = NA_character_,
                 Name = "Kosovo, Republic of",
                 Official_name = "Republic of Kosovo",
                 Common_name = "Kosovo") %>%
  dplyr::mutate(name_short = Common_name %|% Name,
                name_long = Official_name %|% name_short) %>%
  dplyr::arrange(Alpha_2) %>%
  # ensure there are no duplicates
  assertr::assert(predicate = assertr::is_uniq,
                  Alpha_2,
                  Alpha_3)
```

## `data_iso_3166_3`

NOTES:

-   ISO monetizes the standards itselves as well as derived datasets like the [Country Codes Collection](https://www.iso.org/publication/PUB500001.html) instead
    of offering open data APIs! ðŸ¤¬ So most open-source projects including the R package source their ISO 3166 data from [Debian's `iso-codes`
    project](https://salsa.debian.org/iso-codes-team/iso-codes) which might lack behind official standard updates.

```{r}
data_iso_3166_3 <-
  ISOcodes::ISO_3166_3 %>%
  tibble::as_tibble() %>%
  dplyr::mutate(Alpha_2 = Alpha_4 %>% stringr::str_sub(end = 2L),
                Alpha_2_new = Alpha_4 %>% stringr::str_sub(start = 3L),
                # variation of `Alpha_2_new` that in case of multiple successor countries (*HH/*XX) holds the biggest one (1. population-, then 2. area-wise)
                # (main purpose is to be able to match with UN M49 area codes)
                Alpha_2_new_main =
                  Alpha_4 %>%
                  purrr::map_chr(~ {
                    if (stringr::str_detect(.x, "(HH|XX)$")) {
                      switch(.x,
                             ANHH = "CW",
                             CSHH = "CZ",
                             CSXX = "RS",
                             FQHH = "AQ",
                             GEHH = "KI",
                             NTHH = "IQ",
                             PCHH = "FM",
                             SUHH = "RU",
                             cli::abort(paste0("No ISO 3166-3 alpha-4 \"n-to-1\" ISO 3166-1 alpha-2 conversion rule defined for {.val .x}. Please update ",
                                               "{.var data_iso_3166_3} accordingly and run again.")))
                    } else {
                      stringr::str_sub(.x, start = 3L)
                    }
                  }),
                Date_withdrawn =
                  # fix withdrawn date of AN and YU
                  # TODO: remove this once pkg ISOcodes is recent enough to include
                  #       [iso-codes MR #28](https://salsa.debian.org/iso-codes-team/iso-codes/-/merge_requests/28)
                  dplyr::case_when(Alpha_4 == "ANHH" ~ "2010-12-15",
                                   Alpha_4 == "CSXX" ~ "2006-09-26",
                                   Alpha_4 == "YUCS" ~ "2003-07-23",
                                   TRUE ~ Date_withdrawn) %>%
                  purrr::map(~ {
                    if (nchar(.x) == 4L) {
                      clock::date_build(year = as.integer(.x))
                    } else {
                      clock::date_parse(x = .x,
                                        format = "%F")
                    }
                  }) %>%
                  purrr::reduce(c)) %>%
  dplyr::relocate(Alpha_2, Alpha_2_new, Alpha_2_new_main,
                  .after = Alpha_3) %>%
  # harmonize name style
  dplyr::mutate(name_short = dplyr::case_when(Alpha_4 == "BYAA" ~ "Byelorussian SSR",
                                              Alpha_4 == "FXFR" ~ "Metropolitan France",
                                              TRUE ~ stringr::str_extract(string = Name,
                                                                          pattern = "[^,]+")),
                name_long = dplyr::case_when(Alpha_4 == "BYAA" ~ "Byelorussian Soviet Socialist Republic",
                                             Alpha_4 == "CSHH" ~ Name,
                                             Alpha_4 == "SUHH" ~ "Union of Soviet Socialist Republics (USSR)",
                                             Alpha_4 == "YDYE" ~ "Democratic Yemen, People's Democratic Republic of Yemen",
                                             TRUE ~ stringr::str_replace(string = Name,
                                                                         pattern = "^([^,]+), (.+)$",
                                                                         replacement = "\\2 \\1"))) %>%
  dplyr::arrange(Alpha_4) %>%
  # ensure there are no duplicates
  assertr::assert(predicate = assertr::is_uniq,
                  Alpha_4)
```

## `country_codes_sudd_invalid`

```{r}
country_codes_sudd_invalid <- c("MB", "ZZ")

# ensure they aren't used in ISO 3166
if (any(country_codes_sudd_invalid %in% c(data_iso_3166_1$Alpha_2,
                                          data_iso_3166_3$Alpha_2,
                                          data_iso_3166_3$Alpha_2_new_main))) {
  
  cli::cli_abort("At least one of {.var country_codes_sudd_invalid} is used in regular ISO 3166 alpha-2 codes. Please investigate.")
}
```

## `data_topics`

```{r}
data_topics <-
  # download file from private CCM Design repo
  pal::gh_text_file(owner = "ccmdesign",
                    name = "c2d-app",
                    rev = "master",
                    path = "ch.c2d/web/themes.json") %>%
  jsonlite::fromJSON(flatten = FALSE) %>%
  tibble::as_tibble() %>%
  # create tidy data version
  dplyr::rename(topic_tier_1 = name,
                topic_tier_2 = children) %>%
  tidyr::unnest(cols = topic_tier_2,
                keep_empty = TRUE) %>%
  dplyr::rename(topic_tier_2 = name,
                topic_tier_3 = children) %>%
  # ensure consistent col subtypes
  dplyr::mutate(topic_tier_3 = topic_tier_3 %>% purrr::map(~ { if (is.list(.x)) character() else .x })) %>%
  tidyr::unnest(cols = topic_tier_3,
                keep_empty = TRUE)
```

## `months_de`

```{r}
pal::assert_pkg("clock")

months_de <-
  1:12 %>%
  magrittr::set_names(clock::clock_labels_lookup("de")$month) %>%
  as.list()
```

## `topics_tier_#_`

Only for performance-reasons.

```{r}
topics_tier_1_ <- c2d::topics(tiers = 1L)
topics_tier_2_ <- c2d::topics(tiers = 2L)
topics_tier_3_ <- c2d::topics(tiers = 3L)
```

## `un_regions`

NOTES:

-   Antarctica (AQ) is not part of any UN regions (i.e. it's [directly below
    *World*](https://en.wikipedia.org/wiki/List_of_countries_by_United_Nations_geoscheme)).

```{r}
# compile `country_code` <-> `un_country_code` dict
codes <-
  data_iso_3166_1 %>%
  # temporarily add ISO 3166-1 alpha-3 codes for matching with M49 codes
  dplyr::select(country_code = Alpha_2,
                Alpha_3) %>%
  # temporarily add M49 code for matching with actual UN region codes and names
  dplyr::left_join(y = ISOcodes::UN_M.49_Countries %>% dplyr::select(un_country_code = Code,
                                                                     Alpha_3 = ISO_Alpha_3),
                   by = "Alpha_3") %>%
  dplyr::select(-Alpha_3) %>%
  # manual corrections
  dplyr::mutate(
    # assign M49 code of
    # - China to Taiwan, cf. https://en.wikipedia.org/wiki/United_Nations_geoscheme_for_Asia#Note_on_Taiwan
    # - Serbia to Kosovo, cf. https://en.wikipedia.org/wiki/XK_(user_assigned_code)#Potential_assignment_of_an_official_ISO_3166-1_code_for_Kosovo
    un_country_code = dplyr::case_when(country_code == "TW" ~ "156",
                                       country_code == "XK" ~ "688",
                                       TRUE ~ un_country_code)
  )
# extract UN regions of the 3 different tiers
un_regions_tier_1 <-
  ISOcodes::UN_M.49_Regions %>%
  dplyr::filter(Type == "Region" & Parent == "001") %>%
  tidyr::separate_rows(Children,
                       sep = ", ") %>%
  dplyr::transmute(un_region_tier_1_name = Name,
                   un_region_tier_1_code = Code,
                   children_tier_1 = Children)
un_regions_tier_2 <-
  ISOcodes::UN_M.49_Regions %>%
  dplyr::filter(Type == "Region" & Parent %in% un_regions_tier_1$un_region_tier_1_code) %>%
  tidyr::separate_rows(Children,
                       sep = ", ") %>%
  dplyr::transmute(un_region_tier_2_name = Name,
                   un_region_tier_2_code = Code,
                   children_tier_2 = Children)
un_regions_tier_3 <-
  ISOcodes::UN_M.49_Regions %>%
  dplyr::filter(Type == "Region" & Parent %in% un_regions_tier_2$un_region_tier_2_code) %>%
  tidyr::separate_rows(Children,
                       sep = ", ") %>%
  dplyr::transmute(un_region_tier_3_name = Name,
                   un_region_tier_3_code = Code,
                   children_tier_3 = Children)

# combine UN regions of different tiers into single dataset and add `country_code`
un_regions <-
  un_regions_tier_1 %>%
  dplyr::full_join(y = un_regions_tier_2,
                   by = c("children_tier_1" = "un_region_tier_2_code")) %>%
  dplyr::full_join(y = un_regions_tier_3,
                   by = c("children_tier_2" = "un_region_tier_3_code")) %>%
  dplyr::mutate(un_region_tier_2_code = dplyr::if_else(is.na(un_region_tier_2_name),
                                                       NA_character_,
                                                       children_tier_1),
                un_region_tier_3_code = dplyr::if_else(is.na(un_region_tier_3_name),
                                                       NA_character_,
                                                       children_tier_2),
                un_country_code = dplyr::if_else(is.na(children_tier_3),
                                                 children_tier_2,
                                                 children_tier_3)) %>%
  dplyr::select(un_country_code,
                starts_with("un_region_tier_1_"),
                starts_with("un_region_tier_2_"),
                starts_with("un_region_tier_3_")) %>%
  dplyr::left_join(y = codes,
                   by = "un_country_code") %>%
  dplyr::relocate(country_code) %>%
  # remove rows without `country_code` (Sark)
  dplyr::filter(!is.na(country_code)) %>%
  # ensure there are no NAs left
  assertr::assert(predicate = assertr::not_na,
                  un_country_code) %>%
  # convert UN cols to type fct
  dplyr::mutate(
    # tier-1 name lvls are ordered alphabetically
    un_region_tier_1_name = factor(x = un_region_tier_1_name,
                                   levels = sort(unique(un_region_tier_1_name))),
    # tier-2 name lvls are ordered by tier-1 name, then ~ clockwise cardinal direction (except for Oceania)
    un_region_tier_2_name = factor(x = un_region_tier_2_name,
                                   levels = c("Northern Africa",
                                              "Sub-Saharan Africa",
                                              "Northern America",
                                              "Latin America and the Caribbean",
                                              "Central Asia",
                                              "Eastern Asia",
                                              "South-eastern Asia",
                                              "Southern Asia",
                                              "Western Asia",
                                              "Northern Europe",
                                              "Eastern Europe",
                                              "Southern Europe",
                                              "Western Europe",
                                              "Australia and New Zealand",
                                              "Melanesia",
                                              "Micronesia",
                                              "Polynesia")),
    # tier-3 name lvls are ordered by tier-2 name, then ~ clockwise cardinal direction (except for Latin America and the Caribbean)
    un_region_tier_3_name = factor(x = un_region_tier_3_name,
                                   levels = c("Middle Africa",
                                              "Eastern Africa",
                                              "Southern Africa",
                                              "Western Africa",
                                              "South America",
                                              "Central America",
                                              "Caribbean",
                                              "Channel Islands")),
    # code lvls are simply in ascending order
    un_country_code = factor(x = un_country_code,
                             levels = sort(unique(ISOcodes::UN_M.49_Countries$Code))),
    dplyr::across(.cols = matches("un_region_tier_\\d+_code"),
                  .fns = ~ factor(x = .x,
                                  levels = sort(unique(.x))))
  )
```

## `var_lbls`

Only for performance-reasons.

```{r}
var_lbls <-
  data_codebook$variable_label %>%
  pal::strip_md() %>%
  as.list() %>%
  magrittr::set_names(value = data_codebook$variable_name)
```

## `val_set`

```{r}
val_set                        <- list()
val_set$country_code           <- c(data_iso_3166_1$Alpha_2,
                                    data_iso_3166_3$Alpha_4)
val_set$country_code_long      <- sort(unique(c(data_iso_3166_1$Alpha_3,
                                                data_iso_3166_3$Alpha_3)))
val_set$country_code_continual <- sort(unique(data_iso_3166_1$Alpha_2,
                                              data_iso_3166_3$Alpha_2_new_main))
val_set$country_name           <- sort(unique(c(data_iso_3166_1$name_short,
                                                data_iso_3166_3$name_short)))
val_set$country_name_long      <- sort(unique(c(data_iso_3166_1$name_long,
                                                data_iso_3166_3$name_long)))
```

## Write data

Save all the small data objects as a single internal file `R/sysdata.rda`. Note that when documenting them, they must be explicitly `@export`ed to be available
to package users.

```{r}
usethis::use_data(country_codes_sudd_invalid,
                  data_codebook,
                  data_iso_3166_1,
                  data_iso_3166_3,
                  data_topics,
                  months_de,
                  topics_tier_1_,
                  topics_tier_2_,
                  topics_tier_3_,
                  un_regions,
                  var_lbls,
                  val_set,
                  internal = TRUE,
                  overwrite = TRUE,
                  compress = "xz",
                  version = 3L)
```
