---
editor_options:
  chunk_output_type: console
---

NOTES:

-   This file is *not* included in the [source package](https://r-pkgs.org/package-structure-state.html#source-package) because of the [`.nopurl` suffix in the
    filename](https://rpkg.dev/pkgpurl/reference/purl_rmd.html#-rmd-files-excluded-from-purling).

-   The chunks below have to be manually executed in order to regenerate the package data.

# Internal data

NOTES:

-   Although the datasets below are saved as ["internal data" in `R/sysdata.rda`](https://r-pkgs.org/data.html#data-sysdata), some of them are still exported
    and documented (in the main `.Rmd` document), something [not explicitly
    mentioned](https://coolbutuseless.github.io/2018/12/10/r-packages-internal-and-external-data/) in the book [R
    Packages](https://r-pkgs.org/data.html#data-data).

## `data_tags`

```{r, purl = FALSE}
data_tags <-
  # download file from private CCM Design repo
  pal::gh_text_file(owner = "ccmdesign",
                    name = "c2d-app",
                    rev = "master",
                    path = "ch.c2d/web/themes.json") %>%
  jsonlite::fromJSON(flatten = FALSE) %>%
  tibble::as_tibble() %>%
  # create tidy data version
  dplyr::rename(tag_tier_1 = name,
                tag_tier_2 = children) %>%
  tidyr::unnest(cols = tag_tier_2,
                keep_empty = TRUE) %>%
  dplyr::rename(tag_tier_2 = name,
                tag_tier_3 = children) %>%
  # ensure consistent col subtypes
  dplyr::mutate(tag_tier_3 = tag_tier_3 %>% purrr::map(~ { if (is.list(.x)) character() else .x })) %>%
  tidyr::unnest(cols = tag_tier_3,
                keep_empty = TRUE)
```

## `months_de`

```{r, purl = FALSE}
pal::assert_pkg("clock")

months_de <-
  1:12 %>%
  magrittr::set_names(clock::clock_labels_lookup("de")$month) %>%
  as.list()
```

## `tags_tier_#_`

Only for performance-reasons.

```{r}
tags_tier_1_ <- c2d::tags(tiers = 1L)
tags_tier_2_ <- c2d::tags(tiers = 2L)
tags_tier_3_ <- c2d::tags(tiers = 3L)
```

## `un_regions`

```{r}
# compile `country_code` <-> `un_code` dict
codes <-
  ISOcodes::ISO_3166_1 %>%
  # temporarily add ISO 3166-1 alpha-3 codes for matching with M49 codes
  dplyr::select(country_code = Alpha_2,
                Alpha_3) %>%
  # temporarily add M49 code for matching with actual UN region codes and names
  dplyr::left_join(y = ISOcodes::UN_M.49_Countries %>% dplyr::select(un_code = Code,
                                                                     Alpha_3 = ISO_Alpha_3),
                   by = "Alpha_3") %>%
  dplyr::select(-Alpha_3) %>%
  # manually assign China's M49 code to Taiwan, cf. https://en.wikipedia.org/wiki/United_Nations_geoscheme_for_Asia#Note_on_Taiwan
  dplyr::mutate(un_code = dplyr::if_else(country_code == "TW",
                                         "156",
                                         un_code))

# extract UN regions of the 3 different tiers
un_regions_tier_1 <-
  ISOcodes::UN_M.49_Regions %>%
  dplyr::filter(Type == "Region" & Parent == "001") %>%
  tidyr::separate_rows(Children,
                       sep = ", ") %>%
  dplyr::transmute(un_region_tier_1_name = Name,
                   un_region_tier_1_code = Code,
                   children_tier_1 = Children)
un_regions_tier_2 <-
  ISOcodes::UN_M.49_Regions %>%
  dplyr::filter(Type == "Region" & Parent %in% un_regions_tier_1$un_region_tier_1_code) %>%
  tidyr::separate_rows(Children,
                       sep = ", ") %>%
  dplyr::transmute(un_region_tier_2_name = Name,
                   un_region_tier_2_code = Code,
                   children_tier_2 = Children)
un_regions_tier_3 <-
  ISOcodes::UN_M.49_Regions %>%
  dplyr::filter(Type == "Region" & Parent %in% un_regions_tier_2$un_region_tier_2_code) %>%
  tidyr::separate_rows(Children,
                       sep = ", ") %>%
  dplyr::transmute(un_region_tier_3_name = Name,
                   un_region_tier_3_code = Code,
                   children_tier_3 = Children)

# combine UN regions of different tiers into single dataset and add `country_code`
un_regions <-
  un_regions_tier_1 %>%
  dplyr::full_join(y = un_regions_tier_2,
                   by = c("children_tier_1" = "un_region_tier_2_code")) %>%
  dplyr::full_join(y = un_regions_tier_3,
                   by = c("children_tier_2" = "un_region_tier_3_code")) %>%
  dplyr::mutate(un_region_tier_2_code = dplyr::if_else(is.na(un_region_tier_2_name),
                                                       NA_character_,
                                                       children_tier_1),
                un_region_tier_3_code = dplyr::if_else(is.na(un_region_tier_3_name),
                                                       NA_character_,
                                                       children_tier_2),
                un_code = dplyr::if_else(is.na(children_tier_3),
                                         children_tier_2,
                                         children_tier_3)) %>%
  dplyr::select(un_code,
                starts_with("un_region_tier_1_"),
                starts_with("un_region_tier_2_"),
                starts_with("un_region_tier_3_")) %>%
  dplyr::left_join(y = codes,
                   by = "un_code") %>%
  dplyr::relocate(country_code) %>%
  # ensure there are no NAs left
  assertr::assert(predicate = assertr::not_na,
                  un_code)
```

## `var_lbls`

NOTES:

-   `var_lbls` is assigned here because when inlined, it somehow breaks `devtools::run_examples()` during pkg check ("C stack usage (...) is too close to the
    limit"); maybe too large fn stack? (modifying `pal::strip_md()` to minimize the fn stack was tried but didn't help)

```{r, purl = FALSE}
var_lbls <-
  data_codebook$variable_label %>%
  pal::strip_md() %>%
  as.list() %>%
  magrittr::set_names(value = data_codebook$variable_name)
```

## Write data

Save all the small data objects as a single internal file `R/sysdata.rda`. Note that when documenting them, they must be explicitly `@export`ed to be available
to package users.

```{r}
usethis::use_data(data_tags,
                  months_de,
                  tags_tier_1_,
                  tags_tier_2_,
                  tags_tier_3_,
                  un_regions,
                  var_lbls,
                  internal = TRUE,
                  overwrite = TRUE,
                  compress = "xz",
                  version = 3L)
```

# Exported data

NOTES:

-   When used internally, other than internal data, exported data must always be referred to by its explicit namespace, i.e. e.g. `c2d::data_codebook`.

## `data_codebook`

TODO:

-   Once the toml\* package is finished, use it instead to do the stuff below more generically.

NOTES:

-   In the following cases, a variable's prototype (`ptype`) has to be explicitly set in the raw `codebook.Rmd`:

    -   It's a floating point number. -\> Set `ptype = "numeric()"`.
    -   It's a complex number. -\> Set `ptype = "complex()"`.
    -   It's non-basic data type, i.e. a structure like a date. Set `ptype` to the proper value like `ptype = "vctrs::new_date()"`.

```{r}
data_codebook <- {
  
  pal::assert_pkg("assertr")
  codebook <- c2d:::read_toml("data-raw/c2d_codebook.toml")
  
  c(codebook$`01_main`$item,
    codebook$`02_institutional`$`01_status`$item,
    codebook$`02_institutional`$`02_trigger`$item,
    codebook$`02_institutional`$`03_object`$item,
    codebook$`02_institutional`$`04_other`$item) %>%
    purrr::map_dfr(~ tibble::tibble(variable_name = .x$variable_name %||% NA_character_,
                                    variable_label = .x$variable_label %||% NA_character_,
                                    is_multi_valued = .x$is_multi_valued %||% FALSE,
                                    is_nested = .x$is_nested %||% FALSE,
                                    applicability_constraint = .x$applicability_constraint %||% NA_character_,
                                    variable_values = list(.x$variable_values %||% character()),
                                    value_label_prefix = .x$value_label_prefix %||% NA_character_,
                                    value_labels = list(.x$value_labels %||% character()),
                                    value_label_suffix = .x$value_label_suffix %||% NA_character_,
                                    value_default = list(.x$value_default),
                                    value_scale = .x$value_scale %||% NA_character_,
                                    ptype =
                                      .x$ptype %>%
                                      purrr::when(!is.null(.) ~ eval(parse(text = .)),
                                                  ~ .) %>%
                                      list())) %>%
    # infer missing prototypes
    dplyr::mutate(ptype = purrr::pmap(.l = list(variable_name,
                                                is_multi_valued,
                                                is_nested,
                                                variable_values,
                                                value_labels,
                                                value_scale,
                                                ptype),
                                      .f = function(variable_name,
                                                    is_multi_valued,
                                                    is_nested,
                                                    variable_values,
                                                    value_labels,
                                                    value_scale,
                                                    ptype) {
                                        
                                        value_scale %>%
                                          purrr::when(!is.null(ptype) ~
                                                        ptype,
                                                      . == "undefined" || is_multi_valued || is_nested ~
                                                        list(),
                                                      . == "binary" && (length(value_labels) == 0L || all(is.logical(unlist(variable_values)))) ~
                                                        logical(),
                                                      . %in% c("nominal") && length(value_labels) == 0L ~
                                                        character(),
                                                      . %in% c("nominal", "binary", "ordinal_ascending", "ordinal_descending") ~
                                                        factor(levels = variable_values,
                                                               ordered = . %in% c("ordinal_ascending", "ordinal_descending")),
                                                      . %in% c("interval", "ratio") ~
                                                        integer())
                                      })) %>%
    # integrity checks
    assertr::assert(predicate = assertr::not_na,
                    variable_name,
                    variable_label,
                    value_scale,
                    is_multi_valued,
                    is_nested,
                    ptype)
}
```

## Write data

Save all the bigger data objects to separate files under `data/*.rda`. Note that when documenting them, they mustn't be explicitly `@export`ed since they're
already automatically exported and thus available to package users.

```{r}
usethis::use_data(data_codebook,
                  internal = FALSE,
                  overwrite = TRUE,
                  compress = "xz",
                  version = 3L)
```
