---
editor_options:
  chunk_output_type: console
---

# NOTES

The C2D Database offers a [privately documented](https://github.com/ccmdesign/c2d-app/blob/master/docs/services.md) API available under `services.c2d.ch` with
the following HTTP GET "endpoints":

-   `referendums`: get data on multiple referendums

    It supports the following URL parameters:

    -   `mode`: the operation mode; one of `stream`, `count` or `search`
    -   `term` the search term used for `mode=search`; note that only the `title$en` field will be searched
    -   `format`: the data format to be returned when `mode=stream`; one of `json` or `csv`
    -   `filter`: a valid [JSON query filter document](https://docs.mongodb.com/manual/core/document/#query-filter-documents) to customize queries in the
        underlying MongoDB collection; needs to be Base64-encoded; there are various [query
        operators](https://docs.mongodb.com/manual/reference/operator/query/) available to build complex queries

    The following values are used to denote empty values in the returned data:

    -   In integer fields:

        -   `-1L` (means "information not available or nonexistent", an *explicit* `NA`)
        -   `-2L` ([means "information not given"](https://github.com/ccmdesign/c2d-app/issues/13#issuecomment-802466615), an *implicit* `NA`)

    -   In character fields:

        -   `""`
        -   `"-1"`
        -   `"unknown"` (only for certain fields)
        -   `"-2"`
        -   `"not provided"` (only for certain fields)

    -   In array fields:

        -   (Named) `list()`

-   `referendums/ID`: get data on an individual referendum

    `ID` stands for the referendum's unique identifier `oid` (which corresponds to the column `id` in the data returned by the `referendums()` function of this
    package).

-   The returned JSON data has between 22 and 26 fields. Fields that are not always present include:

    -   `archive`
    -   `canton`
    -   `municipality`
    -   `number`

-   `referendums/stats`: get the number of referendums

    It accepts the following URL parameter:

    -   `filter`: a valid [JSON query filter document](https://docs.mongodb.com/manual/core/document/#query-filter-documents) to customize queries in the
        underlying MongoDB collection; needs to be Base64-encoded; there are various [query
        operators](https://docs.mongodb.com/manual/reference/operator/query/) available to build complex queries

-   `s3_objects`: retrieve a file stored on the C2D [Amazon S3 bucket](https://en.wikipedia.org/wiki/Amazon_S3#Design)

    It's not a real REST API endpoint but rather a URL redirection (I guess). It expects an object key to be appended like this:

    ``` http
    GET https://services.c2d.ch/s3_objects/referendum_5f859fafd1291cc3961f1bc2_0002.pdf
    ```

-   `states`: get the first 10 subnational entities that match the query

    It accepts the following URL parameters to customize the query:

    -   `country`: limits the results to a specific country code
    -   `term`: limits the result to subnational entities matching this search term

-   `health`: check API status

# INTERNAL

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

Cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 # tidyselect fns
                                 "all_of",
                                 "any_of",
                                 "everything",
                                 "matches",
                                 "starts_with",
                                 "where",
                                 # other
                                 "Alpha_2",
                                 "applicability_constraint",
                                 "archive",
                                 "committee_name",
                                 "content-disposition",
                                 "country_code",
                                 "country_code_historical",
                                 "country_name",
                                 "country_name_de",
                                 "date_last_edited",
                                 "date_time_created",
                                 "date_time_last_active",
                                 "date_time_last_edited",
                                 "Date_withdrawn",
                                 "day",
                                 "electorate_abroad",
                                 "electorate_total",
                                 "files",
                                 "id",
                                 "id_official",
                                 "id_sudd",
                                 "id_sudd_prefix",
                                 "is_draft",
                                 "is_past_jurisdiction",
                                 "items",
                                 "level",
                                 "month",
                                 "municipality",
                                 "n",
                                 "Name",
                                 "number",
                                 "question",
                                 "question_en",
                                 "remarks",
                                 "result",
                                 "rowid",
                                 "sources",
                                 "subnational_entity_name",
                                 "sudd_prefix",
                                 "tag_tier_1",
                                 "tag_tier_2",
                                 "tag_tier_3",
                                 "tags_tier_1",
                                 "tags_tier_2",
                                 "tags_tier_3",
                                 "territory_name_de",
                                 "territory_name_de_short",
                                 "title_de",
                                 "title_fr",
                                 "title_en",
                                 "type",
                                 "url_sudd",
                                 "url_swissvotes",
                                 "value_labels",
                                 "variable_name",
                                 "variable_values",
                                 "votes",
                                 "votes_per_subterritory",
                                 "year"))
```

## Package load/unload

```{r}
.onLoad <- function(libname, pkgname) {
  
  rlang::with_handlers(.expr = pkgpins::clear_cache(board = pkgpins::board(pkg = pkgname),
                                                    max_age = getOption(paste0(pkgname, ".max_cache_lifespan"),
                                                                        default = "30 days")),
                       error = ~ cli::cli_alert_warning(text = "Failed to clear pkgpins cache on load of {.pkg pkgname}. Error message: {.x$message}"))
}
```

## Create custom CSS file for package vignettes

Assembles a custom CSS file by combining [rmarkdown's default lightweight vignette
stylesheet](https://github.com/rstudio/rmarkdown/blob/master/inst/rmarkdown/templates/html_vignette/resources/vignette.css) with our custom pkgdown CSS.

The R code chunk below is *not* included in the [source package](https://r-pkgs.org/package-structure-state.html#source-package) (`purl = FALSE`) and thus has
to be manually executed in order to regenerate the custom CSS file.

```{r, purl = FALSE}
pal::assert_pkg("brio")

fs::path_package("rmarkdown/templates/html_vignette/resources/vignette.css",
                 package = "rmarkdown") %>%
  brio::read_file() %>%
  paste0("/* BEGIN custom CSS */\n",
         brio::read_file("pkgdown/extra.css"),
         "/* END custom CSS */\n") %>%
  brio::write_file(path = "vignettes/custom.css")
```

## Functions

### `assemble_query_filter`

NOTE: `date` is not stored as an actual [MongoDB `Date` type](https://docs.mongodb.com/manual/reference/bson-types/#std-label-document-bson-type-date) in the
database, so we can't filter on it. It has [been requested](https://github.com/ccmdesign/c2d-app/issues/20) to change this upstream.

```{r}
#' Assemble MongoDB query filter document
#'
#' @param country_code The `country_code`(s) to be included. A character vector.
#' @param subnational_entity_name The `subnational_entity_name`(s) to be included. A character vector.
#' @param municipality The `municipality`(s) to be included. A character vector.
#' @param level The `level`(s) to be included. A character vector.
#' @param type The `type`(s) to be included. A character vector.
#' @param date The `date`(s) to be included. A character vector.
#' @param is_draft `TRUE` means to include only referendum entries with _draft_ status, `FALSE` to include only normal entries. Set to `NULL` in order to
#'   include both draft and normal entries.
#' @param date_time_created_min The minimum `date_time_created` to be included. A [date][base::Date], a [datetime][base::DateTimeClasses], or something
#'   coercible to (like `"2006-01-02"` or `"2006-01-02T15:04:05"`).
#' @param date_time_created_max The maximum `date_time_created` to be included. A [date][base::Date], a [datetime][base::DateTimeClasses], or something
#'   coercible to (like `"2006-01-02"` or `"2006-01-02T15:04:05"`).
#' @param query_filter A valid [MongoDB JSON query filter document](https://docs.mongodb.com/manual/core/document/#query-filter-documents) which allows for
#' maximum control over what data is included. This takes precedence over all of the above listed parameters, i.e. if `query_filter` is provided, the
#' parameters `r formals(assemble_query_filter) %>% names() %>% setdiff(c("query_filter", "base64_encode")) %>% pal::prose_ls(wrap = "\x60")` are ignored.
#' @param base64_encode Whether or not to [Base64](https://en.wikipedia.org/wiki/Base64)-encode the resulting query filter document. Note that the
#'   `query_filter` argument provided to other functions of this package must be Base64-encoded.
#'
#' @return A character scalar containing a valid [MongoDB JSON query filter document](https://docs.mongodb.com/manual/core/document/#query-filter-documents),
#'   [Base64](https://en.wikipedia.org/wiki/Base64)-encoded if `base64_encode = TRUE`.
#' @keywords internal
assemble_query_filter <- function(country_code = NULL,
                                  subnational_entity_name = NULL,
                                  municipality = NULL,
                                  level = NULL,
                                  type = NULL,
                                  date = NULL,
                                  is_draft = NULL,
                                  date_time_created_min = NULL,
                                  date_time_created_max = NULL,
                                  query_filter = NULL,
                                  base64_encode = TRUE) {
  
  # assemble JSON query filter document if `query_filter` is not provided
  if (is.null(checkmate::assert_string(query_filter, null.ok = TRUE))) {
    
    query_filter <-
      list(country_code =
             country_code %>%
             purrr::map_chr(checkmate::assert_choice,
                            choices = ISOcodes::ISO_3166_1$Alpha_2,
                            null.ok = TRUE,
                            .var.name = "country_code") %>%
             query_filter_in(),
           canton = query_filter_in(checkmate::assert_character(subnational_entity_name,
                                                                any.missing = FALSE,
                                                                null.ok = TRUE)),
           municipality = query_filter_in(checkmate::assert_character(municipality,
                                                                      any.missing = FALSE,
                                                                      null.ok = TRUE)),
           level =
             level %>%
             purrr::map_chr(checkmate::assert_choice,
                            choices = v_vals("level"),
                            null.ok = TRUE,
                            .var.name = "level") %>%
             query_filter_in(),
           institution =
             type %>%
             purrr::map_chr(checkmate::assert_choice,
                            choices = v_vals("type"),
                            null.ok = TRUE,
                            .var.name = "type") %>%
             purrr::when(length(.) == 0L ~ .,
                         ~ dplyr::recode("citizens' assembly" = "citizen assembly") %>% stringr::str_to_sentence()) %>%
             query_filter_in(),
           date = query_filter_in(checkmate::assert_character(as.character(date),
                                                              pattern = "\\d{4}-\\d{2}-\\d{2}",
                                                              any.missing = FALSE,
                                                              null.ok = TRUE,
                                                              .var.name = "date")),
           draft = checkmate::assert_flag(is_draft,
                                          null.ok = TRUE),
           created_on = query_filter_date(min = checkmate::assert_posixct(lubridate::as_datetime(date_time_created_min),
                                                                          any.missing = FALSE,
                                                                          .var.name = "date_time_created_min"),
                                          max = checkmate::assert_posixct(lubridate::as_datetime(date_time_created_max),
                                                                          any.missing = FALSE,
                                                                          .var.name = "date_time_created_max"))) %>%
      # remove `NULL` elements
      purrr::compact() %>%
      # convert to base64-encoded JSON
      jsonlite::toJSON(POSIXt = "ISO8601",
                       auto_unbox = TRUE,
                       digits = NA,
                       pretty = FALSE)
  }
  
  query_filter %>% purrr::when(checkmate::assert_flag(base64_encode) ~ jsonlite::base64_enc(.),
                               ~ .)
}
```

### `assert_cols_valid`

```{r}
assert_cols_valid <- function(data,
                              action = cli::cli_abort,
                              cli_progress_id = NULL) {
  
  non_na_col_names <- c("id",
                        "country_code",
                        "date",
                        "level")
  na_col_names <-
    data %>%
    dplyr::select(any_of(non_na_col_names)) %>%
    dplyr::filter(dplyr::if_any(.fns = is.na)) %>%
    dplyr::select(where(~ any(is.na(.x)))) %>%
    colnames()
  n_na_col_names <- length(na_col_names)
  
  if (n_na_col_names) {
    cli::cli_progress_done(id = cli_progress_id,
                           result = "failed")
    action("Detected {n_na_col_names} column{?s} in {.arg data} that contain forbidden {.val NA}s: {.var {na_col_names}}")
  }
  
  ## check `id`
  if ("id" %in% colnames(data) && anyDuplicated(data$id)) {
    cli::cli_progress_done(id = cli_progress_id,
                           result = "failed")
    action("Duplicated {.var id}s detected. IDs must be unique.")
  }
  
  ## check `date`
  if ("date" %in% colnames(data)) {
    
    check <- checkmate::check_date(data$date,
                                   any.missing = FALSE)
    if (!isTRUE(check)) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action("Failed to validate {.var data$date}. {check}")
    }
  }
  
  ## check `level`
  if ("level" %in% colnames(data)) {
    
    check <- checkmate::check_subset(as.character(data$level),
                                     choices = v_vals("level"))
    
    if (!isTRUE(check)) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action("Failed to validate {.var data$level}. {check}")
    }
  }

  ## check `country_code`
  if ("country_code" %in% colnames(data)) {
    
    check <- checkmate::check_subset(as.character(data$country_code),
                                     choices = ISOcodes::ISO_3166_1$Alpha_2)
    
    if (!isTRUE(check)) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action("Failed to validate {.var data$country_code}. {check}")
    }
    
    ## ensure `position_government` is present when `country_code = "CH" & level = "national"`
    if ((data %>%
         dplyr::filter(country_code == "CH" & level == "national") %>%
         nrow() %>%
         magrittr::is_greater_than(0L))
        && !("position_government" %in% colnames(data))) {
      
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action(paste0("Referendums with {.code country_code = \"CH\" & level = \"national\"} present in {.arg data} but column {.var ",
                    "position_government} is missing."))
    }
  }
  
  ## check `subnational_entity_name`
  ## TODO: check `subnational_entity_code` instead once it's available
  if (any(data[["level"]] != "national")) {
    
    if (!("subnational_entity_name" %in% colnames(data))) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action(paste0("Referendums of {.var level} below {.val national} present in {.arg data} but column {.var subnational_entity_name} is missing."))
    }
    
    ix_missing_subnational_entities <-
      data %>%
      tibble::rowid_to_column() %>%
      dplyr::filter(level != "national" & is.na(subnational_entity_name)) %$%
      rowid
    
    n_missing_subnational_entities <- length(ix_missing_subnational_entities)
    
    if (n_missing_subnational_entities) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action(paste0("{n_missing_subnational_entities} row{?s} in {.arg data} {?is/are} missing a {.var subnational_entity_name}. Affected {?is/are} ",
                    "the row{?s} with ind{?ex/ices} {.val {ix_missing_subnational_entities}}."))
    }
  }
  
  ## check `municipality`
  if (any(data[["level"]] == "local")) {
    
    if (!("municipality" %in% colnames(data))) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action(paste0("Referendums of {.var level = \"local\"} present in {.arg data} but column {.var municipality} is missing."))
    }
    
    ix_missing_municipalities <-
      data %>%
      tibble::rowid_to_column() %>%
      dplyr::filter(level == "local" & is.na(municipality)) %$%
      rowid
    
    n_missing_municipalities <- length(ix_missing_municipalities)
    
    if (n_missing_municipalities) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action(paste0("{n_missing_municipalities} row{?s} in {.arg data} {?is/are} missing a {.var municipality}. Affected {?is/are} the row{?s} with ",
                    "ind{?ex/ices} {.val {ix_missing_subnational_entities}}."))
    }
  }
  
  ## check variables that are only meant to be set for Swiss national referendums
  ## TODO: Remove this as soon as [issue #52](https://github.com/ccmdesign/c2d-app/issues/52) is resolved.
  ### `votes_per_subterritory`
  if (all(c("votes_per_subterritory", "level", "country_code") %in% colnames(data))) {
    
    ix_illegal_votes_per_subterritory <-
      data %>%
      tibble::rowid_to_column() %>%
      dplyr::filter((level != "national" | country_code != "CH") & !(votes_per_subterritory %>% purrr::map_lgl(is.null))) %$%
      rowid
    
    n_illegal_votes_per_subterritory <- length(ix_illegal_votes_per_subterritory)
    
    if (n_illegal_votes_per_subterritory) {
      cli::cli_progress_done(id = cli_progress_id,
                             result = "failed")
      action(paste0("{n_illegal_votes_per_subterritory} row{?s} in {.arg data} {?has/have} a {.var position_government} set although they are not Swiss ",
                    "national referendums. Affected {?is/are} the row{?s} with ind{?ex/ices} {.val {ix_illegal_votes_per_subterritory}}."))
    }
  }
  ### non-list vx
  c("lower_house_yes",
    "lower_house_no",
    "lower_house_abstentions",
    "upper_house_yes",
    "upper_house_no",
    "upper_house_abstentions",
    "position_government") %>%
    purrr::walk(function(v_name) {
      
      if (all(c(v_name, "level", "country_code") %in% colnames(data))) {
        
        ix_illegal <-
          data %>%
          tibble::rowid_to_column() %>%
          dplyr::filter((level != "national" | country_code != "CH") & !is.na(!!as.symbol(v_name))) %$%
          rowid
        
        n_illegal <- length(ix_illegal)
        
        if (n_illegal) {
          cli::cli_progress_done(id = cli_progress_id,
                                 result = "failed")
          action(paste0("{n_illegal} row{?s} in {.arg data} {?has/have} a {.var {v_name}} set although {cli::qty(n_illegal)}{?it is not a/they are not} Swiss",
                        " national referendum{?s}. Affected {?is/are} the row{?s} with ind{?ex/ices} {.val {ix_illegal}}."))
        }
      }
    })
  
  invisible(data)
}
```

### `auth_session`

```{r}
#' Authenticate a user session for the [C2D API](https://github.com/ccmdesign/c2d-app/blob/master/docs/services.md#1-reflexive-routes)
#'
#' Creates a new user session token if necessary. The token is stored in the R option `c2d.user_session_tokens`, a [tibble][tibble::tbl_df] with the columns
#' `email`, `token` and `date_time_last_active`.
#' 
#' By default, the `email` and `password` are read from the first element of the R option `c2d.credentials` (a named character vector where names are e-mail
#' addresses and values are passwords).
#'
#' User session tokens expire automatically after 15 days of inactivity.
#'
#' @param email The e-mail address of the user for which a session should be created. A character scalar.
#' @param password The password of the user for which a session should be created. A character scalar.
#'
#' @return The user session token as a character scalar, invisibly.
#' @keywords internal
auth_session <- function(email = names(getOption("c2d.credentials")[1L]),
                         password = getOption("c2d.credentials")[1L]) {
  
  # get existing tokens or initialize empty tibble
  tokens <-
    getOption("c2d.user_session_tokens") %>%
    purrr::when(all(c("email", "token", "date_time_last_active") %in% colnames(.)) ~ .,
                ~ tibble::tibble(email = character(),
                                 token = character(),
                                 date_time_last_active = lubridate::as_datetime(NULL)))
  
  # extract latest token
  token <- tokens %>% dplyr::filter(email == !!email)
  if (nrow(token)) token %<>% dplyr::filter(date_time_last_active == max(date_time_last_active))
  
  # ensure token is not expired (checked if older than 14 days), else set to `NULL`
  if (nrow(token) &&
      checkmate::test_string(token$token, min.chars = 1L) &&
      ((token$date_time_last_active > (lubridate::now() - lubridate::duration(14L, units = "days"))) || !is_session_expired(token$token))) {
    
    token <- token$token
    
  } else {
    
    token <- NULL
  }
  
  # create new session if necessary
  if (is.null(token)) {
    
    pal::cli_process_expr(msg = "Authenticating new user session",
                          expr = {
                            
                            token <-
                              httr::RETRY(verb = "POST",
                                          url = "https://services.c2d.ch/users/session",
                                          times = 5L,
                                          encode = "json",
                                          body = list(email = checkmate::assert_string(email),
                                                      password = checkmate::assert_string(password))) %>%
                              # ensure we actually got a JSON response
                              pal::assert_mime_type(mime_type = "application/json",
                                                    msg_suffix = mime_error_suffix) %>%
                              # parse response
                              httr::content(as = "parsed") %$%
                              token
                          })
  }
  
  # update `c2d.user_session_tokens` option
  options(c2d.user_session_tokens =
            tokens %>%
            dplyr::filter(token != !!token) %>%
            tibble::add_row(email = email,
                            token = token,
                            date_time_last_active = lubridate::now()))
  # return token
  invisible(token)
}
```

### `complete_country_vx`

NOTE that this fn replaces the `country_code` column.

```{r}
complete_country_vx <- function(data) {
  
  data %>%
    dplyr::select(-c(country_code,
                     country_name,
                     any_of("country_code_historical"))) %>%
    tibble::add_column(purrr::map2_dfr(data$country_code,
                                       data$date,
                                       derive_country_vx))
}
```

### `country_code_to_name`

```{r}
country_code_to_name <- function(country_code,
                                 country_code_historical = NA_character_) {
  
  purrr::map2_chr(.x = country_code,
                  .y = country_code_historical,
                  .f = ~ {
                    
                    if (is.na(.y)) {
                      
                      result <-
                        ISOcodes::ISO_3166_1 %>%
                        dplyr::filter(Alpha_2 == !!.x) %$%
                        Name
                      
                    } else {
                      
                      result <-
                        ISOcodes::ISO_3166_3 %>%
                        dplyr::filter(Alpha_4 == !!.y) %$%
                        Name
                    }
                    
                    if (length(result) == 0L) {
                      result <- NA_character_
                    }
                    
                    result
                  })
}
```

### `derive_country_vx`

```{r}
derive_country_vx <- function(country_code,
                              date) {
  
  pal::assert_pkg("assertr")
  country_code %<>% as.character()
  
  data_historical <-
    data_iso_3166_3 %>%
    dplyr::filter(Alpha_2 == !!country_code & !!date <= Date_withdrawn) %>%
    purrr::when(
      # reduce to nearest country_code retirement
      nrow(.) > 1L ~
        dplyr::filter(.data = .,
                      Date_withdrawn == min(Date_withdrawn)) %>%
        assertr::verify(nrow(.) == 1L),
      
      # handle obsolete country_codes
      !(country_code %in% ISOcodes::ISO_3166_1$Alpha_2) ~
        data_iso_3166_3 %>%
        dplyr::filter(Alpha_2 == !!country_code) %>%
        dplyr::filter(dplyr::row_number() == which.min(date - Date_withdrawn)) %>%
        assertr::verify(nrow(.) < 2L),
      
      ~ .
    )

  country_code_proper <- dplyr::if_else(nrow(data_historical) > 0L,
                                        NA_character_,
                                        country_code)
  
  country_code_historical <- data_historical$Alpha_4 %>% purrr::when(length(.) == 0L ~ NA_character_,
                                                                     ~ .)
  
  list(country_code = country_code_proper,
       country_name = country_code_to_name(country_code = country_code_proper,
                                           country_code_historical = country_code_historical),
       country_code_historical = country_code_historical)
}
```

### `drop_disabled_vx`

```{r}
drop_disabled_vx <- function(data,
                             to_drop) {
  
  to_drop_present <- intersect(to_drop, colnames(data))
  n_to_drop_present <- length(to_drop_present)
  
  if (n_to_drop_present) {
    
    cli::cli_alert_warning(paste0("The {cli::qty(n_to_drop_present)} column{?s} {.var {to_drop_present}} in {.arg data} are ignored because setting/altering ",
                                  "the corresponding values is disabled."))
    
    data %<>% dplyr::select(-any_of(to_drop))
  }
  
  data
}
```

### `flatten_array_as_is`

A helper function to apply to list elements before converting the list to JSON using `jsonlite::toJSON(auto_unbox = TRUE)`.

```{r}
flatten_array_as_is <- function(x) {
  
  unlist(x) %>% purrr::when(is.null(.) ~ .,
                            ~ I(.))
}
```

### `httr_config`

[Before 2021-05-25](https://github.com/ccmdesign/c2d-app/issues/10), the C2D API server didn't provide the [intermediate *R3*
certificate](https://crt.sh/?q=+730c1bdcd85f57ce5dc0bba733e5f1ba5a925b2a771d640a26f7a454224dad3b) (issued by Let's Encrypt) and since [curl doesn't support
*Authority Information Access* yet](https://github.com/curl/curl/issues/2793) to automatically discover it, we had to manually specify it. Thus, the certificate
was shipped with this package (found under `certs/3479778542.crt`). Because this isn't needed anymore, the cert as well as the code chunk below (`purl = FALSE`)
are ignored from package builds but kept in case they are needed again at some point in the future.

```{r, purl = FALSE}
httr_config <- function() {
  
  httr::config(cainfo = fs::path_package(package = this_pkg,
                                         "certs", "3479778542.crt"))
}
```

### `is_session_expired`

```{r}
is_session_expired <- function(token) {
  
  response <-
    httr::RETRY(verb = "GET",
                url = "https://services.c2d.ch/users/profile",
                config = httr::add_headers(Authorization = paste("Bearer", token),
                                           Connection = "keep-alive"),
                times = 5L) %>%
    # ensure we actually got a JSON response
    pal::assert_mime_type(mime_type = "application/json",
                          msg_suffix = mime_error_suffix) %>%
    # parse response
    httr::content(as = "parsed")
  
  is.null(response[["profile"]])
}
```

### `lower_non_abbrs`

```{r}
#' Lowercase non-abbreviations
#'
#' @param x A character vector.
#'
#' @return A character vector of the same lenght as `x`.
#' @keywords internal
lower_non_abbrs <- function(x) {
  
  x %>%
    stringr::str_split(pattern = "\\s") %>%
    purrr::map_chr(~ .x %>%
                     dplyr::if_else(stringr::str_detect(string = .,
                                                        pattern = "^[^[:lower:]]+$"),
                                    .,
                                    stringr::str_to_lower(.)) %>%
                     paste0(collapse = " "))
}
```

### `read_toml`

```{r}
#' Read in a TOML file
#'
#' @param path Path to the TOML file. A [path][fs::fs_path] or something coercible to.
#'
#' @return The TOML file's content as a [strict list][xfun::strict_list].
#' @keywords internal
read_toml <- function(path) {
  
  pal::assert_pkg("RcppTOML")
  pal::assert_pkg("xfun")
  
  path %>%
    purrr::when(length(.) > 0L ~ RcppTOML::parseTOML(input = .,
                                                     escape = FALSE),
                ~ NULL) %>%
    xfun::as_strict_list()
}
```

### `rename_from_list`

NOTE that an alternative approach reducing `names_list` to the ones actually present and then `dplyr::rename(!!!names_list_present)` is very inefficient.

```{r}
rename_from_list <- function(x,
                             names_list) {
  if (length(x)) {
    
    names_new <- names(x) %>% dplyr::recode(!!!names_list)
    
    x %>% magrittr::set_names(names_new)
    
  } else {
    x
  }
}
```

### `tidy_date`

```{r}
tidy_date <- function(x) {
  
  x %>%
    unlist(use.names = FALSE) %>%
    magrittr::divide_by(1000L) %>%
    lubridate::as_datetime()
}
```

### `tidy_referendums`

TODO:

-   Upstream renamings and recodings as far as possible and subsequently remove them from `tidy_referendums()`, `assemble_query_filter()` and all other affected
    places.

```{r}
#' Tidy "raw" C2D API referendum data
#'
#' Converts the "raw" MongoDB data from the C2D API to the tidied [referendums()] schema.
#'
#' You can reverse this function again using [untidy_referendums()].
#'
#' @param data The MongoDB data as a list (converted from the JSON returned by the C2D API using [jsonlite::fromJSON()]).
#' @param tidy Whether or not to tidy the referendum data, i.e. apply various data cleansing tasks and add additional variables. If `FALSE`, the raw MongoDB
#'   referendum data will only be modified just enough to be able to return it as a [tibble][tibble::tbl_df]. Note that untidy data doesn't conform to the 
#'   [codebook][data_codebook] (i.a. different variable names).
#'
#' @return `r pkgsnip::return_label("data")`
#' @keywords internal
tidy_referendums <- function(data,
                             tidy = TRUE) {
  
  checkmate::assert_flag(tidy)
  
  data %<>%
    # unnest columns and ensure list type for multi-value columns
    # NOTE that despite of the [speed-up in v1.1.4](https://github.com/tidyverse/tidyr/releases/tag/v1.1.4), `tidyr::unnest()` is still much slower than our
    # custom function
    purrr::map(.f = function(l,
                             category_names = names(l$categories),
                             context_names = names(l$context),
                             title_langs = names(l$title)) {
      
      for (name in category_names) {
        l[[paste0("categories.", name)]] <- l$categories[[name]]
      }
      
      for (name in context_names) {
        l[[paste0("context.", name)]] <- l$context[[name]]
      }
      
      for (lang in title_langs) {
        l[[paste0("title.", lang)]] <- l$title[[lang]]
      }
      
      l$categories <- NULL
      l$context <- NULL
      l$title <- NULL
      
      for (name in c("tags",
                     "categories.action",
                     "categories.special_topics",
                     "categories.excluded_topics")) {
        l[[name]] %<>% purrr::flatten_chr() %>% list()
      }
      
      for (name in c("archive",
                     "files",
                     "context.votes_per_canton")) {
        l[[name]] %<>% list()
      }
      
      l
    }) %>%
    # provisionally replace empty (but actually mandatory) fields with NAs
    purrr::modify_depth(.depth = 1L,
                        .f = ~ {
                          if (!length(.x$date_time_last_edited)) .x$date_time_last_edited <- lubridate::as_datetime(0)[NA]
                          if (!length(.x$is_past_jurisdiction)) .x$is_past_jurisdiction <- NA
                          .x
                        }) %>%
    # convert to tibble
    purrr::map_dfr(tibble::as_tibble_row)
  
  # tidy data
  if (nrow(data)) {
    
    if (tidy) {
      
      data %<>%
        # rename variables (mind that the MongoDB-based API doesn't demand a fixed schema)
        rename_from_list(names_list = v_names) %>%
        # add vars which aren't always included
        dplyr::full_join(y = tibble::tibble(subnational_entity_name = character(),
                                            municipality = character()),
                         by = intersect(c("subnational_entity_name",
                                          "municipality"),
                                        colnames(.))) %>%
        
        # create/recode variables
        dplyr::mutate(
          # ensure all supposed to floating-point numbers are actually of type double (JSON API is not reliable in this respect)
          dplyr::across(any_of(c("subterritories_no",
                                 "subterritories_yes",
                                 "date_time_created")),
                        as.double),
          
          # use explicit NA values
          dplyr::across(where(is.integer),
                        ~ dplyr::if_else(.x %in% c(-1L, -2L),
                                         NA_integer_,
                                         .x)),
          dplyr::across(where(is.character),
                        ~ dplyr::if_else(.x %in% c("", "-1", "-2"),
                                         NA_character_,
                                         .x)),
          dplyr::across(any_of(c("subterritories_yes", "subterritories_no")),
                        ~ dplyr::if_else(.x %in% c(-1.0, -2.0),
                                         NA_real_,
                                         .x)),
          result = result %>% dplyr::if_else(. %in% c("Unknown", "Not provided"),
                                             NA_character_,
                                             .),
          
          # convert all values to lowercase
          ## vectors
          dplyr::across(c(result,
                          type,
                          any_of(c("inst_legal_basis_type",
                                   "inst_object_type",
                                   "inst_object_legal_level",
                                   "inst_object_revision_extent",
                                   "inst_trigger_type",
                                   "inst_trigger_actor_level",
                                   "inst_trigger_time_limit",
                                   "inst_quorum_approval",
                                   "inst_precondition_decision"))),
                        stringr::str_to_lower),
          ## lists
          dplyr::across(.cols = any_of(c("inst_object_revision_modes",
                                         "inst_topics_only",
                                         "inst_topics_excluded")),
                        .fns = purrr::map,
                        .f = stringr::str_to_lower),
          
          # convert non-abbreviations only to lowercase
          dplyr::across(.cols = any_of(c("inst_object_author",
                                         "inst_trigger_actor",
                                         "inst_precondition_actor")),
                        .fns = purrr::map_chr,
                        .f = lower_non_abbrs),
          
          # specific recodings
          ## binary (dummies)
          dplyr::across(any_of("position_government"),
                        ~ dplyr::case_when(.x == "Acceptance" ~ "yes",
                                           .x == "Rejection" ~ "no",
                                           TRUE ~ NA_character_)),
          dplyr::across(any_of("inst_has_urgent_legal_basis"),
                        ~ dplyr::case_when(.x == "Urgent" ~ TRUE,
                                           .x == "Normal" ~ FALSE,
                                           TRUE ~ NA)),
          dplyr::across(any_of("inst_is_binding"),
                        ~ dplyr::case_when(.x == "Binding" ~ TRUE,
                                           .x == "Non-binding" ~ FALSE,
                                           TRUE ~ NA)),
          dplyr::across(any_of("inst_is_counter_proposal"),
                        ~ dplyr::case_when(.x == "Yes" ~ TRUE,
                                           .x == "No" ~ FALSE,
                                           TRUE ~ NA)),
          dplyr::across(any_of("inst_is_assembly"),
                        ~ dplyr::case_when(.x == "Assembly" ~ TRUE,
                                           .x == "Ballot" ~ FALSE,
                                           TRUE ~ NA)),
          dplyr::across(any_of("inst_has_precondition"),
                        ~ dplyr::case_when(.x == "Exists" ~ TRUE,
                                           .x == "Does not exist" ~ FALSE,
                                           TRUE ~ NA)),
          ## nominal
          ### flatten `id`
          id = purrr::flatten_chr(id),
          ### complement `id_official` by old `number` when it doesn't signify an `id_sudd` (the latter consists of a two-letter country code plus a 6-digit number)
          id_official =
            number %>%
            dplyr::if_else(is.na(id_official) & stringr::str_detect(string = .,
                                                                    pattern = "^\\D"),
                           NA_character_,
                           .),
          id_sudd =
            number %>%
            dplyr::if_else(is.na(id_sudd) & stringr::str_detect(string = .,
                                                                pattern = "^\\D"),
                           .,
                           NA_character_) %>%
            # everything beyond the 8th char seems to be manually added -> strip!
            stringr::str_sub(end = 8L),
          
          ### split `tags` into separate per-tier vars
          tags_tier_1 = tags %>% purrr::map(infer_tags,
                                            tier = 1L),
          tags_tier_2 = tags %>% purrr::map(infer_tags,
                                            tier = 2L),
          tags_tier_3 = tags %>% purrr::map(~ .x[.x %in% tags(tiers = 3L)]),
          ### various cleanups
          type = type %>% dplyr::recode("citizen assembly" = "citizens' assembly",
                                        "not provided" = NA_character_),
          dplyr::across(any_of(c("inst_trigger_actor",
                                 "inst_object_author")),
                        dplyr::recode,
                        "institution" = "other institution"),
          dplyr::across(any_of("inst_object_type"),
                        dplyr::recode,
                        "legal text (ausformulierter vorschlag)" = "legal text (formulated proposal)",
                        "legal text (allg. anregung)" = "legal text (general proposal)"),
          dplyr::across(any_of("inst_object_revision_divisibility"),
                        dplyr::recode,
                        "Whole text only" = "as a whole",
                        "Splitting up possible" = "split up",
                        "Variants possible" = "as variants",
                        "Variants / splitting up possible" = "both split up and as variants"),
          dplyr::across(.cols = any_of("inst_topics_only"),
                        .fns = purrr::map,
                        .f = dplyr::recode,
                        "infrastructural act" = "infrastructural acts",
                        "competence shift" = "competence shifts",
                        "financial act" = "financial acts",
                        "financial act (expenses)" = "financial acts (expenses)",
                        "financial act (taxes)" = "financial acts (taxes)",
                        "financial act (obligations)" = "financial acts (obligations)",
                        "total revision of the constitution" = "total revisions of the constitution"),
          dplyr::across(.cols = any_of("inst_topics_excluded"),
                        .fns = purrr::map,
                        .f = dplyr::recode,
                        "budget" = "budgets",
                        "parliamentary competence" = "everything within parliamentary competence"),
          dplyr::across(any_of("inst_quorum_turnout"),
                        stringr::str_replace_all,
                        pattern = c("^(\\s+)?>(\\s+)?" = ">\u202f",
                                    "(\\s+)?%(\\s+)?$" = "\u202f%")),
          ## ordinal
          ## interval
          date = lubridate::as_date(date),
          date_time_created = tidy_date(date_time_created),
          ## undefined
          files = files %>% purrr::map(~ .x %>% purrr::map(~ .x %>%
                                                             # unnest and restore `date`
                                                             purrr::assign_in(where = "date",
                                                                              value = tidy_date(.$date)) %>%
                                                             # change subvariable names
                                                             rename_from_list(names_list = sub_v_names$files))),
          votes_per_subterritory = votes_per_subterritory,
          
          # variable creations
          url_sudd = dplyr::if_else(!is.na(id_sudd),
                                    paste0("https://sudd.ch/event.php?id=", id_sudd),
                                    NA_character_),
          url_swissvotes = dplyr::if_else(country_code == "CH" & level == "national" & !is.na(id_official),
                                          paste0("https://swissvotes.ch/vote/", id_official),
                                          NA_character_)
        ) %>%
        
        # remove obsolete vars
        dplyr::select(-c(number,
                         tags)) %>%
        
        # convert to (ordered) factor where appropriate
        ## based on codebook
        dplyr::mutate(dplyr::across(.fns = ~ {
          
          metadata <- data_codebook %>% dplyr::filter(variable_name == dplyr::cur_column())
          if (nrow(metadata) != 1L) cli::cli_abort("Missing codebook metadata! Please debug")
          
          if (!is.logical(.x) && !is.null(metadata$variable_values[[1L]])) {
            
            lvls <- purrr::flatten_chr(metadata$variable_values)
            is_ordered <- metadata$value_scale %in% c("ordinal_ascending", "ordinal_descending")
            
            if (is.list(.x)) {
              .x %>% purrr::map(.f = factor,
                                levels = lvls,
                                ordered = is_ordered)
            } else {
              factor(x = .x,
                     levels = lvls,
                     ordered = is_ordered)
            }
          } else .x
        })) %>%
        ## nominal vars without variable_values in codebook
        dplyr::mutate(dplyr::across(.cols = country_code,
                                    .fns = factor,
                                    levels = ISOcodes::ISO_3166_1$Alpha_2,
                                    ordered = FALSE),
                      dplyr::across(.cols = c(country_name,
                                              subnational_entity_name,
                                              municipality),
                                    .fns = as.factor)) %>%
        # add variable labels
        labelled::set_variable_labels(.labels = var_lbls,
                                      .strict = FALSE) %>%
        # reorder columns
        dplyr::relocate(id,
                        id_official,
                        id_sudd,
                        country_code,
                        country_code_historical,
                        country_name,
                        subnational_entity_name,
                        municipality,
                        level,
                        is_past_jurisdiction,
                        date,
                        title_de,
                        title_fr,
                        title_en,
                        question,
                        question_en,
                        committee_name,
                        result,
                        any_of("subterritories_yes"),
                        any_of("subterritories_no"),
                        any_of("electorate_total"),
                        any_of("electorate_abroad"),
                        any_of("votes_yes"),
                        any_of("votes_no"),
                        any_of("votes_empty"),
                        any_of("votes_invalid"),
                        any_of("votes_per_subterritory"),
                        any_of("lower_house_yes"),
                        any_of("lower_house_no"),
                        any_of("lower_house_abstentions"),
                        any_of("upper_house_yes"),
                        any_of("upper_house_no"),
                        any_of("upper_house_abstentions"),
                        any_of("position_government"),
                        tags_tier_1,
                        tags_tier_2,
                        tags_tier_3,
                        remarks,
                        files,
                        url_sudd,
                        url_swissvotes,
                        sources,
                        is_draft,
                        date_time_created,
                        date_time_last_edited,
                        archive,
                        type,
                        any_of("inst_legal_basis_type"),
                        any_of("inst_has_urgent_legal_basis"),
                        any_of("inst_is_binding"),
                        any_of("inst_is_counter_proposal"),
                        any_of("inst_is_assembly"),
                        any_of("inst_trigger_type"),
                        any_of("inst_trigger_actor"),
                        any_of("inst_trigger_actor_level"),
                        any_of("inst_trigger_threshold"),
                        any_of("inst_trigger_time_limit"),
                        any_of("inst_object_type"),
                        any_of("inst_object_author"),
                        any_of("inst_object_legal_level"),
                        any_of("inst_object_revision_extent"),
                        any_of("inst_object_revision_modes"),
                        any_of("inst_object_revision_divisibility"),
                        any_of("inst_topics_only"),
                        any_of("inst_topics_excluded"),
                        any_of("inst_quorum_turnout"),
                        any_of("inst_quorum_approval"),
                        any_of("inst_has_precondition"),
                        any_of("inst_precondition_actor"),
                        any_of("inst_precondition_decision"))
      
      # correct known errors
      # TODO: correct this upstream using `edit_referendums()` once [issue #29](https://github.com/ccmdesign/c2d-app/issues/29) is resolved
      ## wrong `id_sudd`
      data$id_sudd[data$id == "5bbbffa992a21351232e50e7"] <- "az022009"
      data$id_sudd[data$id == "5bbbfb7c92a21351232e4185"] <- "bs022002"
      data$id_sudd[data$id == "5bbbe5fb92a21351232dfbfb"] <- "mg011972"
      data$id_sudd[data$id == "5bbbe7fd92a21351232e0243"] <- "mg011975"
      data$id_sudd[data$id == "5bbbf37c92a21351232e2721"] <- "mg011992"
      data$id_sudd[data$id == "5bbbf60a92a21351232e2f4d"] <- "mg011995"
      data$id_sudd[data$id == "5bbbf7e892a21351232e3757"] <- "mg011998"
      data$id_sudd[data$id == "5bbbfe8692a21351232e4c99"] <- "mg012007"
      data$id_sudd[data$id == "5bbc009e92a21351232e5389"] <- "mg012010"
      data$id_sudd[data$id == "5bbbe99c92a21351232e0949"] <- "mh011979"
      data$id_sudd[data$id %in% c("5bbbf45592a21351232e291f", "5bbbf45592a21351232e291d")] <- "mw011993"
      data$id_sudd[data$id == "5bbbf50592a21351232e2ca9"] <- "ec031994"
      data$id_sudd[data$id == "5bbbfe7b92a21351232e4c0f"] <- "ec022006"
      data$id_sudd[data$id == "5bbbe2d592a21351232df4f7"] <- "gq011968"
      data$id_sudd[data$id == "5bbbf92f92a21351232e3a11"] <- "gt011999"
      data$id_sudd[data$id == "5bbbf92f92a21351232e3a17"] <- "gt021999"
      data$id_sudd[data$id == "5bbbf92f92a21351232e3a15"] <- "gt031999"
      data$id_sudd[data$id == "5bbbe29492a21351232de33d"] <- "li021930"
      data$id_sudd[data$id == "5bbbf50592a21351232e2c9d"] <- "lt031994"
      data$id_sudd[data$id == "5bbbeaee92a21351232e0ca5"] <- "nf011979"
      data$id_sudd[data$id == "5bbbe73592a21351232dffc1"] <- "tv011974"
      data$id_sudd[data$id == "5bbbe27f92a21351232ddd93"] <- "uy011917"
      data$id_sudd[data$id == "5bbbf2e692a21351232e23cb"] <- "ye011991"
      ## missing `id_sudd`
      data$id_sudd[data$id == "5caf179361af8403c235ddc9"] <- "si012015"
    }
  }
  
  # convert nested list cols to tibbles
  data %>% dplyr::mutate(dplyr::across(any_of(c("context.votes_per_canton",
                                                "files",
                                                "votes_per_subterritory")),
                                       ~ .x %>% purrr::map(~ { if (length(.x)) .x %>% purrr::map_dfr(tibble::as_tibble) else NULL })),
                         dplyr::across(any_of("archive"),
                                       ~ .x %>% purrr::map(~ { if (length(.x)) tibble::as_tibble(.x) else NULL })))
}
```

### `untidy_date`

```{r}
untidy_date <- function(x) {
  
  as.numeric(x) %>%
    magrittr::multiply_by(1000) %>%
    as.list() %>%
    magrittr::set_names(rep("$date",
                            times = length(.)))
}
```

### `untidy_referendums`

```{r}
#' Untidy into "raw" C2D API referendum data
#'
#' Converts from the tidied [referendums()] to the "raw" MongoDB schema used by the C2D API. Basically reverts [tidy_referendums()].
#'
#' @param data The data to untidy as returned by [referendums()].
#'
#' @return
#' If `as_tibble = FALSE`, a list with one element per referendum, suitable to convert [jsonlite::toJSON()] and then feed to the C2D API.
#'
#' Otherwise a [tibble][tibble::tbl_df] of the same format as returned by [`referendums(tidy = FALSE)`][referendums].
#' @keywords internal
untidy_referendums <- function(data,
                               as_tibble = FALSE) {
  
  checkmate::assert_flag(as_tibble)
  v_names_inverse <- names(v_names) %>% magrittr::set_names(purrr::flatten_chr(v_names))
  sub_v_names_files_inverse <- names(sub_v_names$files) %>% magrittr::set_names(purrr::flatten_chr(sub_v_names$files))
  
  # restore `number`
  if (all(c("id_official", "id_sudd") %in% colnames(data))) {
    data %<>% dplyr::mutate(id_sudd = dplyr::if_else(is.na(id_sudd),
                                                     id_official,
                                                     id_sudd))
  }
  
  data %<>%
    dplyr::mutate(
      # restore strings
      dplyr::across(c(any_of("date"),
                      where(is.factor)),
                    as.character),
      dplyr::across(where(is.list),
                    ~ {
                      if (is.factor(.x[[1L]])) {
                        .x %>% purrr::map(as.character)
                      } else {
                        .x
                      }
                    }),
      # restore dates
      dplyr::across(any_of("date_time_created"),
                    untidy_date),
      # restore individual variables
      ## `files`
      dplyr::across(.cols = any_of("files"),
                    .fns = purrr::map,
                    .f = ~ {
                      
                      if ("date_time_attached" %in% colnames(.x)) {
                        
                        .x$date_time_attached %<>% untidy_date()
                      }
                      
                      .x %<>% rename_from_list(names_list = sub_v_names_files_inverse)
                    }),
      ## `inst_topics_excluded`
      dplyr::across(.cols = any_of("inst_topics_excluded"),
                    .fns = purrr::map,
                    .f = dplyr::recode,
                    "budgets" = "budget"),
      ## `inst_topics_only`
      dplyr::across(.cols = any_of("inst_topics_only"),
                    .fns = purrr::map,
                    .f = dplyr::recode,
                    "infrastructural acts" = "infrastructural act",
                    "competence shifts" = "competence shift",
                    "financial acts" = "financial act",
                    "financial acts (expenses)" = "financial act (expenses)",
                    "financial acts (taxes)" = "financial act (taxes)",
                    "financial acts (obligations)" = "financial act (obligations)",
                    "total revisions of the constitution" = "total revision of the constitution"),
      ## `inst_object_revision_divisibility`
      dplyr::across(any_of("inst_object_revision_divisibility"),
                    dplyr::recode,
                    "as a whole" = "Whole text only",
                    "split up" = "Splitting up possible",
                    "as variants" = "Variants possible",
                    "both split up and as variants" = "Variants / splitting up possible"),
      ## `inst_object_type`
      dplyr::across(any_of("inst_object_type"),
                    dplyr::recode,
                    "legal text (formulated proposal)" = "legal text (ausformulierter vorschlag)",
                    "legal text (general proposal)" = "legal text (allg. anregung)"),
      ## `inst_trigger_actor` / `inst_object_author`
      dplyr::across(any_of(c("inst_trigger_actor",
                             "inst_object_author")),
                    dplyr::recode,
                    "other institution" = "institution"),
      ## `inst_precondition_actor`
      dplyr::across(any_of("inst_precondition_actor"),
                    dplyr::recode,
                    "parliament and president" = "parliament and President",
                    "parliament and government" = "parliament and Government"),
      ## `type`
      dplyr::across(any_of("type"),
                    dplyr::recode,
                    "citizens' assembly" = "citizen assembly",
                    .missing = "not provided"),
      ## `id`
      dplyr::across(any_of("id"),
                    ~ as.list(.x) %>% magrittr::set_names(rep("$oid", times = length(.)))),
      ## binary (dummies)
      dplyr::across(any_of("position_government"),
                    dplyr::recode,
                    "yes" = "Acceptance",
                    "no" = "Rejection"),
      dplyr::across(any_of("inst_has_urgent_legal_basis"),
                    dplyr::if_else,
                    true = "Urgent",
                    false = "Normal"),
      dplyr::across(any_of("inst_is_binding"),
                    dplyr::if_else,
                    true = "Binding",
                    false = "Non-binding"),
      dplyr::across(any_of("inst_is_counter_proposal"),
                    dplyr::if_else,
                    true = "Yes",
                    false = "No"),
      dplyr::across(any_of("inst_is_assembly"),
                    dplyr::if_else,
                    true = "Assembly",
                    false = "Ballot"),
      dplyr::across(any_of("inst_has_precondition"),
                    dplyr::if_else,
                    true = "Exists",
                    false = "Does not exist"),
      # uppercase first letter of various vars
      dplyr::across(.cols = any_of(c("result",
                                     "type",
                                     "inst_legal_basis_type",
                                     "inst_object_type",
                                     "inst_object_legal_level",
                                     "inst_object_revision_extent",
                                     "inst_trigger_type",
                                     "inst_trigger_actor_level",
                                     "inst_trigger_time_limit",
                                     "inst_quorum_approval",
                                     "inst_precondition_decision",
                                     # vars containing uppercase abbreviations
                                     "inst_object_author",
                                     "inst_trigger_actor",
                                     "inst_precondition_actor")),
                    .fns = pal::sentenceify,
                    punctuation_mark = ""),
      dplyr::across(.cols = any_of(c("inst_object_revision_modes",
                                     "inst_topics_only",
                                     "inst_topics_excluded")),
                    .fns = purrr::map,
                    .f = pal::sentenceify,
                    punctuation_mark = ""),
      # restore NA values (always assumed to mean 'not provided', never 'unknown')
      dplyr::across(any_of("result"),
                    tidyr::replace_na,
                    replace = "Not provided"),
      dplyr::across(any_of(c("subterritories_yes", "subterritories_no")),
                    tidyr::replace_na,
                    replace = -2.0),
      dplyr::across(where(is.character),
                    tidyr::replace_na,
                    replace = ""),
      dplyr::across(where(is.integer),
                    tidyr::replace_na,
                    replace = -2L)
    ) %>%
    # restore variable names
    # TODO: find out why this (and only this) call of `rename_from_list()` causes the warning:
    #       "Unquoting language objects with `!!!` is deprecated as of rlang 0.4.0."
    rename_from_list(names_list = v_names_inverse)
  
  # restore `tags`
  tags_v_names <- paste0("tags_tier_", 1:3)
  tags_vx_present <- tags_v_names %in% colnames(data)
  
  if (any(tags_vx_present)) {
    
    if (!all(tags_vx_present)) {
      tags_vx_missing <- tags_v_names %>% setdiff(tags_vx_present)
      cli::cli_abort("There are only part of all {.var tags_tier_#} variables present. ",
                     "{cli::qty(tags_vx_missing)} The following variable{?s} are missing: {.var {tags_vx_missing}}")
    }
    
    data %<>%
      dplyr::mutate(tags = restore_tags(tags_tier_1,
                                        tags_tier_2,
                                        tags_tier_3)) %>%
      dplyr::select(-any_of(tags_v_names))
  }
  
  data %<>%
    # remove unknown columns
    dplyr::select(any_of(referendum_fields$all_flat)) %>%
    # remove variable labels
    labelled::remove_var_label()
  
  if (!as_tibble) {
    
    # remove nested field prefixes
    data %<>% dplyr::rename_with(.cols = matches("^(categories|context|title)\\."),
                                 .fn = ~ stringr::str_remove(string = .x,
                                                             pattern = "^\\w+?\\."))
    
    # restore nested structure
    categories_fields_present <-
      names(v_names) %>%
      stringr::str_subset(pattern = "^categories\\.") %>%
      stringr::str_remove(pattern = "^categories\\.") %>%
      intersect(colnames(data))
    
    context_fields_present <-
      names(v_names) %>%
      stringr::str_subset(pattern = "^context\\.") %>%
      stringr::str_remove(pattern = "^context\\.") %>%
      intersect(colnames(data))
    
    title_fields_present <-
      names(v_names) %>%
      stringr::str_subset(pattern = "^title\\.") %>%
      stringr::str_remove(pattern = "^title\\.") %>%
      intersect(colnames(data))
    
    if (length(categories_fields_present)) {
      data %<>% tidyr::nest(categories = all_of(categories_fields_present))
    }
    if (length(context_fields_present)) {
      data %<>% tidyr::nest(context = all_of(context_fields_present))
    }
    if (length(title_fields_present)) {
      data %<>% tidyr::nest(title = all_of(title_fields_present))
    }
    
    data %<>%
      # convert to list
      dplyr::group_split(dplyr::row_number(),
                         .keep = FALSE) %>%
      purrr::map(as.list) %>%
      # tweak list structure
      purrr::modify_depth(.depth = 1L,
                          .f = ~
                            .x %>%
                            # flatten unnecessarily nested elements
                            purrr::modify_at(.at = "tags",
                                             .f = flatten_array_as_is) %>%
                            # convert nested tibbles to lists
                            purrr::modify_at(.at = "files",
                                             .f = ~
                                               .x[[1L]] %>%
                                               purrr::when(is.null(.) ~ list(),
                                                           ~ dplyr::group_split(.tbl = .,
                                                                                dplyr::row_number(),
                                                                                .keep = FALSE) %>%
                                                             purrr::map(as.list))) %>%
                            purrr::modify_at(.at = c("archive",
                                                     "categories",
                                                     "context",
                                                     "title"),
                                             .f = ~
                                               .x %>%
                                               purrr::map(as.list) %>%
                                               unlist(recursive = FALSE)) %>%
                            # reduce nesting of nested tibble
                            purrr::when(is.null(purrr::pluck(., "context", "votes_per_canton")) ~ .,
                                        ~ purrr::modify_in(.x = .,
                                                           .where = c("context", "votes_per_canton"),
                                                           .f = dplyr::first)) %>%
                            # reduce nesting of array fields
                            purrr::when(is.null(purrr::pluck(., "categories", "action")) ~ .,
                                        ~ purrr::modify_in(.x = .,
                                                           .where = c("categories", "action"),
                                                           .f = flatten_array_as_is)) %>%
                            purrr::when(is.null(purrr::pluck(., "categories", "excluded_topics")) ~ .,
                                        ~ purrr::modify_in(.x = .,
                                                           .where = c("categories", "excluded_topics"),
                                                           .f = flatten_array_as_is)) %>%
                            purrr::when(is.null(purrr::pluck(., "categories", "special_topics")) ~ .,
                                        ~ purrr::modify_in(.x = .,
                                                           .where = c("categories", "special_topics"),
                                                           .f = flatten_array_as_is)))
  }
  
  data
}
```

### MongoDB query filter operator helpers

#### `$date`

Example query found in the mongolite documentation: <https://jeroen.github.io/mongolite/query-data.html#select-by-date>

```{r}
query_filter_date <- function(min,
                              max) {
  
  list(`$gte` = list(`$date` = lubridate::as_datetime(min)) %>% purrr::compact(),
       `$lte` = list(`$date` = lubridate::as_datetime(max)) %>% purrr::compact()) %>%
    purrr::compact()
}
```

#### `$in`

MongoDB documentation: <https://docs.mongodb.com/manual/reference/operator/query/in/#mongodb-query-op.-in>

```{r}
query_filter_in <- function(x) {
  
  x %>% purrr::when(is.null(.) || length(.) == 0L ~ NULL,
                    length(.) == 1 ~ .,
                    ~ list(`$in` = .))
}
```

### sudd.ch-related

#### `add_sudd_country_name_de`

DEPRECATED!

NOTES:

-   To map the `territory_name_de` of `list_sudd_territories()` unambiguously to the `territory_name_de` of `sudd_referendums()` and `list_sudd_referendums()`,
    the latter needs to be truncated first using `shorten_sudd_territory_name_de()`.

    Simple mapping by substring as follows leads to ambiguous results:

    ``` r
    sudd_t <- c2d::list_sudd_territories()

    c2d::list_sudd_referendums() %>%
      dplyr::mutate(country_name_de =
                      territory_name_de %>%
                      purrr::map(~ sudd_t %>%
                                   dplyr::filter(stringr::str_detect(string = .x,
                                                                     pattern = paste0("\\Q", territory_name_de, "\\E"))) %$%
                                   country_name_de %>% unique())) %>%
      dplyr::filter(country_name_de %>% purrr::map_lgl(~ length(.x) > 1L)) %>%
      View()
    ```

-   The function below still leads to multiple results in certain cases due to ambiguities in sudd territories, which would need to be resolved first:

    ``` r
    list_sudd_territories() %>%
      dplyr::filter(territory_name_de %in% territory_name_de[duplicated(territory_name_de)]) %>%
      dplyr::arrange(territory_name_de)
    ```

```{r, purl = FALSE}
add_sudd_country_name_de <- function(data) {
  
  pal::assert_pkg("assertr")
  
  data %>%
    dplyr::mutate(territory_name_de_short = shorten_sudd_territory_name_de(territory_name_de)) %>%
    dplyr::left_join(list_sudd_territories() %>% dplyr::select(country_name_de, territory_name_de),
                     by = c("territory_name_de_short" = "territory_name_de")) %>%
    dplyr::select(-territory_name_de_short) %>%
    dplyr::relocate(country_name_de,
                    .before = territory_name_de) %>%
    assertr::assert(predicate = assertr::not_na,
                    country_name_de)
}
```

#### `complete_sudd_url`

Completes relative URLs.

```{r}
complete_sudd_url <- function(x) {
  
  httr::parse_url(x) %>%
    purrr::modify_in(.where = "scheme",
                     .f = ~ .x %||% "https") %>%
    purrr::modify_in(.where = "hostname",
                     .f = ~ .x %||% "sudd.ch") %>%
    # work around "Error: All components of query must be named" in `httr::build_url()`
    purrr::modify_in(.where = "query",
                     .f = ~ {
                       .x[names(.x) == ""] <- NULL
                       .x
                     }) %>%
    httr::build_url()
}
```

#### `parse_sudd_date`

Parses pseudo ISO 8601 strings like `"1999-03-17"` (valid) and `"2000-09-00"` (missing day).

```{r}
parse_sudd_date <- function(x) {
  
  components <-
    x %>%
    stringr::str_split(pattern = "-") %>%
    dplyr::first()
  
  list(day = components[3L] %>% dplyr::recode("00" = NA_character_) %>% as.integer(),
       month = components[2L] %>% as.integer(),
       year = components[1L] %>% as.integer())
}
```

#### `parse_sudd_date_de`

Parses German date strings like `"17. März 1999"` and `??. September 2000`.

```{r}
parse_sudd_date_de <- function(x) {
  
  components <- x %>% stringr::str_split(pattern = "\\s")
  
  list(year = components %>% purrr::map_chr(magrittr::extract, 3L) %>% stringr::str_extract(pattern = "\\d+") %>% as.integer(),
       month = components %>% purrr::map_chr(magrittr::extract, 2L) %>% dplyr::recode(!!!months_de),
       day = components %>% purrr::map_chr(magrittr::extract, 1L) %>% stringr::str_extract(pattern = "\\d+") %>% as.integer())
}
```

#### `parse_sudd_id`

Derives `country_code`, `country_name` and `country_code_historical` from an `id_sudd`.

An `id_sudd` is composed of

-   the 2-character lowercase `country_code`
-   plus a sequential 2-digit referendum number starting with `01` for the first referendum in the given year
-   plus the 4-digit `year` the referendum took place.

```{r}
parse_sudd_id <- function(id_sudd) {
  
  sudd_year <-
    id_sudd %>%
    stringr::str_extract(pattern = "\\d{4}$") %>%
    as.integer()
  
  sudd_country_code <-
    id_sudd %>%
    stringr::str_sub(end = 2L) %>%
    stringr::str_to_upper()
  
  derive_country_vx(country_code = sudd_country_code,
                    date = lubridate::make_date(year = sudd_year,
                                                month = 1L,
                                                day = 1L))
}
```

#### `shorten_sudd_territory_name_de`

```{r}
shorten_sudd_territory_name_de <- function(x) {
  
  stringr::str_remove(string = x,
                      pattern = "\\s*\\([^\\)]+\\).*")
}
```

#### `sudd_referendum_field_names`

Determines the `field_names` of a sudd.ch referendum, whether it `has_field_names_duplicated`, and if so, the actual `field_names_duplicated` (incl. number of
duplications).

This function is mainly useful for debugging and thus not included in the final package (`purl = FALSE`).

To get an overview of *all* duplicated sudd.ch referendum field names, use:

``` r
data_sudd_field_names <-
  c2d::list_sudd_referendums() %$%
  id_sudd %>%
  purrr::map_dfr(c2d:::sudd_referendum_field_names) %>%
  tibble::add_column(!!!(.$id_sudd %>% purrr::map_dfr(c2d:::parse_sudd_id)),
                     year = .$id_sudd %>% stringr::str_extract(pattern = "\\d{4}$"))

data_sudd_field_names %>%
  dplyr::filter(has_field_names_duplicated) %>%
  dplyr::arrange(country_code, year, id_sudd) %>%
  print(n = Inf)
```

```{r, purl = FALSE}
sudd_referendum_field_names <- function(id_sudd) {
  
  checkmate::assert_string(id_sudd)
  
  html <-
    httr::RETRY(verb = "GET",
                url = "https://sudd.ch/event.php",
                query = list(id = id_sudd),
                times = 5L) %>%
    xml2::read_html() %>%
    rvest::html_element(css = "main table") %>%
    rvest::html_children()
  
  field_names <-
    html %>%
    rvest::html_elements(css = "td.feld") %>%
    rvest::html_text()
  
  field_names_duplicated <-
    field_names[field_names %in% field_names[duplicated(field_names)]] %>%
    table(exclude = NULL) %>%
    tibble::enframe(name = "field_name",
                    value = "n")
  
  tibble::tibble(id_sudd = id_sudd,
                 field_names = list(field_names),
                 has_field_names_duplicated = nrow(field_names_duplicated) > 0L,
                 field_names_duplicated = list(field_names_duplicated))
}
```

#### `sudd_referendum`

Retrieves a single referendum's data from sudd.ch.

```{r}
sudd_referendum <- function(id_sudd) {
  
  checkmate::assert_string(id_sudd)
  
  html <-
    httr::RETRY(verb = "GET",
                url = "https://sudd.ch/event.php",
                query = list(id = id_sudd),
                times = 5L) %>%
    xml2::read_html() %>%
    rvest::html_element(css = "main table") %>%
    rvest::html_children()
  
  field_names <-
    html %>%
    rvest::html_elements(css = "td.feld") %>%
    rvest::html_text()
  
  # handle fields with duplicated/ambiguous names
  if (anyDuplicated(field_names)) {
    
    ## simple duplicates (errors)
    if (id_sudd == "gr011862") {
      
      i_to_drop <- which(field_names == "\u2517\u2501 Republik")[2L]
      html %<>% .[-i_to_drop]
      field_names %<>% .[-i_to_drop]
      
      ## competing / mutually exclusive proposals, e.g. proposals with direct counter proposal and (optionally) tie-breaker question (CH and LI)
    } else {
      
      option_names <-
        html %>%
        rvest::html_elements(css = "td.feld strong") %>%
        rvest::html_text()
      
      if (length(option_names) < 2L) cli::cli_abort("Unknown table layout detected for referendum with {.arg id_sudd = {id_sudd}}. Please debug.")
      
      i_option_names <- which(field_names %in% option_names)
      option_names_counter <- c("Gegenentwurf", "Gegenvorschlag")
      option_names_tie_breaker <- "Stichfrage"
      option_names_special <- c(option_names_counter, option_names_tie_breaker)
      has_counter_proposal <- any(option_names_counter %in% option_names)
      n_proposals_original <-
        option_names %>%
        setdiff(option_names_special) %>%
        length()
      
      i_option_field_names <-
        i_option_names[-length(i_option_names)] %>%
        purrr::imap(~ (.x + 1L):(i_option_names[.y + 1L] - 1L)) %>%
        c(list((dplyr::last(i_option_names) + 1L):(min(length(field_names), which(field_names %in% c("Medien",
                                                                                                     "Bemerkungen",
                                                                                                     "Gleichzeitig mit",
                                                                                                     "Quellen",
                                                                                                     "Vollst\u00e4ndigkeit",
                                                                                                     "Letzte \u00c4nderung"))) - 1L)))
      # rename field names
      option_suffixes <-
        option_names %>%
        purrr::imap_chr(~ .x %>% purrr::when(. %in% option_names_counter                        ~ "counter_proposal",
                                             . %in% option_names_tie_breaker                    ~ "tie_breaker",
                                             has_counter_proposal && n_proposals_original == 1L ~ "proposal",
                                             ~ glue::glue("option_{.y}")))
      renamings <-
        purrr::map2(.x = setdiff(option_names,
                                 option_names_tie_breaker),
                    .y = setdiff(option_suffixes,
                                 "tie_breaker"),
                    .f = ~ rlang::list2(!!paste("\u2517\u2501", .x) := glue::glue("votes_tie_breaker_{.y}"),
                                        !!paste("\u2517\u2501 St\u00e4nde", .x) := glue::glue("subterritories_{.y}_tie_breaker"))) %>%
        purrr::flatten()
      
      for (i in seq_along(option_names)) {
        
        field_names[i_option_field_names[[i]]] %<>%
          dplyr::recode(!!!c(renamings,
                             list("Abgegebene Stimmen"                   = glue::glue("votes_{option_suffixes[i]}_total"),
                                  "Stimmen ausser Betracht"              = glue::glue("votes_{option_suffixes[i]}_invalid"),
                                  "Ohne Antwort"                         = glue::glue("votes_{option_suffixes[i]}_empty"),
                                  "G\u00fcltige (= massgebende) Stimmen" = glue::glue("votes_{option_suffixes[i]}_valid"),
                                  "\u2517\u2501 Ja-Stimmen"              = glue::glue("votes_{option_suffixes[i]}_yes"),
                                  "\u2517\u2501 Nein-Stimmen"            = glue::glue("votes_{option_suffixes[i]}_no"),
                                  "Ja-Stimmen"                           = glue::glue("votes_{option_suffixes[i]}_yes"),
                                  "Nein-Stimmen"                         = glue::glue("votes_{option_suffixes[i]}_no"),
                                  "St\u00e4nde (Kantone)"                = glue::glue("subterritories_{option_suffixes[i]}"),
                                  "\u2517\u2501 Annehmende St\u00e4nde"  = glue::glue("subterritories_{option_suffixes[i]}_yes"),
                                  "\u2517\u2501 Verwerfende St\u00e4nde" = glue::glue("subterritories_{option_suffixes[i]}_no"))))
      }
      
      # drop obsolete fields
      html %<>% .[-i_option_names]
      field_names %<>% .[-i_option_names]
      
    }
  }
  
  # handle other special cases
  if (id_sudd %in% c("li011954",
                     "li031985")) {
    
    field_names %<>% dplyr::recode("\u2517\u2501 Initiative"     = "votes_proposal",
                                   "\u2517\u2501 Gegenvorschlag" = "votes_counter_proposal",
                                   "\u2517\u2501 Nein-Stimmen"   = "votes_option_none")
  }
  
  ## move content of exotic fields to `remarks`
  remarks_field <-
    html[field_names == "Bemerkungen"] %>%
    purrr::when(length(.) > 0L ~ rvest::html_elements(x = ., css = "td")[[2L]],
                ~ .)
  
  remarks_list_col <- list(list(text = rvest::html_text2(remarks_field),
                                urls =
                                  remarks_field %>%
                                  rvest::html_elements(css = "a") %>%
                                  purrr::map_chr(~ .x %>%
                                                   rvest::html_attr(name = "href") %>%
                                                   complete_sudd_url()),
                                html =
                                  remarks_field %>%
                                  xml2::xml_contents() %>%
                                  as.character() %>%
                                  paste0(collapse = "")))
  i_fields_to_remarks <-
    field_names %>%
    stringr::str_detect(pattern = paste0("^",
                                         pal::fuse_regex("\u2517\u2501\u2501\u2501 .+Stimmen( .+)?",
                                                         "Unklare Stimmen",
                                                         "Unstimmigkeiten",
                                                         "G\u00fcltig stimmende Personen"),
                                         "$")) %>%
    which()
  
  if (length(i_fields_to_remarks)) {
    
    addendum <-
      field_names[i_fields_to_remarks] %>%
      stringr::str_extract("\\w.*") %>%
      paste0(": ",
             html[i_fields_to_remarks] %>%
               rvest::html_elements(css = "td") %>%
               magrittr::extract2(2L) %>%
               rvest::html_elements(css = "data") %>%
               rvest::html_attr("value"),
             collapse = "\n\n")
    
    remarks_list_col[[1]]$text %<>% paste0(addendum, "\n\n", .)
    remarks_list_col[[1]]$html %<>% paste0("<p>\n", addendum, "\n</p>", .)
    html %<>% .[-i_fields_to_remarks]
    field_names %<>% .[-i_fields_to_remarks]
  }
  
  # remove unnecessary fields
  i_to_drop <- which(field_names %in% c("Nicht eingelegte Stimmzettel",
                                        "Nicht eingelegte Stimmenzettel",
                                        "Nicht teilgenommen"))
  
  if (length(i_to_drop)) {
    html %<>% .[-i_to_drop]
    field_names %<>% .[-i_to_drop]
  }
  
  field_names %<>%
    dplyr::recode("Gebiet"                                         = "territory_name_de",
                  "\u2517\u2501 Stellung"                          = "territory_type_de",
                  "Datum"                                          = "date",
                  "Titel"                                          = "title_de",
                  "Vorlage"                                        = "title_de",
                  "\u2517\u2501 Fragemuster"                       = "question_type_de",
                  "\u2517\u2501 Abstimmungstyp"                    = "types",
                  "Ergebnis"                                       = "result_de",
                  "Vollst\u00e4ndigkeit"                           = "result_status_de",
                  "\u2517\u2501 Mehrheiten"                        = "adoption_requirements_de",
                  "Stimmberechtigte"                               = "electorate_total",
                  "\u2517\u2501 Davon im Ausland"                  = "electorate_abroad",
                  "Stimmausweise"                                  = "polling_cards",
                  "Stimmbeteiligung"                               = "votes_total",
                  "Stimmen ausser Betracht"                        = "votes_invalid",
                  "Stimmzettel ausser Betracht"                    = "votes_invalid",
                  "Leere Stimmen"                                  = "votes_empty",
                  "\u2517\u2501 Leere Stimmen"                     = "votes_empty",
                  "\u2517\u2501 Leere Stimmzettel"                 = "votes_empty",
                  "Ung\u00fcltige Stimmen"                         = "votes_void",
                  "\u2517\u2501 Ung\u00fcltige Stimmen"            = "votes_void",
                  "\u2517\u2501 Ung\u00fcltige Stimmzettel"        = "votes_void",
                  "Ganz ung\u00fcltige Stimmzettel"                = "votes_void",
                  "G\u00fcltige (= massgebende) Stimmen"           = "votes_valid",
                  "\u2517\u2501 Ja-Stimmen"                        = "votes_yes",
                  "\u2517\u2501 Nein-Stimmen"                      = "votes_no",
                  "\u2517\u2501 Nein zu beiden Vorschl\u00e4gen"   = "votes_option_none",
                  "\u2517\u2501 Stimmen ausser Betracht"           = "votes_invalid",
                  "Staaten"                                        = "subterritories",
                  "\u2517\u2501 Annehmende Staaten"                = "subterritories_yes",
                  "\u2517\u2501 Verwerfende Staaten"               = "subterritories_no",
                  "Gebiete"                                        = "subterritories",
                  "\u2517\u2501 Annehmende Gebiete"                = "subterritories_yes",
                  "\u2517\u2501 Verwerfende Gebiete"               = "subterritories_no",
                  "Provinzen"                                      = "subterritories",
                  "\u2517\u2501 Annehmende Provinzen"              = "subterritories_yes",
                  "\u2517\u2501 Verwerfende Provinzen"             = "subterritories_no",
                  "Inseln"                                         = "subterritories",
                  "\u2517\u2501 Annehmende Inseln"                 = "subterritories_yes",
                  "\u2517\u2501 Verwerfende Inseln"                = "subterritories_no",
                  "St\u00e4nde (Kantone)"                          = "subterritories",
                  "\u2517\u2501 Annehmende St\u00e4nde"            = "subterritories_yes",
                  "\u2517\u2501 Verwerfende St\u00e4nde"           = "subterritories_no",
                  "Wahlkreise"                                     = "subterritories",
                  "\u2517\u2501 Annehmende Wahlkreise"             = "subterritories_yes",
                  "\u2517\u2501 Verwerfende Wahlkreise"            = "subterritories_no",
                  "Senatswahlkreise"                               = "subterritories",
                  "\u2517\u2501 Annehmende Senatswahlkreise"       = "subterritories_yes",
                  "\u2517\u2501 Verwerfende Senatswahlkreise"      = "subterritories_no",
                  "Medien"                                         = "files",
                  "Bemerkungen"                                    = "remarks",
                  "Gleichzeitig mit"                               = "ids_sudd_simultaneous",
                  "Quellen"                                        = "sources",
                  "Letzte \u00c4nderung"                           = "date_last_edited") %>%
    # assert field names are unique
    checkmate::assert_character(any.missing = FALSE,
                                unique = TRUE,
                                .var.name = "field_names") %>%
    # referendum-option-specific recodings (sequentially numbered `votes_option_#` columns)
    # TODO: adapt this once we can properly capture more than yes/no answer options
    purrr::map_at(.at = which(stringr::str_detect(string = .,
                                                  pattern = "^\u2517\u2501 ")),
                  .f = function(old_name, old_names) paste0("votes_option_", which(old_names == old_name)),
                  old_names = stringr::str_subset(string = .,
                                                  pattern = "^\u2517\u2501 ")) %>%
    purrr::flatten_chr()

  # assert no original uppercase field names are left over
  i_field_names_unknown <-
    field_names %>%
    stringr::str_detect(pattern = "[:upper:]") %>%
    which()
  
  if (length(i_field_names_unknown)) {
    cli::cli_abort(paste0("Unknown {cli::qty(length(i_field_names_unknown))} field{?s} {.field {field_names[i_field_names_unknown]}} present in data for ",
                          "referendum with {.arg id_sudd = {id_sudd}}."))
  }
  
  purrr::map2_dfc(.x = html,
                  .y = field_names,
                  .f = function(html, col_name) {
                    
                    cells <- html %>% rvest::html_elements(css = "td")
                    col_text <- rvest::html_text2(cells[[2L]])
                    
                    # extract hyperlinks if necessary
                    if (col_name %in% c("remarks",
                                        "ids_sudd_simultaneous",
                                        "sources")) {
                      urls <-
                        cells[[2L]] %>%
                        rvest::html_elements(css = "a") %>%
                        purrr::map_chr(~ .x %>%
                                         rvest::html_attr(name = "href") %>%
                                         complete_sudd_url())
                    }
                    
                    tibble::tibble(!!col_name :=
                                     col_name %>%
                                     purrr::when(
                                       # character scalars
                                       . %in% c("territory_name_de",
                                                "territory_type_de",
                                                "title_de",
                                                "question_type_de",
                                                "result_de",
                                                "result_status_de") ~
                                         col_text,
                                       
                                       # integer scalars
                                       stringr::str_detect(
                                         string = .,
                                         pattern = paste0(
                                           "^",
                                           pal::fuse_regex(
                                             "electorate_total",
                                             "electorate_abroad",
                                             "polling_cards",
                                             "votes_total",
                                             "votes_invalid",
                                             "votes_empty",
                                             "votes_void",
                                             "votes_valid",
                                             "votes_yes",
                                             "votes_no",
                                             "votes_proposal",
                                             "votes_counter_proposal",
                                             paste0("votes_",
                                                    pal::fuse_regex("option_(\\d+|none)",
                                                                    "(counter_)?proposal",
                                                                    "tie_breaker(_(option_\\d+|(counter_)?proposal))?"),
                                                    paste0("(_",
                                                           pal::fuse_regex("total",
                                                                           "empty",
                                                                           "void",
                                                                           "invalid",
                                                                           "valid",
                                                                           "yes",
                                                                           "no"),
                                                           ")?"))),
                                           "$")) ~
                                         cells[[2L]] %>%
                                         rvest::html_elements(css = "data") %>%
                                         rvest::html_attr("value") %>%
                                         # fall back to parsing text if no semantic data could be extracted
                                         purrr::when(length(.) == 0L ~ col_text %>% stringr::str_remove_all(pattern = "[^\\d]"),
                                                     ~ .) %>%
                                         as.integer(),
                                       
                                       stringr::str_detect(string = .,
                                                           pattern = "^subterritories") ~
                                         cells[[2L]] %>%
                                         rvest::html_elements(css = "data") %>%
                                         rvest::html_attr("value") %>%
                                         # fall back to parsing text if no semantic data could be extracted
                                         purrr::when(length(.) == 0L ~ col_text %>% stringr::str_remove_all(pattern = "[^\\d]"),
                                                     ~ .) %>%
                                         as.numeric(),
                                       
                                       # date scalars
                                       . == "date" ~
                                         cells[[2L]] %>%
                                         rvest::html_element(css = "time") %>%
                                         rvest::html_attr(name = "datetime"),
                                       
                                       . == "date_last_edited" ~
                                         cells[[2L]] %>%
                                         rvest::html_element(css = "time") %>%
                                         rvest::html_attr(name = "datetime") %>%
                                         lubridate::as_date(),
                                       
                                       # lists (multi-value cols)
                                       . == "remarks" ~
                                         remarks_list_col,
                                       
                                       . %in% c("sources") ~
                                         list(list(text = col_text,
                                                   urls = urls,
                                                   html =
                                                     cells[[2L]] %>%
                                                     xml2::xml_contents() %>%
                                                     as.character() %>%
                                                     paste0(collapse = ""))),
                                       . == "types" ~
                                         col_text %>% stringr::str_split(pattern = "\\s*\u2192\\s*"),
                                       . == "adoption_requirements_de" ~
                                         col_text %>% stringr::str_split(pattern = ",\\s*"),
                                       . == "files" ~
                                         cells[[2L]] %>%
                                         rvest::html_elements(css = "a") %>%
                                         purrr::map_dfr(~ .x %>%
                                                          rvest::html_attr(name = "href") %>%
                                                          complete_sudd_url() %>%
                                                          tibble::tibble(description = rvest::html_text(.x),
                                                                         url = .)) %>%
                                         list(),
                                       . == "ids_sudd_simultaneous" ~
                                         urls %>%
                                         stringr::str_extract(pattern = "(?<=[\\?&]id=)[\\w\\d]+") %>%
                                         list(),
                                       
                                       ~ "PARSING ERROR; PLEASE DEBUG"
                                     ))
                  })
}
```

### Tags-related

#### `restore_tags`

NOTE that this function doesn't restore *redundant* information (parent-tier tags). Once [issue #41](https://github.com/ccmdesign/c2d-app/issues/41) is
resolved, we can deprecate this anyway.

```{r}
restore_tags <- function(tags_tier_1,
                         tags_tier_2,
                         tags_tier_3) {
  list(tags_tier_1,
       tags_tier_2,
       tags_tier_3) %>%
    purrr::pmap(~ {
      
      ..1 %>%
        unlist() %>%
        as.character() %>%
        checkmate::assert_character(any.missing = FALSE,
                                    max.len = 3L)
      ..2 %>%
        unlist() %>%
        as.character() %>%
        checkmate::assert_character(any.missing = FALSE,
                                    max.len = 3L)
      ..3 %>%
        unlist() %>%
        as.character() %>%
        checkmate::assert_character(any.missing = FALSE,
                                    max.len = 3L,
                                    .var.name = "tags_tier_3")
      
      tags_hierarchy <- hierarchize_tags(tibble::tibble(tags_tier_1 = list(..1),
                                                        tags_tier_2 = list(..2),
                                                        tags_tier_3 = list(..3)))
      
      tags <- tags_hierarchy$tag_tier_3 %>% setdiff(NA_character_)
      
      if (length(tags) < 3L) {
        
        tags <-
          tags_hierarchy %>%
          dplyr::filter(is.na(tag_tier_3)) %$%
          tag_tier_2 %>%
          setdiff(NA_character_) %>%
          c(tags)
      }
      
      if (length(tags) < 3L) {
        
        tags <-
          tags_hierarchy %>%
          dplyr::filter(is.na(tag_tier_3) & is.na(tag_tier_2)) %$%
          tag_tier_1 %>%
          setdiff(NA_character_) %>%
          c(tags)
      }
      
      tags
    })
}
```

#### `tags`

```{r}
tags <- function(tiers = 1:3) {
  
  checkmate::assert_integerish(tiers,
                               lower = 1L,
                               upper = 3L,
                               any.missing = FALSE,
                               unique = TRUE)
  tag_set <- character()
  
  if (1L %in% tiers) {
    tag_set %<>% c(data_tags$tag_tier_1)
  }
  
  if (2L %in% tiers) {
    tag_set %<>% c(data_tags$tag_tier_2)
  }
  
  if (3L %in% tiers) {
    tag_set %<>% c(data_tags$tag_tier_3)
  }
  
  tag_set %>% setdiff(NA_character_) %>% unique()
}
```

## Constants

```{r}
this_pkg <- utils::packageName()
```

### C2D referendum database fields

Field names as returned by the `referendums` API endpoint.

```{r}
referendum_fields <- list()
```

#### All

```{r}
referendum_fields$all <- c("_id",
                           "archive",
                           "canton",
                           "categories",
                           "citizens_abroad",
                           "committee_name",
                           "context",
                           "country_code",
                           "country_name",
                           "created_on",
                           "date",
                           "draft",
                           "files",
                           "institution",
                           "level",
                           "municipality",
                           "number",
                           "remarks",
                           "result",
                           "tags",
                           "title",
                           "total_electorate",
                           "votes_empty",
                           "votes_invalid",
                           "votes_no",
                           "votes_yes")

referendum_fields$all_flat <-
  referendum_fields$all %>%
  setdiff(c("categories", "context", "title")) %>%
  union(c("categories.action",
          "categories.author_of_the_vote_object",
          "categories.counter_proposal",
          "categories.decision_quorum",
          "categories.degree_of_revision",
          "categories.excluded_topics",
          "categories.hierarchy_of_the_legal_norm",
          "categories.institutional_precondition",
          "categories.institutional_precondition_decision",
          "categories.institutional_precondition_decision_actor",
          "categories.legal_act_type",
          "categories.official_status",
          "categories.referendum_text_options",
          "categories.special_topics",
          "categories.turnout_quorum",
          "categories.vote_object",
          "categories.vote_result_status",
          "categories.vote_trigger",
          "categories.vote_trigger_actor",
          "categories.vote_trigger_number",
          "categories.vote_trigger_state_level",
          "categories.vote_trigger_time",
          "categories.vote_venue",
          "context.national_council_abstentions",
          "context.national_council_no",
          "context.national_council_yes",
          "context.recommendation",
          "context.states_council_abstentions",
          "context.states_council_no",
          "context.states_council_yes",
          "context.states_no",
          "context.states_yes",
          "context.votes_per_canton",
          "title.de",
          "title.en",
          "title.fr"))
```

#### Mandatory

The following fields are mandatory when adding/editing referendums via the [admin portal](https://admin.c2d.ch/), but not *strictly* mandatory schema-wise:

| field                    | edits | additions | remarks                                                                                       |
|--------------------------|-------|-----------|-----------------------------------------------------------------------------------------------|
| `_id`                    | yes   | no        | must be provided in the URL, not the payload                                                  |
| `country_code`           | no    | yes       | must be a valid choice; the back-end automatically derives `country_name` from `country_code` |
| `canton`                 | no    | yes       | only mandatory if `"level":"subnational"`                                                     |
| `municipality`           | no    | yes       | only mandatory if `"level":"local"`                                                           |
| `level`                  | no    | yes       | must be a valid choice                                                                        |
| `date`                   | no    | yes       | must be a valid date (ISO 8601 date string)                                                   |
| `title.en`               | no    | yes       | contains `NA`s from before relaunch                                                           |
| `result`                 | no    | yes       | must be a valid choice ("Yes", "No" or "Unknown")                                             |
| `context.recommendation` | no    | yes       | only mandatory if `"country_code":"CH","level":"national"`; must be a valid choice            |
| `total_electorate`       | no    | yes       | must be a valid integer                                                                       |
| `citizens_abroad`        | no    | no        | omitting it in additions leads to serious problems (cf. GH issue #50)                         |
| `votes_yes`              | no    | no        | omitting it in additions leads to serious problems (cf. GH issue #50)                         |
| `votes_no`               | no    | no        | omitting it in additions leads to serious problems (cf. GH issue #50)                         |
| `votes_empty`            | no    | no        | omitting it in additions leads to serious problems (cf. GH issue #50)                         |
| `votes_invalid`          | no    | no        | omitting it in additions leads to serious problems (cf. GH issue #50)                         |
| `draft`                  | yes   | no        | defaults to `true` if not provided for additions                                              |
| `institution`            | no    | yes       | must be a valid choice                                                                        |

Based on the above, we define the fields that must always be present in the JSON payload when adding/editing referendums as follows:

```{r}
referendum_fields$required_for_edits <- c("draft")

referendum_fields$required_for_additions <- c("country_code",
                                              "level",
                                              "date",
                                              "title.en",
                                              "result",
                                              "total_electorate",
                                              "citizens_abroad",
                                              "votes_yes",
                                              "votes_no",
                                              "votes_empty",
                                              "votes_invalid",
                                              "draft",
                                              "institution")
```

#### Never empty

The following fields are expected to never be empty when returned by the API.

```{r}
referendum_fields$never_empty <- c("_id",
                                   "country_code",
                                   "country_name",
                                   "created_on",
                                   "level",
                                   "total_electorate",
                                   "citizens_abroad",
                                   "votes_yes",
                                   "votes_no",
                                   "votes_empty",
                                   "votes_invalid",
                                   "draft")
```

### ISO 3166

```{r}
data_iso_3166_3 <-
  ISOcodes::ISO_3166_3 %>%
  tibble::as_tibble() %>%
  dplyr::mutate(Alpha_2 = Alpha_4 %>% stringr::str_sub(end = 2L),
                Alpha_2_New = Alpha_4 %>% stringr::str_sub(start = 3L),
                Date_withdrawn =
                  Date_withdrawn %>%
                  lubridate::parse_date_time2(orders = c("%Y-%m-%d", "%Y")) %>%
                  lubridate::as_date()) %>%
  dplyr::relocate(Alpha_2, Alpha_2_New,
                  .after = Alpha_3)
```

### Messages

```{r}
mime_error_suffix <- "This indicates either some network issue or a change in the C2D API."
```

### sudd.ch years

```{r}
sudd_years <-
  xml2::read_html("https://sudd.ch/index.php") %>%
  rvest::html_element(css = "select[id='first']") %>%
  rvest::html_elements("option") %>% rvest::html_attr("value") %>%
  as.integer()

sudd_max_year <- pal::safe_max(sudd_years)
sudd_min_year <- pal::safe_min(sudd_years)
rm(sudd_years)
```

### Variable renamings

This maps the field names of the back-end's MongoDB to the final variable names as found in the [C2D codebook](https://rpkg.dev/c2d/articles/codebook.html). The
renamings should eventually all be upstreamed and this mapping shall become superfluous.

```{r}
                # old name                                               new name
v_names <- list("_id"                                                  = "id",
                "canton"                                               = "subnational_entity_name",
                "title.de"                                             = "title_de",
                "title.en"                                             = "title_en",
                "title.fr"                                             = "title_fr",
                "context.states_no"                                    = "subterritories_no",
                "context.states_yes"                                   = "subterritories_yes",
                "total_electorate"                                     = "electorate_total",
                "citizens_abroad"                                      = "electorate_abroad",
                "context.votes_per_canton"                             = "votes_per_subterritory",
                "context.national_council_yes"                         = "lower_house_yes",
                "context.national_council_no"                          = "lower_house_no",
                "context.national_council_abstentions"                 = "lower_house_abstentions",
                "context.states_council_yes"                           = "upper_house_yes",
                "context.states_council_no"                            = "upper_house_no",
                "context.states_council_abstentions"                   = "upper_house_abstentions",
                "context.recommendation"                               = "position_government",
                "draft"                                                = "is_draft",
                "created_on"                                           = "date_time_created",
                "institution"                                          = "type",
                "categories.official_status"                           = "inst_legal_basis_type",
                "categories.legal_act_type"                            = "inst_has_urgent_legal_basis",
                "categories.vote_result_status"                        = "inst_is_binding",
                "categories.counter_proposal"                          = "inst_is_counter_proposal",
                "categories.vote_venue"                                = "inst_is_assembly",
                "categories.vote_trigger"                              = "inst_trigger_type",
                "categories.vote_trigger_actor"                        = "inst_trigger_actor",
                "categories.vote_trigger_state_level"                  = "inst_trigger_actor_level",
                "categories.vote_trigger_number"                       = "inst_trigger_threshold",
                "categories.vote_trigger_time"                         = "inst_trigger_time_limit",
                "categories.vote_object"                               = "inst_object_type",
                "categories.author_of_the_vote_object"                 = "inst_object_author",
                "categories.hierarchy_of_the_legal_norm"               = "inst_object_legal_level",
                "categories.degree_of_revision"                        = "inst_object_revision_extent",
                "categories.action"                                    = "inst_object_revision_modes",
                "categories.referendum_text_options"                   = "inst_object_revision_divisibility",
                "categories.turnout_quorum"                            = "inst_quorum_turnout",
                "categories.decision_quorum"                           = "inst_quorum_approval",
                "categories.institutional_precondition"                = "inst_has_precondition",
                "categories.institutional_precondition_decision_actor" = "inst_precondition_actor",
                "categories.institutional_precondition_decision"       = "inst_precondition_decision",
                "categories.special_topics"                            = "inst_topics_only",
                "categories.excluded_topics"                           = "inst_topics_excluded")

                                 # old name     new name
sub_v_names <- list(files = list("date"       = "date_time_attached",
                                 "object_key" = "s3_object_key",
                                 "size"       = "file_size",
                                 "deleted"    = "is_deleted"))
```

## Data

The R code chunks below are *not* included in the [source package](https://r-pkgs.org/package-structure-state.html#source-package) (`purl = FALSE`). The chunks
have to be executed at least once to generate the necessary internal data file [`R/sysdata.rda`](https://r-pkgs.org/data.html#data-sysdata).

### `data_codebook`

TODO: Once the toml\* package is finished, use it instead to do the stuff below more generically.

```{r, purl = FALSE}
data_codebook <- {
  
  pal::assert_pkg("assertr")
  codebook <- c2d:::read_toml("data-raw/c2d_codebook.toml")
  
  c(codebook$`01_main`$item,
    codebook$`02_institutional`$`01_status`$item,
    codebook$`02_institutional`$`02_trigger`$item,
    codebook$`02_institutional`$`03_object`$item,
    codebook$`02_institutional`$`04_other`$item) %>%
    purrr::map_dfr(~ tibble::tibble(variable_name = .x$variable_name %||% NA_character_,
                                    variable_label = .x$variable_label %||% NA_character_,
                                    is_multi_valued = .x$is_multi_valued %||% FALSE,
                                    applicability_constraint = .x$applicability_constraint %||% NA_character_,
                                    variable_values = list(.x$variable_values) %||% list(character()),
                                    value_label_prefix = .x$value_label_prefix %||% NA_character_,
                                    value_labels = list(.x$value_labels) %||% list(character()),
                                    value_label_suffix = .x$value_label_suffix %||% NA_character_,
                                    value_default = list(.x$value_default) %||% list(character()),
                                    value_scale = .x$value_scale %||% NA_character_)) %>%
    # integrity checks
    assertr::assert(predicate = assertr::not_na,
                    variable_name,
                    variable_label,
                    value_scale,
                    is_multi_valued)
}
```

### `data_tags`

```{r, purl = FALSE}
data_tags <-
  # download file from private CCM Design repo
  pal::gh_text_file(owner = "ccmdesign",
                    name = "c2d-app",
                    rev = "master",
                    path = "ch.c2d/web/themes.json") %>%
  jsonlite::fromJSON(flatten = FALSE) %>%
  tibble::as_tibble() %>%
  # create tidy data version
  dplyr::rename(tag_tier_1 = name,
                tag_tier_2 = children) %>%
  tidyr::unnest_longer(col = tag_tier_2) %$%
  dplyr::bind_cols(tag_tier_1 = tag_tier_1,
                   tag_tier_2) %>%
  dplyr::rename(tag_tier_2 = name,
                tag_tier_3 = children) %>%
  # ensure consistent col subtypes
  dplyr::mutate(tag_tier_3 = tag_tier_3 %>% purrr::map(~ { if (is.list(.x)) character() else .x })) %>%
  tidyr::unnest_longer(col = tag_tier_3)
```

### `months_de`

```{r, purl = FALSE}
pal::assert_pkg("clock")

months_de <-
  1:12 %>%
  magrittr::set_names(clock::clock_labels_lookup("de")$month) %>%
  as.list()
```

### `var_lbls`

NOTES:

-   `var_lbls` is assigned here because when inlined, it somehow breaks `devtools::run_examples()` during pkg check ("C stack usage (...) is too close to the
    limit"); maybe too large fn stack? (modifying `pal::strip_md()` to minimize the fn stack was tried but didn't help)

```{r, purl = FALSE}
var_lbls <-
  data_codebook$variable_label %>%
  pal::strip_md() %>%
  as.list() %>%
  magrittr::set_names(value = data_codebook$variable_name)
```

Finally, we have to save all the external data objects to `data/*.RData` as well as the internal data objects to `R/sysdata.rda`.

Note that `data_codebook` is saved as internal data and later exported because external data doesn't support `@aliases`.

```{r, purl = FALSE}
usethis::use_data(data_codebook,
                  data_tags,
                  months_de,
                  var_lbls,
                  internal = TRUE,
                  overwrite = TRUE,
                  compress = "xz",
                  version = 3L)
```

# EXPORTED

## Referendum data

### `referendums`

```{r}
#' Get referendum data
#'
#' Downloads the referendum data from the C2D Database. See the [`codebook`][codebook] for a detailed description of all variables.
#'
#' @inheritParams assemble_query_filter
#' @inheritParams tidy_referendums
#' @param incl_archive Whether or not to include an `archive` column containing data from an earlier, obsolete state of the C2D database.
#' @param use_cache `r pkgsnip::param_label("use_cache")`
#' @param cache_lifespan `r pkgsnip::param_label("cache_lifespan")`
#'
#' @return `r pkgsnip::return_label("data")`
#' @family referendum
#' @export
#'
#' @examples
#' \dontrun{
#' # get all referendums (excl. drafts)
#' c2d::referendums()}
#' 
#' # get only referendums in Austria and Australia on subnational level
#' c2d::referendums(country_code = c("AT", "AU"),
#'                  level = "subnational")
#' 
#' # provide custom `query_filter` for more complex queries like regex matches
#' # cf. https://docs.mongodb.com/manual/reference/operator/query/regex/
#' c2d::referendums(query_filter = '{"country_code":{"$regex":"A."}}')
referendums <- function(country_code = NULL,
                        subnational_entity_name = NULL,
                        municipality = NULL,
                        level = NULL,
                        type = NULL,
                        date = NULL,
                        is_draft = FALSE,
                        date_time_created_min = NULL,
                        date_time_created_max = NULL,
                        query_filter = NULL,
                        incl_archive = FALSE,
                        tidy = TRUE,
                        use_cache = TRUE,
                        cache_lifespan = "1 week") {
  
  checkmate::assert_flag(incl_archive)
  
  result <- pkgpins::with_cache(expr = {
    
    status_msg <- "Fetching JSON data from C2D API..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    data <-
      httr::RETRY(verb = "GET",
                  url = "https://services.c2d.ch/referendums",
                  httr::progress(type = "down"),
                  query = list(mode = "stream",
                               format = "json",
                               filter = assemble_query_filter(country_code = country_code,
                                                              subnational_entity_name = subnational_entity_name,
                                                              municipality = municipality,
                                                              level = level,
                                                              type = type,
                                                              date = date,
                                                              is_draft = is_draft,
                                                              date_time_created_min = date_time_created_min,
                                                              date_time_created_max = date_time_created_max,
                                                              query_filter = query_filter)),
                  times = 5L) %>%
      # ensure we actually got a JSON response
      pal::assert_mime_type(mime_type = "application/json",
                            msg_suffix = mime_error_suffix) %>%
      # extract JSON
      httr::content(as = "text",
                    encoding = "UTF-8")
    
    status_msg <- "Converting JSON to list data..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    # NOTE that we cannot rely on params `simplify*` and `flatten` because of varying field lengths in API result (depending on `query`)
    data %<>%
      jsonlite::fromJSON(simplifyVector = FALSE,
                         simplifyDataFrame = FALSE,
                         simplifyMatrix = FALSE,
                         flatten = FALSE) %$%
      items
    
    status_msg <- "Tidying data..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    data %>% tidy_referendums(tidy = tidy)
  },
  pkg = this_pkg,
  from_fn = "referendums",
  country_code,
  subnational_entity_name,
  municipality,
  level,
  type,
  date,
  is_draft,
  date_time_created_min,
  date_time_created_max,
  query_filter,
  tidy,
  use_cache = use_cache,
  cache_lifespan = cache_lifespan)
  
  # exclude `archive` if requested
  if (!incl_archive) result %<>% dplyr::select(-any_of("archive"))
  
  result
}
```

### `referendum`

```{r}
#' Get a single referendum's data
#'
#' Downloads a single referendum's data from the C2D Database. See the [`codebook`][codebook] for a detailed description of all variables.
#'
#' @param id The referendum's unique [identifier](https://rpkg.dev/c2d/articles/codebook.html#id).
#' @inheritParams referendums
#'
#' @inherit referendums return
#' @family referendum
#' @export
#'
#' @examples
#' c2d::referendum(id = "5bbbe26a92a21351232dd73f")
referendum <- function(id,
                       incl_archive = FALSE,
                       tidy = TRUE) {
  
  checkmate::assert_string(id,
                           min.chars = 1L)
  checkmate::assert_flag(incl_archive)
  checkmate::assert_flag(tidy)
  
  # retrieve data
  data <-
    httr::RETRY(verb = "GET",
                url = paste0("https://services.c2d.ch/referendums/", id),
                times = 5L) %>%
    # ensure we actually got a JSON response
    pal::assert_mime_type(mime_type = "application/json",
                          msg_suffix = mime_error_suffix) %>%
    # extract JSON
    httr::content(as = "text",
                  encoding = "UTF-8") %>%
    # convert JSON to list
    # NOTE that we cannot rely on params `simplify*` and `flatten` because of varying field lengths in API result
    jsonlite::fromJSON(simplifyVector = FALSE,
                       simplifyDataFrame = FALSE,
                       simplifyMatrix = FALSE,
                       flatten = FALSE) %>%
    # tidy data
    tidy_referendums(tidy = tidy)
  
  # exclude `archive` if requested
  if (!incl_archive) data %<>% dplyr::select(-any_of("archive"))
  
  # return data
  data
}
```

### `download_file_attachment`

```{r}
#' Download file attachment
#'
#' Downloads a file attachment from the C2D database. The necessary `s3_object_key`s identifying individual files are found in the `files` list column returned
#' by [referendums()].
#'
#' @param s3_object_key The key uniquely identifying the file in the C2D [Amazon S3 bucket](https://en.wikipedia.org/wiki/Amazon_S3#Design). A character scalar.
#' @param path The path where the downloaded file is written to. If a directory, the original filename returned by the C2D services API will be used.
#'
#' @return A [response object][httr::response], invisibly.
#' @family referendum
#' @export
#'
#' @examples
#' \dontrun{
#' # get all file object keys...
#' c2d::referendums()$files |>
#'   purrr::map_depth(2L, purrr::pluck, "s3_object_key") |>
#'   purrr::flatten() |>
#'   purrr::flatten_chr() |>
#'   # ...select first three keys...
#'   magrittr::extract(1:3) |>
#'   # ...and download the corresponding files to the current working dir
#'   purrr::walk(c2d::download_file_attachment)}
download_file_attachment <- function(s3_object_key,
                                     path = ".") {
  
  checkmate::assert_string(s3_object_key)
  checkmate::assert_atomic(path)
  
  if (fs::dir_exists(path)) {
    checkmate::assert_directory(path,
                                access = "rw")
    use_original_filename <- TRUE
  } else {
    checkmate::assert_path_for_output(path,
                                      overwrite = TRUE)
    use_original_filename <- FALSE
  }
  
  temp_path <- fs::file_temp()
  
  response <- httr::RETRY(verb = "GET",
                          url = paste0("https://services.c2d.ch/s3_objects/", s3_object_key),
                          httr::write_disk(path = temp_path),
                          times = 5L)
  
  if (use_original_filename) {
    
    final_path <-
      response %>%
      httr::headers() %$%
      `content-disposition` %>%
      stringr::str_extract(pattern = "(?<=filename=\").+?(?=\")") %>%
      fs::path(path, .)
    
  } else {
    final_path <- path
  }
  
  fs::file_move(path = temp_path,
                new_path = final_path)
  
  invisible(response)
}
```

### `add_referendums`

NOTES:

-   For additions, the following JSON fields are mandatory:

    | field                    | notes                                                                                                             |
    |--------------------------|-------------------------------------------------------------------------------------------------------------------|
    | `country_code`           | must be a valid choice                                                                                            |
    | `canton`                 | only mandatory if `"level":"subnational"`                                                                         |
    | `municipality`           | only mandatory if `"level":"local"`                                                                               |
    | `level`                  | must be a valid choice                                                                                            |
    | `date`                   | must be a valid date (ISO 8601 date string)                                                                       |
    | `institution`            | must be a valid choice                                                                                            |
    | `title.en`               | must contain at least one non-whitespace character                                                                |
    | `result`                 | must be a valid choice ("Yes", "No" or "Unknown")                                                                 |
    | `context.recommendation` | only mandatory if `"country_code":"CH","level":"national"`; must be a valid choice                                |
    | `total_electorate`       | must be a valid integer                                                                                           |
    | `citizens_abroad`        | not actually mandatory, but [serious problems arise when omitted](https://github.com/ccmdesign/c2d-app/issues/50) |
    | `votes_yes`              | not actually mandatory, but [serious problems arise when omitted](https://github.com/ccmdesign/c2d-app/issues/50) |
    | `votes_no`               | not actually mandatory, but [serious problems arise when omitted](https://github.com/ccmdesign/c2d-app/issues/50) |
    | `votes_empty`            | not actually mandatory, but [serious problems arise when omitted](https://github.com/ccmdesign/c2d-app/issues/50) |
    | `votes_invalid`          | not actually mandatory, but [serious problems arise when omitted](https://github.com/ccmdesign/c2d-app/issues/50) |

-   If `draft` is not provided, it defaults to `true`.

-   Nested fields like `categories` can be partially provided.

-   `country_name` is ignored and automatically derived from `country_code`.

-   The `context.*` fields are ignored unless `"country_code":"CH","level":"national"`, cf. [issue #52](https://github.com/ccmdesign/c2d-app/issues/52).

-   The order of the JSON fields doesn't matter.

-   The API performs input validation on certain fields, and if it fails, it responds with a message like:

    ``` json
    {"error": {"id": "validation_failed", "value": {"categories.author_of_the_vote_object": "invalid"}}}
    ```

-   A minimal sample cURL request to add a test entry looks as follows:

    ``` curl
    curl 'https://services.c2d.ch/referendums' \
         --request POST \
         --header 'Content-Type: application/json' \
         --header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1YzhiYTE3ZDYxYWY4NDYyMmRkZThjNjEiLCJleHAiOjE2MzAxODY0ODB9.lpKWUPyYh7yGWN1AKBWkjhrsQIVeIH71DUOA4hpJhR8' \
         --data-raw $'{"title":{"en":"test test test"},"date":"2222-02-22","level":"national","country_code":"AT","institution":"Citizens\' initiative","votes_no":-1,"votes_yes":-1,"votes_empty":-1,"votes_invalid":-1,"total_electorate":-1,"citizens_abroad":-1,"result":"Unknown"}'
    ```

```{r}
#' Add new referendums to the C2D database
#'
#' Adds new referendum entries to the C2D database via [its API](https://github.com/ccmdesign/c2d-app/blob/master/docs/services.md#3-referendum-routes).
#'
#' @details
#' Note that the following variables are not supported, i.e. simply dropped from `data`:
#' - `id_official`
#' - `id_sudd`
#' - `files`
#'
#' @param data The new referendum data. A [tibble][tibble::tbl_df] that in any case must contain the columns
#' `r referendum_fields$required_for_additions %>% dplyr::recode(!!!v_names) %>% paste0("[\x60", ., "\x60](https://rpkg.dev/c2d/articles/codebook.html#", ., ")") %>% pal::as_md_list()`
#'   
#' plus the column [`subnational_entity_name`](https://rpkg.dev/c2d/articles/codebook.html#subnational_entity_name) for referendums of
#' [`level`](https://rpkg.dev/c2d/articles/codebook.html#subnational_entity_name) below `"national"`, and the column
#' [`municipality`](https://rpkg.dev/c2d/articles/codebook.html#municipality) for referendums of `level = "local"`,
#'   
#' plus any additional [valid][codebook] columns containing the values for the corresponding database fields.
#' @param email The e-mail address of the C2D API user account to be used for authentication. A character scalar.
#' @param password The password of the C2D API user account to be used for authentication. A character scalar.
#'
#' @return `data`, invisibly.
#' @family referendum
#' @export
add_referendums <- function(data,
                            email = names(getOption("c2d.credentials")[1L]),
                            password = getOption("c2d.credentials")[1L]) {
  # ensure `data` is valid
  checkmate::assert_data_frame(data,
                               min.rows = 1L)
  
  ## ensure forbidden columns are absent
  if ("id" %in% colnames(data)) {
    cli::cli_abort(paste0("{.arg data} mustn't contain an {.var id} column. It is automatically set by the C2D API back-end. Did you mean to {.fun ",
                          "edit_referendums} instead?"))
  }
  if ("created_on" %in% colnames(data)) {
    cli::cli_abort("{.arg data} mustn't contain a {.var created_on} column. This date is automatically set by the C2D API back-end.")
  }
  if ("country_name" %in% colnames(data)) {
    cli::cli_abort("{.arg data} mustn't contain a {.var country_name} column. It is automatically set by the C2D API back-end based on {.var country_code}.")
  }
  
  ## ensure mandatory columns are present
  referendum_fields$required_for_additions %>%
    dplyr::recode(!!!v_names) %>%
    purrr::walk(~ if (!(.x %in% colnames(data))) cli::cli_abort(paste0("Mandatory column {.var ", .x, "} is missing from {.arg data}.")))
  
  ## ensure columns are valid
  assert_cols_valid(data)
  
  # drop disabled variables
  data %<>% drop_disabled_vx(to_drop = c("id_official",
                                         "id_sudd",
                                         "files"))
  # convert data to MongoDB schema
  json_items <-
    data %>%
    # restore MongoDB fields
    untidy_referendums() %>%
    # convert to JSON
    purrr::map(jsonlite::toJSON,
               auto_unbox = TRUE,
               digits = NA)
  
  # add data to the MongoDB via HTTP POST on `/referendums` API endpoint
  responses <-
    json_items %>%
    purrr::map(~ httr::RETRY(verb = "POST",
                             url = "https://services.c2d.ch/referendums",
                             config = httr::add_headers(Authorization = paste("Bearer", auth_session(email = email,
                                                                                                     password = password)),
                                                        Connection = "keep-alive"),
                             body = .x,
                             times = 3L,
                             httr::content_type_json()) %>%
                 # ensure we actually got a JSON response
                 pal::assert_mime_type(mime_type = "application/json",
                                       msg_suffix = mime_error_suffix) %>%
                 # extract JSON string
                 httr::content(as = "text",
                               encoding = "UTF-8"))
  
  # throw warnings for unsuccessful API calls
  purrr::walk2(.x = seq_along(responses),
               .y = responses,
               .f = ~ if (!isTRUE(jsonlite::fromJSON(.y)$ok)) {
                 cli::cli_warn("Failed to add the {.x}. referendum. The API server responded with error {.field {.y}}.")
               })
  
  invisible(data)
}
```

### `edit_referendums`

NOTES:

-   For edits, the only mandatory JSON field is `draft`. Only the fields that are supposed to change need to be supplied. Nested fields like `categories` can be
    partially overwritten, too.

-   `country_name` is ignored and automatically derived from `country_code`.

-   The `context.*` fields are ignored unless `"country_code":"CH","level":"national"`, cf. [issue #52](https://github.com/ccmdesign/c2d-app/issues/52).

-   The order of the JSON fields doesn't matter.

-   The API performs input validation on certain fields, and if it fails, it responds with a message like:

    ``` json
    {"error": {"id": "validation_failed", "value": {"categories.author_of_the_vote_object": "invalid"}}}
    ```

-   A minimal sample cURL request to change a test entry looks as follows:

    ``` sh
    curl 'https://services.c2d.ch/referendums/610005e2c72633da60229938' \
         --request PUT \
         --header 'Content-Type: application/json' \
         --header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1YzhiYTE3ZDYxYWY4NDYyMmRkZThjNjEiLCJleHAiOjE2MzAxODY0ODB9.lpKWUPyYh7yGWN1AKBWkjhrsQIVeIH71DUOA4hpJhR8' \
         --header 'Connection: keep-alive' \
         --data-raw $'{"draft":true,"title":{"de":"salims cat test"}}'
    ```

```{r}
#' Edit existing referendums in the C2D database
#'
#' Edits existing referendum entries in the C2D database via [its API](https://github.com/ccmdesign/c2d-app/blob/master/docs/services.md#3-referendum-routes).
#'
#' @inherit add_referendums details
#' @param data The updated referendum data. A [tibble][tibble::tbl_df] that must contain an [`id`](https://rpkg.dev/c2d/articles/codebook.html#id) column 
#'   identifying the referendums to be edited, an [`is_draft`](https://rpkg.dev/c2d/articles/codebook.html#is_draft) column setting their updated draft status,
#'   plus a [valid][codebook] column containing the new values for each additional database field that should be updated.
#' @inheritParams add_referendums
#'
#' @inherit add_referendums return
#' @family referendum
#' @export
edit_referendums <- function(data,
                             email = names(getOption("c2d.credentials")[1L]),
                             password = getOption("c2d.credentials")[1L]) {
  # ensure `data` is valid
  checkmate::assert_data_frame(data,
                               min.rows = 1L)
  
  ## ensure forbidden columns are absent
  if ("created_on" %in% colnames(data)) {
    cli::cli_abort(paste0("{.arg data} mustn't contain a {.var created_on} column. This date is automatically set by the C2D API back-end and not supposed to ",
                          "be changed."))
  }
  if ("country_name" %in% colnames(data)) {
    cli::cli_abort("{.arg data} mustn't contain a {.var country_name} column. It is automatically set by the C2D API back-end based on {.var country_code}.")
  }
  
  ## ensure mandatory columns are present
  referendum_fields$required_for_edits %>%
    dplyr::recode(!!!v_names) %>%
    c("id") %>%
    purrr::walk(~ if (!(.x %in% colnames(data))) cli::cli_abort(paste0("Mandatory column {.var ", .x, "} is missing from {.arg data}.")))
  
  ## ensure columns are valid
  assert_cols_valid(data)
  
  # drop disabled variables
  data %<>% drop_disabled_vx(to_drop = c("id_official",
                                         "id_sudd",
                                         "files"))
  # convert data to MongoDB schema
  ids <- data$id
  
  json_items <-
    data %>%
    # drop `id`
    dplyr::select(-id) %>%
    # restore MongoDB fields
    untidy_referendums() %>%
    # convert to JSON
    purrr::map(jsonlite::toJSON,
               auto_unbox = TRUE,
               digits = NA)
  
  # edit data in the MongoDB via HTTP PUT on `/referendums` API endpoint
  responses <- purrr::map2(.x = ids,
                           .y = json_items,
                           .f = ~
                             httr::RETRY(verb = "PUT",
                                         url = paste0("https://services.c2d.ch/referendums/",.x),
                                         config = httr::add_headers(Authorization = paste("Bearer", auth_session(email = email,
                                                                                                                 password = password)),
                                                                    Connection = "keep-alive"),
                                         body = .y,
                                         times = 3L,
                                         httr::content_type_json()) %>%
                             # ensure we actually got a JSON response
                             pal::assert_mime_type(mime_type = "application/json",
                                                   msg_suffix = mime_error_suffix) %>%
                             # extract JSON string
                             httr::content(as = "text",
                                           encoding = "UTF-8"))
  
  # throw warnings for unsuccessful API calls
  purrr::walk2(.x = ids,
               .y = responses,
               .f = ~ if (!isTRUE(jsonlite::fromJSON(.y)$ok)) {
                 cli::cli_warn("Failed to edit referendum with {.var id} {.val {.x}}. The API server responded with {.field {.y}}.")
               })
  
  invisible(data)
}
```

### `validate_referendums`

This function performs various data validation steps to ensure there are no errors in the database.

```{r}
#' Validate referendum data
#'
#' @param data The referendum data to validate, as returned by [referendums()].
#' @param check_applicability_constraint Whether or not to check that no applicability constraints as defined in the [codebook][data_codebook] are violated.
#' @param check_id_sudd_prefix Whether or not to check that all [`id_sudd`](https://rpkg.dev/c2d/articles/codebook.html#id-sudd) prefixes are valid.
#'
#' @return `data`, invisibly.
#' @family referendum
#' @export
validate_referendums <- function(data,
                                 check_applicability_constraint = TRUE,
                                 check_id_sudd_prefix = TRUE) {
  
  checkmate::assert_data_frame(data,
                               min.rows = 1L)
  checkmate::assert_subset(colnames(data),
                           choices = data_codebook$variable_name)
  checkmate::assert_flag(check_applicability_constraint)
  checkmate::assert_flag(check_id_sudd_prefix)
  
  # check columns
  status_msg <- "Checking basic column validity..."
  cli_progress_id <- cli::cli_progress_step(msg = status_msg,
                                            msg_done = paste(status_msg, "done"),
                                            msg_failed = paste(status_msg, "failed"))
  
  assert_cols_valid(data = data,
                    action = cli::cli_alert_warning,
                    cli_progress_id = cli_progress_id)
  
  # check applicability constraints
  if (check_applicability_constraint) {
    
    status_msg <- "Asserting applicability constraints..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    v_names_violated <-
      data_codebook %>%
      dplyr::filter(variable_name %in% colnames(data)
                    & !is.na(applicability_constraint)) %$%
      purrr::map2_lgl(.x = magrittr::set_names(x = variable_name,
                                               value = variable_name),
                      .y = applicability_constraint,
                      .f = ~ {
                        
                        data %>%
                          dplyr::filter(!eval(parse(text = .y))) %$%
                          eval(as.symbol(.x)) %>%
                          {is.na(.) | purrr::map_lgl(., is.null)} %>%
                          all()
                      }) %>%
    magrittr::extract(. %in% FALSE) %>%
    names()
    
    n_v_names_violated <- length(v_names_violated)
    
    if (n_v_names_violated) {
      
      cli::cli_progress_done(result = "failed")
      cli::cli_alert_warning("Applicability constraints are violated for {n_v_names_violated} variable{?s}:")
      
      paste0("{.var ", v_names_violated, "}") %>%
        magrittr::set_names(rep("x",
                                times = length(.))) %>%
        cli::cli_bullets()
      
      first_v_name_violated <- v_names_violated[1L]
      
      cli::cli({
        cli::cli_text("\nTo get the applicability constraint of e.g. {.var {first_v_name_violated}}, run:")
        cli::cli_text("")
        cli::cli_code(c("data_codebook %>%",
                        glue::glue("  dplyr::filter(variable_name == \"{first_v_name_violated}\") %$%"),
                        "  applicability_constraint"))
        cli::cli_text("")
        cli::cli_text("To inspect the entries in violation of the above applicability constraint, run:")
        cli::cli_text("")
        cli::cli_code(c("data_codebook %>%",
                        glue::glue("  dplyr::filter(variable_name == \"{first_v_name_violated}\") %$%"),
                        "  dplyr::filter(.data = data,",
                        "                !eval(parse(text = applicability_constraint))) %$%",
                        glue::glue("  {first_v_name_violated}")))
      })
    }
  }
  
  # check `id_sudd` prefix if requested
  if (check_id_sudd_prefix) {
    
    status_msg <- "Validating `id_sudd` prefixes..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    if (!all(c("country_code", "id_sudd") %in% colnames(data))) {
      cli::cli_progress_done(result = "failed")
      cli::cli_abort("Columns {.var country_code} and {.var id_sudd} must be present in {.arg data}.")
    }
    
    # define allowed exceptions
    allowed_exceptions <- tibble::tribble(
      ~country_code, ~id_sudd_prefix,
      # Curacao
      "CW", "an",
      # Szeklerland, cf. https://sudd.ch/event.php?id=hu042008
      "RO", "hu"
    )
    
    # assemble target country codes
    country_codes <-
      data$country_code %>%
      as.character() %>%
      as.list()
    
    for (country_code in allowed_exceptions$country_code) {
      
      additional_country_codes <-
        allowed_exceptions %>%
        dplyr::filter(country_code == !!country_code) %$%
        id_sudd_prefix %>%
        stringr::str_to_upper()
      
      i_country_codes <- country_codes %>% purrr::map_lgl(~ country_code %in% .x) %>% which()
      
      for (i in i_country_codes) {
        country_codes[[i]] <- unique(c(country_codes[[i]], additional_country_codes))
      }
    }
    
    # add dummy indicating if target country codes match
    # TODO: instead of modifying input data, print cli msg with all relevant info!
    data$matches_id_sudd_prefix <-
      data$id_sudd %>%
      stringr::str_extract(pattern = "^..") %>%
      stringr::str_to_upper() %>%
      purrr::map2_lgl(.y = country_codes,
                      .f = ~ .x %in% .y)
    
    data$matches_id_sudd_prefix[is.na(data$id_sudd)] <- NA
  }
  
  invisible(data)
}
```

### `count_referendums`

```{r}
#' Count number of referendums
#'
#' Counts the number of referendums per [`level`](https://rpkg.dev/c2d/articles/codebook.html#level) in the C2D Database.
#'
#' @inheritParams assemble_query_filter
#'
#' @return A named list with `level` as names and referendum counts as values.
#' @family referendum
#' @export
#'
#' @examples
#' # the whole database (excl. drafts)
#' c2d::count_referendums()
#' 
#' # only Swiss and Austrian referendums
#' c2d::count_referendums(country_code = c("CH", "AT"))
#' 
#' # only Swiss referendums created between 2020 and 2021
#' c2d::count_referendums(country_code = "CH",
#'                        date_time_created_min = "2020-01-01",
#'                        date_time_created_max = "2021-01-01")
count_referendums <- function(is_draft = FALSE,
                              country_code = NULL,
                              subnational_entity_name = NULL,
                              municipality = NULL,
                              level = NULL,
                              type = NULL,
                              date = NULL,
                              date_time_created_min = NULL,
                              date_time_created_max = NULL,
                              query_filter = NULL) {
  httr::RETRY(verb = "GET",
              url = "https://services.c2d.ch/referendums/stats",
              query = list(filter = assemble_query_filter(country_code = country_code,
                                                          subnational_entity_name = subnational_entity_name,
                                                          municipality = municipality,
                                                          level = level,
                                                          type = type,
                                                          date = date,
                                                          is_draft = is_draft,
                                                          date_time_created_min = date_time_created_min,
                                                          date_time_created_max = date_time_created_max,
                                                          query_filter = query_filter)),
              times = 5L) %>%
    # ensure we actually got a JSON response
    pal::assert_mime_type(mime_type = "application/json",
                          msg_suffix = mime_error_suffix) %>%
    # parse response
    httr::content(as = "parsed") %$%
    votes %>%
    magrittr::set_names(names(.) %>% dplyr::recode("sub_national" = "subnational"))
}
```

### !`search_referendums`

TODO: API Endpoint seems broken as of 2021-11-03. Either fix (and add a test) or remove the fn, cf. <https://github.com/ccmdesign/c2d-app/issues/62>

Currently, the C2D API [only supports searching in the English referendum
title](https://github.com/ccmdesign/c2d-app/blob/master/docs/services.md#3-referendum-routes).

```{r, purl = FALSE}
#' Search in English referendum titles
#'
#' Allows to use the C2D API's primitive search functionality. The search is not case-sensitive and no [fuzzy
#' search](https://en.wikipedia.org/wiki/Approximate_string_matching) is performed (i.e. only exact matches are returned).
#'
#' Note that this function is probably not of much use since it doesn't return any additional information about the matched referendums but only the English
#' titles.
#'
#' @param term The Search term. A character scalar.
#'
#' @return A character vector of English referendum titles matching the search `term`.
#' @family referendum
#' @export
#'
#' @examples
#' c2d::search_referendums("freedom")
search_referendums <- function(term) {
  
  httr::RETRY(verb = "GET",
              url = "https://services.c2d.ch/referendums",
              query = list(mode = "search",
                           term = checkmate::assert_string(term)),
              times = 5L) %>%
    # ensure we actually got a JSON response
    pal::assert_mime_type(mime_type = "application/json",
                          msg_suffix = mime_error_suffix) %>%
    # parse response
    httr::content(as = "parsed") %$%
    items %>%
    purrr::flatten_chr() 
}
```

## Referendum metadata

### `data_codebook`

```{r}
#' C2D Codebook
#'
#' A tibble containing the complete metadata of all [referendums()] variables. The Codebook below is also available
#' [online](https://rpkg.dev/c2d/articles/codebook.html).
#'
#' @includeRmd vignettes/codebook.Rmd
#'
#' @format `r pkgsnip::return_label("data")`
#' @aliases codebook
#' @family metadata
#' @export
"data_codebook"
```

### `val_lbls`

```{r}
#' Get the set of possible *value labels* of a referendum data variable
#'
#' Returns a character vector of value labels of a specific [referendums()] column, in the same order as [v_vals()], or of length `0` if `v_name`'s values are
#' not restricted to a predefined set or no value labels are defined in the [codebook][data_codebook].
#'
#' @param v_name A variable name. Must be one of the column names of [`data_codebook`].
#' @param incl_affixes Whether or not to add the corresponding `value_label_prefix` and `value_label_suffix` to the returned labels.
#'
#' @return A character vector. Of length `0` if `v_name`'s values are not restricted to a predefined set or no value labels are defined in the
#'   [codebook][data_codebook].
#' @seealso [`data_codebook`][data_codebook]
#' @family metadata
#' @export
#'
#' @examples
#' c2d::val_lbls("result",
#'               incl_affixes = FALSE)
#' c2d::val_lbls("result")
#' 
#' # Convert the labels to sentence case with trailing dot
#' c2d::val_lbls("result") |> pal::sentenceify()
val_lbls <- function(v_name,
                     incl_affixes = TRUE) {
  v_name <- rlang::arg_match(arg = v_name,
                             values = data_codebook$variable_name)
  metadata <- data_codebook %>% dplyr::filter(variable_name == !!v_name)
  result <- metadata$value_labels %>% purrr::flatten_chr()
  
  if (incl_affixes) {
    if (!is.na(metadata$value_label_prefix)) result <- paste(metadata$value_label_prefix, result)
    if (!is.na(metadata$value_label_suffix)) result <- paste(metadata$value_label_suffix, result)
  }
  
  result
}
```

### `v_vals`

```{r}
#' Get the set of possible *values* of a referendum data variable
#'
#' Returns a vector of the possible predefined values a specific column in [referendums()] can hold. If the variable values aren't restricted to a predefined
#' set, `NULL` is returned.
#'
#' @param v_name A variable name. Must be one of the column names of [`data_codebook`].
#'
#' @return
#' If `v_name`'s values are restricted to a predefined set and
#' - `v_name` is *not* of type list, a vector of the same type as `v_name`.
#' - `v_name` is of type list, a vector of the same type as the elements of `v_name`.
#'
#' Else `NULL`.
#' @seealso [`data_codebook`][data_codebook]
#' @family metadata
#' @export
#'
#' @examples
#' v_vals("result")
#' v_vals("id")
v_vals <- function(v_name) {
  
  v_name <- rlang::arg_match(arg = v_name,
                             values = data_codebook$variable_name)
  data_codebook %>%
    dplyr::filter(variable_name == !!v_name) %$%
    variable_values %>%
    unlist()
}
```

## Tags

The tags classification was developped together with [Swissvotes](https://swissvotes.ch/), the [Institute of Federalism of the University of
Fribourg](https://www.unifr.ch/federalism/en/) and the [Section Politics of the Federal Statistical
Office](https://www.bfs.admin.ch/bfs/en/home/statistics/politics.html). Any modifications should be coordinated with these parties.

### DESCRIPTION

Functions to work with referendum [tags](https://rpkg.dev/c2d/articles/codebook.html#tags).

### `hierarchize_tags`

```{r}
#' Hierarchize Tags
#'
#' Reconstructs the hierarchical relations between the three tag variables `tags_tier_1`, `tags_tier_2` and `tags_tier_3`. Can also be used to simply determine
#' the parent tag(s) of any tag.
#'
#' @param x The tags to hierarchize. Either a character vector of tags or a single-row data frame containing at least the columns `tags_tier_1`, `tags_tier_2`
#'   and `tags_tier_3`.
#'
#' @return `r pkgsnip::param_label("data")`
#' @family tags
#' @export
#'
#' @examples
#' c2d::hierarchize_tags("territorial questions")
#'
#' # hierarchize the tags of all Austrian referendums
#' c2d::referendums(country_code = "AT") |>
#'   dplyr::group_split(id) |>
#'   purrr::map(c2d::hierarchize_tags)
hierarchize_tags <- function(x) {
  
  test_char <- checkmate::test_character(x, any.missing = FALSE)
  
  if (!test_char) {
    
    tag_v_names <- paste0("tags_tier_", 1:3)
    test_df <- checkmate::test_data_frame(x,
                                          min.rows = 1L,
                                          max.rows = 1L)
    has_tag_vars <- all(tag_v_names %in% colnames(x))
    
    if (!test_df || !has_tag_vars) {
      cli::cli_abort(paste0("{.arg x} must be either a character vector of tags or a single-row data frame containing at least the columns ",
                            "{.field tags_tier_1}, {.field tags_tier_2} and {.field tags_tier_3}."))
    }
    
    x %<>%
      .[, tag_v_names] %>%
      purrr::pmap(~ as.character(c(..1, ..2, ..3))) %>%
      purrr::flatten_chr()
  }
  
  checkmate::assert_subset(x,
                           choices = tags(),
                           empty.ok = TRUE,
                           .var.name = "tags")
  
  tags_tier_1 <- x[x %in% tags(tiers = 1L)]
  tags_tier_2 <- x[x %in% tags(tiers = 2L)]
  tags_tier_3 <- x[x %in% tags(tiers = 3L)]
  inferred_tags_tier_1 <- infer_tags(tags = c(tags_tier_2, tags_tier_3),
                                     tier = 1L)
  inferred_tags_tier_2 <- infer_tags(tags = tags_tier_3,
                                     tier = 2L)
  non_parent_tags_tier_1 <- tags_tier_1 %>% setdiff(inferred_tags_tier_1)
  non_parent_tags_tier_2 <- tags_tier_2 %>% setdiff(inferred_tags_tier_2)
  
  # 0. initialize empty tibble
  result <- tibble::tibble(tag_tier_1 = character(),
                           tag_tier_2 = character(),
                           tag_tier_3 = character())
  
  # 1. add third-tier tags
  result <-
    tags_tier_3 %>%
    purrr::map_dfr(~ tibble::tibble(tag_tier_1 = infer_tags(tags = .x,
                                                            tier = 1L),
                                    tag_tier_2 = infer_tags(tags = .x,
                                                            tier = 2L),
                                    tag_tier_3 = .x)) %>%
    dplyr::bind_rows(result)
  
  # 2. add remaining second-tier tags
  if (length(non_parent_tags_tier_2)) {
    
    result <-
      non_parent_tags_tier_2 %>%
      purrr::map_dfr(~ tibble::tibble(tag_tier_1 = infer_tags(tags = .x,
                                                              tier = 1L),
                                      tag_tier_2 = .x,
                                      tag_tier_3 = NA_character_)) %>%
      dplyr::bind_rows(result)
  }
  
  # 3. add remaining top-tier tags
  if (length(non_parent_tags_tier_1)) {
    
    result %<>% dplyr::bind_rows(tibble::tibble(tag_tier_1 = non_parent_tags_tier_1,
                                                tag_tier_2 = NA_character_,
                                                tag_tier_3 = NA_character_))
  }
  
  # sort result
  result %>% dplyr::arrange(tag_tier_1, tag_tier_2, tag_tier_3)
}
```

### `infer_tags`

```{r}
#' Infer higher-tier tags
#'
#' Determines the top-tier (`tier = 1L`) or second-tier (`tier = 2L`) tags that are the parents or grandparents of `tags` in the
#' [hierarchy](https://rpkg.dev/c2d/articles/codebook.html#tags).
#'
#' @param tags The tags to determine the corresponding (grand)parent tags of. A factor or character vector.
#' @param tier The tier of the inferred tags. Should be >= than the tier of the `tags`. An integer scalar.
#'
#' @return A character vector.
#' @family tags
#' @export
#'
#' @examples
#' c2d::infer_tags(tags = c("EU", "animal protection"),
#'                 tier = 1L)
#' c2d::infer_tags(tags = c("EU", "animal protection"),
#'                 tier = 2L)
#' 
#' # tags of different tiers can mixed in `tags`
#' c2d::infer_tags(tags = c("EU", "environment"),
#'                 tier = 2L)
#' 
#' # but `tags` of a higher tier than `tier` will be ignored
#' c2d::infer_tags(tags = "foreign policy",
#'                 tier = 2L)
infer_tags <- function(tags,
                       tier = 1L) {
  
  if (is.factor(tags)) tags <- as.character(tags)
  
  checkmate::assert_subset(tags,
                           choices = tags())
  checkmate::assert_int(tier,
                        lower = 1L,
                        upper = 2L)
  
  # inferred from lower-tier tags
  result <- data_tags[data_tags$tag_tier_2 %in% tags | data_tags$tag_tier_3 %in% tags, ]
  result %<>% .[[paste0("tag_tier_", tier)]]
  
  # plus top-tier tags
  if (tier == 1L) result %<>% c(tags[tags %in% tags(tiers = 1L)])
  
  unique(result)
}
```

## C2D API Status

### `is_online`

```{r}
#' Test C2D API availability
#'
#' Checks if the C2D API server is online and operational.
#'
#' @param quiet Whether or not to suppress printing a warning in case the API is unavailable.
#'
#' @return A logical scalar.
#' @family api_status
#' @export
is_online <- function(quiet = FALSE) {
  
  checkmate::assert_flag(quiet)
  result <- FALSE
  response <-
    rlang::with_handlers(.expr = httr::RETRY(verb = "GET",
                                             url = "https://services.c2d.ch/health",
                                             times = 5L),
                         error = ~ paste0("Error: ", .x$message)) %>%
    # ensure we actually got a plaintext response
    pal::assert_mime_type(mime_type = "text/plain",
                          msg_suffix = mime_error_suffix) %>%
    # parse response
    httr::content(as = "text",
                  encoding = "UTF-8")
  
  if (response == "OK") {
    result <- TRUE
    
  } else if (!quiet) {
    cli::cli_warn("C2D API server responded with: {.val {response}}")
  }
  
  result
}
```

## sudd.ch scraping

The [`list.php`](https://sudd.ch/list.php) endpoint supports

-   the following filtering URL parameters which can be combined arbitrarily:

    -   `sense`: the sorting order of the results; one of `desc` (descending) or `asc` (ascending)
    -   `area`: search the combined `territory_name_de` field; case-insensitive; partial (but no fuzzy) matching is supported
    -   `topic`: search the `title_de` field; case-insensitive; partial (but no fuzzy) matching is supported
    -   `first`/`last`: the minimum and maximum `date` years to include; an integer or `NaN` for no limitation; strangely, `last` and `first` can be
        interchanged, i.e. `last` can be lower than `first` (results stay the same)

-   a `mode` URL parameter for "special views" with the following possible values (filtering parameters are usually ignored when `mode` is provided):

    -   `allareas`: list all territories (`territory_name_de`) by country (`country_name_de`)
    -   `alltopics`: list all `title_de` values together with the number of referendums
    -   `allrefs`: ; list all referendums; supports the `sense` parameter
    -   `moddate`: list all referendums by `date_last_edited`
    -   `random`: list 5 randomly selected referendums

### DESCRIPTION

Functions to scrape the data from the [sudd.ch](https://sudd.ch/) database.

### `list_sudd_territories`

NOTES:

-   Unfortunately, we cannot sensibly determine if a subnational territory on sudd.ch is a subdivision like a province, i.e. a `subnational_entity_name_de`,
    *or* a `municipality_de`. There seems to be no semantic data included in any form which we could derive this from.

```{r}
#' List referendum territories from [sudd.ch](https://sudd.ch/)
#'
#' Lists [all referendum territories from sudd.ch](https://sudd.ch/list.php?mode=allareas), which means each `country_name_de` together with all the associated
#' `territory_name_de`, their search URL and their number of occurrences.
#'
#' Note that the values in the `territory_name_de` column returned by this function can differ from those in the `territory_name_de` column of
#' [sudd_referendums()] and [list_sudd_referendums()]. The latter is often more extensive and usually includes the `country_name_de` (in parentheses) for
#' subnational referendums.
#'
#' @inheritSection sudd_referendums About [sudd.ch](https://sudd.ch/)
#' @return `r pkgsnip::return_label("data")`
#' @family sudd
#' @export
list_sudd_territories <- function() {
  
  rows <-
    httr::RETRY(verb = "GET",
              url = "https://sudd.ch/list.php",
              query = list(mode = "allareas"),
              times = 5L) %>%
    xml2::read_html() %>%
    rvest::html_elements(css = "main table tr") %>%
    purrr::map(rvest::html_elements,
               css = "td")
  
  col_1 <- rows %>% purrr::map(magrittr::extract2, 1L)
  col_2 <- rows %>% purrr::map(~ { if (length(.x) > 1L) .x[[2L]] else xml2::as_xml_document(list()) })
  col_3 <- rows %>% purrr::map(~ { if (length(.x) > 2L) .x[[3L]] else xml2::as_xml_document(list()) })
  
  tibble::tibble(country_name_de = col_1 %>% purrr::map_chr(rvest::html_text),
                 territory_name_de = col_2 %>% purrr::map_chr(rvest::html_text),
                 filter_url = col_2 %>% purrr::map_chr(~ {
                   if (length(.x) > 0L) {
                     .x %>%
                       rvest::html_element(css = "a") %>%
                       rvest::html_attr(name = "href") %>%
                       complete_sudd_url()
                   } else {
                     NA_character_
                   }
                 }),
                 n = col_3 %>% purrr::map_chr(rvest::html_text)) %>%
    dplyr::mutate(country_name_de = dplyr::if_else(stringr::str_detect(string = country_name_de,
                                                                       pattern = "^\\s*$"),
                                                   NA_character_,
                                                   country_name_de)) %>%
    tidyr::fill(country_name_de,
                .direction = "down") %>%
    dplyr::filter(!dplyr::if_all(c(territory_name_de, n),
                                 is.na))
}
```

### `list_sudd_titles`

```{r}
#' List referendum titles from [sudd.ch](https://sudd.ch/)
#'
#' Lists [all referendum titles from sudd.ch](https://sudd.ch/list.php?mode=alltopics), together with their search URLs and number of occurrences.
#'_referendums()].
#'
#' @inheritSection sudd_referendums About [sudd.ch](https://sudd.ch/)
#' @return `r pkgsnip::return_label("data")`
#' @family sudd
#' @export
#'
#' @examples
#' c2d::list_sudd_titles() |> dplyr::filter(n > 1)
list_sudd_titles <- function() {
  
  rows <-
    httr::RETRY(verb = "GET",
              url = "https://sudd.ch/list.php",
              query = list(mode = "alltopics"),
              times = 5L) %>%
    xml2::read_html() %>%
    rvest::html_elements(css = "main table tr") %>%
    purrr::map(rvest::html_elements,
               css = "td")
  
  col_1 <- rows %>% purrr::map(magrittr::extract2, 1L)
  col_2 <- rows %>% purrr::map(magrittr::extract2, 2L)
  
  tibble::tibble(title_de = col_1 %>% purrr::map_chr(rvest::html_text),
                 filter_url = col_1 %>% purrr::map_chr(~ .x %>%
                                                         rvest::html_element(css = "a") %>%
                                                         rvest::html_attr(name = "href") %>%
                                                         complete_sudd_url()),
                 n = col_2 %>% purrr::map_chr(rvest::html_text))
}
```

### `list_sudd_referendums`

```{r}
#' List referendum data from [sudd.ch](https://sudd.ch/)
#'
#' @description
#' Lists the referendum data from [sudd.ch](https://sudd.ch/) in various ways its [`list.php`](https://sudd.ch/list.php) endpoint allows. The output of this
#' function can be directly fed to [sudd_referendums()].
#'
#' @inheritSection sudd_referendums About [sudd.ch](https://sudd.ch/)
#' @param mode The listing mode. One of
#' - `"by_date"`: Lists [all referendums in the sudd.ch database **by `date`**](https://sudd.ch/list.php?mode=allrefs), together with their `id_sudd`,
#'   `country_code`, `territory_name_de` and `title_de`. Specifying the sorting order of the results via the `order` parameter is supported.
#' - `"by_mod_date"`: Lists [all referendums in the sudd.ch database **by `date_last_edited`**](https://sudd.ch/list.php?mode=moddate), together with their
#'   `id_sudd`, `country_code`, `territory_name_de`, `date` and `title_de`.
#' - `"filter"`: Allows to provide additional arguments (via the `filter` parameter) that limit the results accordingly. Specifying the sorting order of the
#'   results via the `order` parameter is supported.
#' - `"random"`: Lists the `id_sudd` of five randomly selected referendums, together with their `country_code`.
#' @param order The sorting order of the results. Only relevant if `mode` is either `"by_date"` or `"filter"`.
#' @param filter A list with valid filtering arguments. Only relevant if `mode = "filter"`. The supported filtering arguments include
#' - `territory_name_de`: A string that must be (partially) matched by the referendums' `territory_name_de`. Matching is case-insensitive and no [fuzzy
#'   matching](https://en.wikipedia.org/wiki/Approximate_string_matching) is supported.
#' - `title_de`: A string that must be (partially) matched by the referendums' `title_de`. Matching is case-insensitive and no [fuzzy
#'   matching](https://en.wikipedia.org/wiki/Approximate_string_matching) is supported.
#' - `year_min`: The lower year limit of the referendums' `date`. A positive integer.
#' - `year_max`: The upper year limit of the referendums' `date`. A positive integer.
#' @param use_cache `r pkgsnip::param_label("use_cache")`
#' @param cache_lifespan `r pkgsnip::param_label("cache_lifespan")`
#'
#' @return A [tibble][tibble::tbl_df] containing at least an `id_sudd` column.
#' @family sudd
#' @export
#'
#' @examples
#' # list all referendums by modification date
#' c2d::list_sudd_referendums(mode = "by_mod_date")
#' 
#' # list all referendums whose title matches "AHV"
#' c2d::list_sudd_referendums(mode = "filter",
#'                            filter = list(title_de = "AHV"))
#' 
#' # get sudd.ch referendum data from all referendums from 2020 onwards
#' c2d::list_sudd_referendums(mode = "filter",
#'                            filter = list(year_min = 2020)) |>
#'   c2d::sudd_referendums()
#' 
#' # get sudd.ch referendum data from five randomly picked referendums
#' c2d::list_sudd_referendums(mode = "random") |>
#'   c2d::sudd_referendums()
list_sudd_referendums <- function(mode = c("by_date",
                                           "by_mod_date",
                                           "filter",
                                           "random"),
                                  order = c("ascending",
                                            "descending"),
                                  filter = list(territory_name_de = NULL,
                                                title_de = NULL,
                                                year_min = NULL,
                                                year_max = NULL),
                                  use_cache = TRUE,
                                  cache_lifespan = "1 week") {
  # check args
  mode <- rlang::arg_match(mode)
  order <-
    rlang::arg_match(order) %>%
    dplyr::recode("ascending" = "asc",
                  "descending" = "desc")
  
  # do not cache `mode = "random"`
  if (mode == "random") use_cache <- FALSE
  
  pkgpins::with_cache(expr = {
    
    checkmate::assert_list(filter,
                           names = "unique")
    
    checkmate::assert_subset(names(filter),
                             choices = c("territory_name_de",
                                         "title_de",
                                         "year_min",
                                         "year_max"))
    
    checkmate::assert_string(filter$territory_name_de,
                             null.ok = TRUE)
    checkmate::assert_string(filter$title_de,
                             null.ok = TRUE)
    
    filter$year_min <- checkmate::assert_int(filter$year_min,
                                             lower = sudd_min_year,
                                             upper = sudd_max_year,
                                             null.ok = TRUE,
                                             coerce = TRUE)
    filter$year_max <- checkmate::assert_int(filter$year_max,
                                             lower = filter$year_min %||% sudd_min_year,
                                             upper = sudd_max_year,
                                             null.ok = TRUE,
                                             coerce = TRUE)
    
    is_year_missing <- purrr::map_lgl(c(filter$year_min, filter$year_max), is.null) %>% { !all(.) && any(!.) }
    
    if (is_year_missing) {
      filter$year_min <- filter$year_min %||% sudd_min_year
      filter$year_max <- filter$year_max %||% sudd_max_year
    }
    
    if (mode == "filter" && all(purrr::map_lgl(filter, is.null))) {
      cli::cli_abort("At least one filtering argument must be provided in {.arg filter} when {.arg mode = \"filter\"}.")
    }
    
    names(filter) %<>% dplyr::recode("territory_name_de" = "area",
                                     "title_de" = "topic",
                                     "year_min" = "first",
                                     "year_max" = "last")
    
    # assemble query params
    query <- c(list(mode = mode %>% dplyr::recode("by_date" = "allrefs",
                                                  "by_mod_date" = "moddate"))[mode != "filter"],
               list(sense = order)[mode %in% c("by_date", "filter")],
               filter[mode == "filter"])
    
    # retrieve and parse data
    status_msg <- "Fetching raw HTML data from {.url sudd.ch}..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    html <-
      httr::RETRY(verb = "GET",
                  url = "https://sudd.ch/list.php",
                  query = query,
                  times = 5L) %>%
      xml2::read_html()
    
    status_msg <- "Parsing and tidying raw HTML data..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    if (mode == "random") {
      
      result <-
        html %>%
        rvest::html_elements(css = "main ul li a") %>%
        rvest::html_attr(name = "href") %>%
        stringr::str_extract(pattern = "(?<=id=)[\\w\\d]+") %>%
        tibble::tibble(id_sudd = .)
      
    } else {
      
      rows <-
        html %>%
        rvest::html_element(css = "main table") %>%
        rvest::html_children() %>%
        purrr::map(rvest::html_elements,
                   css = "td")
      
      col_1 <- rows %>% purrr::map(magrittr::extract2, 1L)
      col_2 <- rows %>% purrr::map(magrittr::extract2, 2L)
      col_3 <- rows %>% purrr::map(magrittr::extract2, 3L)
      col_4 <- rows %>% purrr::map(magrittr::extract2, 4L)
      
      result <-
        tibble::tibble(id_sudd = col_4 %>% purrr::map_chr(~ .x %>%
                                                            rvest::html_element(css = "a") %>%
                                                            rvest::html_attr(name = "href") %>%
                                                            stringr::str_extract(pattern = "(?<=[\\?&]id=)[\\w\\d]+")),
                       territory_name_de = col_2 %>% purrr::map_chr(rvest::html_text),
                       !!!(col_3 %>% purrr::map_chr(rvest::html_text) %>% parse_sudd_date_de()),
                       title_de = col_4 %>% purrr::map_chr(rvest::html_text)) %>%
        # add `date`
        dplyr::mutate(date = lubridate::make_date(year = year,
                                                  month = month,
                                                  day = day)) %>%
        dplyr::relocate(date,
                        .before = year)
      
      if (mode == "by_mod_date") {
        
        result %<>%
          tibble::add_column(date_last_edited =
                               col_1 %>%
                               purrr::map_chr(~ .x %>%
                                                rvest::html_element(css = "time") %>%
                                                rvest::html_attr(name = "datetime")) %>%
                               lubridate::as_date()) %>%
          tidyr::fill(date_last_edited,
                      .direction = "down")
      }
    }
    
    result %>%
      # derive vx from `id_sudd`
      dplyr::bind_cols(.$id_sudd %>% purrr::map_dfr(parse_sudd_id)) %>%
      dplyr::mutate(is_past_jurisdiction = !is.na(country_code_historical)) %>%
      dplyr::select(id_sudd,
                    starts_with("country_"),
                    is_past_jurisdiction,
                    everything())
  },
  pkg = this_pkg,
  from_fn = "list_sudd_referendums",
  mode,
  order,
  filter,
  use_cache = use_cache,
  cache_lifespan = cache_lifespan)
}
```

### `sudd_referendums`

NOTES:

-   The `@importFrom rlang :=` directive is to get rid of the R CMD check `no visible global function definition for ‘:=’`, see [this SO
    question](https://stackoverflow.com/questions/58026637/no-visible-global-function-definition-for).

```{r}
#' Get referendum data from [sudd.ch](https://sudd.ch/)
#'
#' Downloads referendum data from [sudd.ch](https://sudd.ch/).
#'
#' # About [sudd.ch](https://sudd.ch/)
#'
#' **sudd** stands for _**Su**chmaschine für **d**irekte **D**emokratie_ (German) and is operated by [Beat Müller](mailto:beat@sudd.ch). Its database content is
#' licensed under [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA
#' 4.0)](https://creativecommons.org/licenses/by-nc-sa/4.0/).
#'
#' @param ids_sudd The referendum identifiers assigned by [sudd.ch](https://sudd.ch/). Either as a character vector or a data frame containing a column
#'   `id_sudd`. `NA`s are ignored.
#' @param use_cache `r pkgsnip::param_label("use_cache")`
#' @param cache_lifespan `r pkgsnip::param_label("cache_lifespan")`
#'
#' @return `r pkgsnip::return_label("data")` The column names are aligned with those of [referendums()] as closely as possible.
#' @family sudd
#' @importFrom rlang :=
#' @export
#'
#' @examples
#' c2d::referendum(id = "5bbc045192a21351232e596f")$id_sudd |> c2d::sudd_referendums()
#' 
#' c2d::referendums(country_code = "AT") |> c2d::sudd_referendums()
sudd_referendums <- function(ids_sudd,
                             use_cache = TRUE,
                             cache_lifespan = "1 week") {
  
  if (purrr::vec_depth(ids_sudd) > 1L) {
    
    if (!("id_sudd" %in% colnames(ids_sudd))) {
      cli::cli_abort(paste0("{.arg ids_sudd} must be either a character vector of valid sudd.ch referendum identifiers or a data frame with a column of such",
                            " named {.var id_sudd}."))
    }
    
    ids_sudd <- ids_sudd$id_sudd
  }
  
  ids_sudd <-
    checkmate::assert_character(ids_sudd,
                                all.missing = FALSE) %>%
    magrittr::extract(!is.na(.))
  
  pkgpins::with_cache(expr = {
    
    ids_sudd %>%
      cli::cli_progress_along(name = "Scraping referendum data from sudd.ch") %>%
      purrr::map_dfr(~ sudd_referendum(ids_sudd[.x])) %>%
      # properly parse `date`
      dplyr::bind_cols(.$date %>% purrr::map_dfr(parse_sudd_date)) %>%
      dplyr::mutate(date = lubridate::make_date(year = year,
                                                month = month,
                                                day = day)) %>%
      # add `id_sudd`
      tibble::add_column(id_sudd = ids_sudd,
                         .before = 1L) %>%
      # derive vx from `id_sudd`
      dplyr::bind_cols(ids_sudd %>% purrr::map_dfr(parse_sudd_id)) %>%
      # reorder columns
      dplyr::relocate(id_sudd,
                      country_code,
                      country_code_historical,
                      country_name,
                      territory_name_de,
                      any_of(c("territory_type_de",
                               "date",
                               "year",
                               "month",
                               "day",
                               "title_de",
                               "question_type_de",
                               "types",
                               "result_de",
                               "result_status_de",
                               "adoption_requirements_de",
                               "electorate_total",
                               "electorate_abroad",
                               "polling_cards",
                               "votes_total",
                               "votes_empty",
                               "votes_void",
                               "votes_invalid",
                               "votes_valid",
                               "votes_yes",
                               "votes_no")),
                      matches("^votes_(option_\\d+|(counter_)?proposal)(_(total|empty|void|invalid|valid|yes|no))?$"),
                      any_of("votes_option_none"),
                      matches("^$"),
                      any_of(c("subterritories",
                               "subterritories_yes",
                               "subterritories_no",
                               "files",
                               "remarks",
                               "sources",
                               "ids_sudd_simultaneous",
                               "date_last_edited")))
  },
  pkg = this_pkg,
  from_fn = "sudd_referendums",
  ids_sudd,
  use_cache = use_cache,
  cache_lifespan = cache_lifespan)
}
```

# TEMP

```{r, purl = FALSE}
data_c2d_aargau <-
  readxl::read_excel("/home/salim/Arbeit/ZDA/Git/zdaarau/rpkgs/c2d/19-AG-Abstimmungen-1888-1971.xlsx") %>%
  dplyr::mutate(date = lubridate::dmy(Datum),
                title_en = deeplr::translate2(text = Vorlage,
                                              auth_key = Sys.getenv("DEEPL_TOKEN"),
                                              target_lang = "EN",
                                              source_lang = "DE",
                                              preserve_formatting = TRUE)) %>%
  dplyr::select(date,
                title_de = Vorlage,
                title_en,
                electorate_total = Stimmberechtigte,
                votes_total = "Eingegangene Stimmzettel",
                votes_yes = "Anzahl JA-Stimmen",
                votes_no = "Anzahl NEIN-Stimmen",
                votes_empty = Leer)
```
