---
editor_options:
  chunk_output_type: console
---

# NOTES

The C2D Database offers a [privately documented](https://github.com/ccmdesign/c2d-app/blob/master/docs/services.md) API available under `services.c2d.ch` with
the following "endpoints":

-   `referendums`: get referendum data

    Data on individual referendums can be retrieved under `referendums/ID` where `ID` stands for the referendum's unique identifier `oid` (which corresponds to
    the column `id` in the data returned by the `referendums()` function of this package).

    It supports the following URL parameters:

    -   `mode`: the operation mode; one of `stream`, `count` or `search`
    -   `term` the search term used for `mode=search`; note that only the `title$en` field will be searched
    -   `format`: the data format to be returned when `mode=stream`; one of `json` or `csv`
    -   `filter`: a valid [JSON query filter document](https://docs.mongodb.com/manual/core/document/#query-filter-documents) to customize queries in the
        underlying MongoDB collection; needs to be Base64-encoded; there are various [query
        operators](https://docs.mongodb.com/manual/reference/operator/query/) available to build complex queries

    The following values are used to denote empty values in the returned data:

    -   In integer fields:

        -   `-1L` (means "information not available or nonexistent")
        -   `-2L` ([means "information not given"](https://github.com/ccmdesign/c2d-app/issues/13#issuecomment-802466615))

    -   In character fields:

        -   `""`
        -   `"-1"`
        -   `"unknown"` (only for certain fields)
        -   `"-2"`
        -   `"not provided"` (only for certain fields)

    -   In array fields:

        -   (Named) `list()` in array fields

-   The returned JSON data has between 22 and 26 fields. Fields that are not always present include:

    -   `archive`
    -   `canton`
    -   `municipality`
    -   `number`

-   `referendums/stats`: get the number of referendums

    It accepts the following URL parameter:

    -   `filter`: a valid [JSON query filter document](https://docs.mongodb.com/manual/core/document/#query-filter-documents) to customize queries in the
        underlying MongoDB collection; needs to be Base64-encoded; there are various [query
        operators](https://docs.mongodb.com/manual/reference/operator/query/) available to build complex queries

-   `s3_objects`: retrieve a file stored on the C2D [Amazon S3 bucket](https://en.wikipedia.org/wiki/Amazon_S3#Design)

    It's not a real REST API endpoint but rather a URL redirection (I guess). It expects an object key to be appended like this:

    ``` {.http}
    GET https://services.c2d.ch/s3_objects/referendum_5f859fafd1291cc3961f1bc2_0002.pdf
    ```

-   `states`: get the first 10 sub-national states that match the query

    It accepts the following URL parameters to customize the query:

    -   `country`: limits the results to a specific country code
    -   `term`: limits the result to states matching this search term

-   `health`: check API status

# INTERNAL

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

Cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 "content-disposition",
                                 "items",
                                 "sudd_prefix",
                                 "votes"))
```

## Package load/unload

```{r}
.onLoad <- function(libname, pkgname) {
  pkgpins::clear(pkg = pkgname,
                 max_age = getOption("c2d.max_cache_lifespan",
                                     default = "30 days"))
}

.onUnload <- function(libpath) {
  pkgpins::deregister(pkg = pkg)
}
```

## Constants

```{r}
pkg <- utils::packageName()
```

### Mandatory data fields

Fields names as returned by the `referendums` API endpoint.

```{r}
required_fields <- c("_id",
                     "country_name",
                     "created_on",
                     "level",
                     "title",
                     "total_electorate",
                     "votes_no",
                     "votes_yes")
```

## Functions

### Get httr config

Since the C2D API server doesn't provide the [intermediate *R3*
certificate](https://crt.sh/?q=+730c1bdcd85f57ce5dc0bba733e5f1ba5a925b2a771d640a26f7a454224dad3b) (issued by Let's Encrypt) and [curl doesn't support *Authority
Information Access* yet](https://github.com/curl/curl/issues/2793) to automatically discover it, we have to manually specify it. Thus, the certificate is
shipped with this package (found under `certs/3479778542.crt`).

The issue has been [reported](https://github.com/ccmdesign/c2d-app/issues/10) to the server operator.

```{r}
httr_config <- function() {
  
  httr::config(cainfo = fs::path_package(package = pkg,
                                         "certs", "3479778542.crt"))
}
```

### Assemble MongoDB query filter document

NOTE: `date` is not stored as an actual [MongoDB `Date` type](https://docs.mongodb.com/manual/reference/bson-types/#std-label-document-bson-type-date) in the
database, so we can't filter on it. It has [been requested](https://github.com/ccmdesign/c2d-app/issues/20) to change this upstream.

```{r}
#' Assemble MongoDB query filter document
#'
#' @param country_code The `country_code`(s) to be included. A character vector.
#' @param subnational_entity_name The `subnational_entity_name`(s) to be included. A character vector.
#' @param municipality The `municipality`(s) to be included. A character vector.
#' @param level The `level`(s) to be included. A character vector.
#' @param type The `type`(s) to be included. A character vector.
#' @param date The `date`(s) to be included. A character vector.
#' @param is_draft `TRUE` means to include only referendum entries with _draft_ status, `FALSE` to include only normal entries. Set to `NULL` in order to
#'   include both draft and normal entries.
#' @param date_time_created_min The minimum `date_time_created` to be included. A [date][base::Date], a [datetime][base::DateTimeClasses], or something
#'   coercible to (like `"2006-01-02"` or `"2006-01-02T15:04:05"`).
#' @param date_time_created_max The maximum `date_time_created` to be included. A [date][base::Date], a [datetime][base::DateTimeClasses], or something
#'   coercible to (like `"2006-01-02"` or `"2006-01-02T15:04:05"`).
#' @param query_filter A valid [MongoDB JSON query filter document](https://docs.mongodb.com/manual/core/document/#query-filter-documents) which allows for
#'   maximum control over what data is included. This takes precedence over all the other parameters, i.e. if `query_filter` is provided, all the other
#'   parameters are ignored.
#' @param base64_encode Whether or not to [Base64](https://en.wikipedia.org/wiki/Base64)-encode the resulting query filter document. Note that the
#'   `query_filter` argument provided to other functions of this package must be Base64-encoded.
#'
#' @return A character scalar containing a valid [MongoDB JSON query filter document](https://docs.mongodb.com/manual/core/document/#query-filter-documents),
#'   [Base64](https://en.wikipedia.org/wiki/Base64)-encoded if `base64_encode = TRUE`.
assemble_query_filter <- function(country_code = NULL,
                                  subnational_entity_name = NULL,
                                  municipality = NULL,
                                  level = NULL,
                                  type = NULL,
                                  date = NULL,
                                  is_draft = NULL,
                                  date_time_created_min = NULL,
                                  date_time_created_max = NULL,
                                  query_filter = NULL,
                                  base64_encode = TRUE) {
  
  # assemble JSON query filter document if `query_filter` is not provided
  if (is.null(query_filter)) {
    
    query_filter <-
      list(country_code = query_filter_in(country_code),
           canton = query_filter_in(subnational_entity_name),
           municipality = query_filter_in(municipality),
           level =
             level %>%
             purrr::when(is.null(.) ~ .,
                         ~ dplyr::recode(., "subnational" = "sub-national") %>% stringr::str_to_sentence()) %>%
             query_filter_in(),
           institution =
             type %>%
             purrr::when(is.null(.) ~ .,
                         ~ dplyr::recode("citizens' assembly" = "citizen assembly") %>% stringr::str_to_sentence()) %>%
             query_filter_in(),
           date = query_filter_in(date),
           draft = checkmate::assert_flag(is_draft,
                                          null.ok = TRUE),
           created_on = query_filter_date(min = date_time_created_min,
                                          max = date_time_created_max)) %>%
      # remove `NULL` elements
      purrr::compact() %>%
      # convert to base64-encoded JSON
      jsonlite::toJSON(POSIXt = "ISO8601",
                       auto_unbox = TRUE,
                       digits = NA,
                       pretty = FALSE)
  }
  
  query_filter %>% purrr::when(base64_encode ~ jsonlite::base64_enc(.),
                               ~ .)
}
```

### MongoDB query filter operator helpers

#### `$date`

Example query found in the mongolite documentation: <https://jeroen.github.io/mongolite/query-data.html#select-by-date>

```{r}
query_filter_date <- function(min,
                              max) {
  
  list(`$gte` = list(`$date` = lubridate::as_datetime(min)) %>% purrr::compact(),
       `$lte` = list(`$date` = lubridate::as_datetime(max)) %>% purrr::compact()) %>%
    purrr::compact()
}
```

#### `$in`

MongoDB documentation: <https://docs.mongodb.com/manual/reference/operator/query/in/#mongodb-query-op.-in>

```{r}
query_filter_in <- function(x) {
  
  x %>% purrr::when(is.null(.) || length(.) == 0L ~ NULL,
                    length(.) == 1 ~ .,
                    ~ list(`$in` = .))
}
```

# Check API health

```{r}
#' Test C2D API availability
#'
#' Checks if the C2D API server is online and operational.
#'
#' @param quiet Whether to suppress printing a warning in case the API is unavailable.
#'
#' @return A logical scalar.
#' @export
is_online <- function(quiet = FALSE) {
  
  result <- FALSE
  response <- rlang::with_handlers(.expr = httr::RETRY(verb = "GET",
                                                       url = "https://services.c2d.ch/health",
                                                       config = httr_config(),
                                                       times = 5L),
                                   error = ~ paste0("Error: ", .x$message))
  
  if (class(response) == "response") {
    
    response %<>% httr::content(as = "parsed",
                                encoding = "UTF-8")
    
    if (response == "OK") {
      result <- TRUE
      
    } else if (checkmate::assert_flag(quiet)) {
      warning(glue::glue("C2D API server responded with '{response}'"),
              call. = FALSE,
              immediate. = TRUE)
    }
  }
  
  result
}
```

# Referendums

## Get data

TODO:

-   [ ] Upstream renamings and recodings as far as possible and subsequently remove them from `referendums()` and `assemble_query_filter()`.

```{r}
#' Get referendum data
#'
#' Downloads the referendum data from the C2D Database.
#'
#' @param use_cache `r pkgsnip::param_label("use_cache")`
#' @param cache_lifespan `r pkgsnip::param_label("cache_lifespan")`
#' @param incl_archive Whether or not to include an `archive` column containing data from an earlier, obsolete state of the C2D database.
#' @inheritParams assemble_query_filter
#'
#' @return `r pkgsnip::return_label("data")`
#' @export
#'
#' @examples
#' \dontrun{
#' # get all referendums (excl. drafts)
#' c2d::referendums()}
#' 
#' # get only referendums in Austria on subnational level
#' c2d::referendums(country_code = "AT",
#'                  level = "subnational")
#' 
#' # provide custom `query_filter` for more complex queries like regex matches
#' # cf. https://docs.mongodb.com/manual/reference/operator/query/regex/
#' c2d::referendums(query_filter = '{"country_code":{"$regex":"A."}}')
referendums <- function(use_cache = TRUE,
                        cache_lifespan = "1 week",
                        incl_archive = FALSE,
                        is_draft = FALSE,
                        country_code = NULL,
                        subnational_entity_name = NULL,
                        municipality = NULL,
                        level = NULL,
                        type = NULL,
                        date = NULL,
                        date_time_created_min = NULL,
                        date_time_created_max = NULL,
                        query_filter = NULL) {
  
  pkgpins::with_cache(.fn = ~ {
    
    # retrieve data
    data <-
      httr::RETRY(verb = "GET",
                  url = "https://services.c2d.ch/referendums",
                  query = list(mode = "stream",
                               format = "json",
                               filter = assemble_query_filter(country_code = country_code,
                                                              subnational_entity_name = subnational_entity_name,
                                                              municipality = municipality,
                                                              level = level,
                                                              type = type,
                                                              date = date,
                                                              is_draft = is_draft,
                                                              date_time_created_min = date_time_created_min,
                                                              date_time_created_max = date_time_created_max,
                                                              query_filter = query_filter)),
                  config = httr_config(),
                  times = 5L) %>%
      httr::content(as = "parsed") %$%
      items %>%
      # wrap all array fields in another list level for subsequent conversion to tibble
      purrr::map(.f = ~ .x %>% purrr::modify_if(.p = ~ length(.x) != 1L,
                                                .f = ~ list(.x))) %>%
      # convert to tibble
      dplyr::bind_rows()
    
    # check data integrity
    ## ensure mandatory fields are never `NA`
    if (data %>%
        dplyr::select(all_of(required_fields)) %>%
        dplyr::filter(dplyr::if_any(.fns = is.na)) %>%
        nrow()) {
      
      rlang::abort(cli::format_error("Mandatory fields detected that contain {.val NA} values. Please debug."))
    }
    
    ## ensure there's always exactly *one* `oid` per row
    ids <- data$`_id` %>% purrr::map(length)
    
    if (length(unique(names(ids))) != 1L ||
        !"$oid" %in% unique(names(ids)) ||
        any(purrr::flatten_int(unique(ids))) != 1L) {
      
      rlang::abort(cli::format_error("Unexpected ID fields detected. Please debug."))
    }
    
    ## ensure `oid`s are unique
    if (data$`_id` %>%
        purrr::flatten_chr() %>%
        unique() %>%
        length() %>%
        magrittr::equals(nrow(data)) %>%
        magrittr::not()) {
      
      rlang::abort(cli::format_error("Duplicated {.var oid}s detected. Please debug."))
    }
    
    ## ensure `country_codes`s are valid
    invalid_country_codes <- data$country_code[!(data$country_code %in% countrycode::codelist$iso2c)]
    
    if (length(invalid_country_codes)) {
      rlang::abort(cli::format_error("Unknown {.var country_code}s detected. Please debug."))
    }
    
    # tidy data
    data %<>%
      # unnest `context`, `categories` and `title` (no technical need to be nested)
      tidyr::unnest_wider(col = context) %>%
      tidyr::unnest_wider(col = categories) %>%
      tidyr::unnest_wider(col = title,
                          names_sep = "_") %>%
      # rename variables (since the MongoDB-based API doesn't demand a schema, we can't use `dplyr::rename()`)
      magrittr::set_names(names(.) %>% dplyr::recode("created_on" = "date_time_created",
                                                     "legal_act_type" = "has_urgent_legal_basis",
                                                     "_id" = "id",
                                                     "number" = "id_official",
                                                     "draft" = "is_draft",
                                                     "canton" = "subnational_entity_name",
                                                     "total_electorate" = "electorate_total",
                                                     "citizens_abroad" = "electorate_abroad",
                                                     "votes_per_canton" = "votes_per_subterritory",
                                                     "national_council_yes" = "lower_house_yes",
                                                     "national_council_no" = "lower_house_no",
                                                     "national_council_abstentions" = "lower_house_abstentions",
                                                     "states_council_yes" = "upper_house_yes",
                                                     "states_council_no" = "upper_house_no",
                                                     "states_council_abstentions" = "upper_house_abstentions",
                                                     "recommendation" = "position_government",
                                                     "institution" = "type",
                                                     "vote_result_status" = "is_binding",
                                                     "counter_proposal" = "is_counter_proposal",
                                                     "official_status" = "legal_basis_type",
                                                     "author_of_the_vote_object" = "object_author",
                                                     "hierarchy_of_the_legal_norm" = "object_legal_level",
                                                     "vote_object" = "object_type",
                                                     "vote_trigger_actor" = "trigger_actor",
                                                     "vote_trigger_state_level" = "trigger_state_level",
                                                     "vote_trigger_number" = "trigger_threshold",
                                                     "vote_trigger_time" = "trigger_time_limit",
                                                     "vote_trigger" = "trigger_type")) %>%
      # create/recode variables
      dplyr::mutate(
        # flatten unnecessarily convoluted list columns
        dplyr::across(c(id,
                        action,
                        tags,
                        any_of(c("excluded_topics",
                                 "special_topics"))),
                      ~ .x %>% purrr::map(unlist)),
        
        # replace empty lists with `NULL` in list columns
        dplyr::across(where(is.list),
                      ~ dplyr::case_when(.x %>% purrr::map_lgl(~ length(.x) == 0L) ~ list(NULL),
                                         TRUE ~ .x)),
        
        # use explicit NA values
        dplyr::across(where(is.integer),
                      ~ dplyr::if_else(.x %in% c(-1L, -2L),
                                       NA_integer_,
                                       .x)),
        dplyr::across(where(is.character),
                      ~ dplyr::if_else(.x %in% c("", "-1", "-2"),
                                       NA_character_,
                                       .x)),
        dplyr::across(any_of(c("states_yes", "states_no")),
                      ~ dplyr::if_else(.x %in% c(-1.0, -2.0),
                                       NA_real_,
                                       .x)),
        result = result %>% dplyr::if_else(. %in% c("unknown", "not provided"),
                                           NA_character_,
                                           .),
        
        # convert values to lowercase where appropriate
        dplyr::across(c(level,
                        result,
                        type,
                        any_of(c("legal_basis_type",
                                 "object_author",
                                 "object_legal_level",
                                 "object_type",
                                 "trigger_actor",
                                 "trigger_state_level",
                                 "trigger_type"))),
                      stringr::str_to_lower),
        # only convert non-abbreviations to lowercase for the following vars
        dplyr::across(.cols = tags,
                      .fns = purrr::map,
                      .f = ~
                        .x %>%
                        stringr::str_split(pattern = "\\s") %>%
                        purrr::map_chr(~ .x %>%
                                         dplyr::if_else(stringr::str_detect(string = .,
                                                                            pattern = "^[^[:lower:]]+$"),
                                                        .,
                                                        stringr::str_to_lower(.)) %>%
                                         paste(collapse = " "))),
        
        # specific recodings
        ## split `id_official` into `id_sudd` (the latter consists of a two-letter country code plus a 6-digit number)
        id_sudd =
          id_official %>%
          dplyr::if_else(stringr::str_detect(string = .,
                                             pattern = "^\\D"),
                         .,
                         NA_character_) %>%
          # everything beyond the 8th char seems to be manually added -> strip!
          stringr::str_sub(end = 8L),
        id_official =
          id_official %>%
          dplyr::if_else(stringr::str_detect(string = .,
                                             pattern = "^\\D"),
                         NA_character_,
                         .),
        ## binary (dummies)
        dplyr::across(any_of("position_government"),
                      ~ dplyr::case_when(.x == "Acceptance" ~ "yes",
                                         .x == "Rejection" ~ "no",
                                         TRUE ~ NA_character_)),
        dplyr::across(any_of("is_binding"),
                      ~ dplyr::case_when(.x == "Binding" ~ TRUE,
                                         .x == "Non-binding" ~ FALSE,
                                         TRUE ~ NA)),
        dplyr::across(any_of("is_counter_proposal"),
                      ~ dplyr::case_when(.x == "Yes" ~ TRUE,
                                         .x == "No" ~ FALSE,
                                         TRUE ~ NA)),
        dplyr::across(any_of("has_urgent_legal_basis"),
                      ~ dplyr::case_when(.x == "Urgent" ~ TRUE,
                                         .x == "Normal" ~ FALSE,
                                         TRUE ~ NA)),
        ## nominal
        id = purrr::flatten_chr(id),
        level = stringr::str_replace(string = level,
                                     pattern = "sub-national",
                                     replacement = "subnational"),
        type = type %>% dplyr::recode("citizen assembly" = "citizens' assembly",
                                      "not provided" = NA_character_),
        dplyr::across(any_of("trigger_actor"),
                      ~ .x %>% dplyr::recode(institution = "other institution")),
        dplyr::across(any_of("object_type"),
                      ~ .x %>% dplyr::recode("legal text (ausformulierter vorschlag)" = "legal text (formulated proposal)",
                                             "legal text (allg. anregung)" = "legal text (general proposal)")),
        ## ordinal
        ## interval
        date_time_created = purrr::flatten_dbl(date_time_created) %>% magrittr::divide_by(1000L) %>% lubridate::as_datetime(),
        files = files %>% purrr::map(~ .x %>%
                                       # harmonize depth (i.e. add list level if necessary)
                                       purrr::when(length(.) == 0L || purrr::vec_depth(.) > 3L ~ .,
                                                   ~ list(.)) %>%
                                       purrr::map(~ .x %>%
                                                    # unnest and restore `date`
                                                    purrr::assign_in(where = "date",
                                                                     value =
                                                                       .$date %>%
                                                                       purrr::flatten_dbl() %>%
                                                                       magrittr::divide_by(1000L) %>%
                                                                       lubridate::as_datetime()) %>%
                                                    # change subvariable names
                                                    magrittr::set_names(names(.) %>% dplyr::recode("date" = "date_time_attached",
                                                                                                   "object_key" = "s3_object_key",
                                                                                                   "size" = "file_size",
                                                                                                   "deleted" = "is_deleted")))),
        
        # variable creations
        url_sudd = dplyr::if_else(!is.na(id_sudd),
                                  paste0("https://sudd.ch/event.php?id=", id_sudd),
                                  NA_character_),
        url_swissvotes = dplyr::if_else(country_code == "CH" & level == "national",
                                        paste0("https://swissvotes.ch/vote/", id_official),
                                        NA_character_)
      ) %>%
      
      # reorder columns
      dplyr::relocate(id,
                      id_official,
                      id_sudd,
                      country_code,
                      country_name,
                      subnational_entity_name,
                      municipality,
                      level,
                      date,
                      title_de,
                      title_fr,
                      title_en,
                      committee_name,
                      result,
                      any_of("states_yes"),
                      any_of("states_no"),
                      electorate_total,
                      electorate_abroad,
                      any_of("votes_yes"),
                      any_of("votes_no"),
                      any_of("votes_empty"),
                      any_of("votes_invalid"),
                      any_of("votes_per_subterritory"),
                      any_of("lower_house_yes"),
                      any_of("lower_house_no"),
                      any_of("lower_house_abstentions"),
                      any_of("upper_house_yes"),
                      any_of("upper_house_no"),
                      any_of("upper_house_abstentions"),
                      any_of("position_government"),
                      tags,
                      remarks,
                      files,
                      url_sudd,
                      url_swissvotes,
                      is_draft,
                      date_time_created,
                      archive,
                      type,
                      any_of("object_type"),
                      any_of("object_author"),
                      any_of("object_legal_level"),
                      any_of("legal_basis_type"),
                      any_of("has_urgent_legal_basis"),
                      any_of("degree_of_revision"),
                      any_of("is_binding"),
                      any_of("is_counter_proposal"),
                      any_of("vote_venue"),
                      starts_with("trigger_"),
                      any_of("turnout_quorum"),
                      any_of("decision_quorum"),
                      any_of("referendum_text_options"),
                      any_of("institutional_precondition"),
                      any_of("institutional_precondition_decision"),
                      any_of("institutional_precondition_decision_actor"),
                      any_of("action"),
                      any_of("special_topics"),
                      any_of("excluded_topics")) %>%
      purrr::when(incl_archive ~ .,
                  ~ dplyr::select(.data = ., -archive))
    
    # correct known errors
    ## `id_sudd`
    data$id_sudd[data$country_code == "AZ" & data$id_sudd == "az021009"] <- "az022009"
    data$id_sudd[data$country_code == "BS" & data$id_sudd == "bs021002"] <- "bs022002"
    data$id_sudd[data$country_code == "MG" & data$id_sudd == "md011972"] <- "mg011972"
    data$id_sudd[data$country_code == "MG" & data$id_sudd == "md011975"] <- "mg011975"
    data$id_sudd[data$country_code == "MG" & data$id_sudd == "md011992"] <- "mg011992"
    data$id_sudd[data$country_code == "MG" & data$id_sudd == "md011995"] <- "mg011995"
    data$id_sudd[data$country_code == "MG" & data$id_sudd == "md011998"] <- "mg011998"
    data$id_sudd[data$country_code == "MG" & data$id_sudd == "md012007"] <- "mg012007"
    data$id_sudd[data$country_code == "MG" & data$id_sudd == "md012010"] <- "mg012010"
    data$id_sudd[data$country_code == "MH" & data$id_sudd == "mh00578"] <- "mh011979"
    data$id_sudd[data$country_code == "MW" & data$id_sudd == "mw012003"] <- "mw011993"
    data$id_sudd[data$country_code == "EC" & data$id_sudd == "ec031993"] <- "ec031994"
    data$id_sudd[data$country_code == "EC" & data$id_sudd == "ec021006"] <- "ec022006"
    data$id_sudd[data$country_code == "GQ" & data$id_sudd == "gq012968"] <- "gq011968"
    data$id_sudd[data$country_code == "GT" & data$id_sudd == "gt011998"] <- "gt011999"
    data$id_sudd[data$country_code == "GT" & data$id_sudd == "gt021998"] <- "gt021999"
    data$id_sudd[data$country_code == "GT" & data$id_sudd == "gt031998"] <- "gt031999"
    data$id_sudd[data$country_code == "LI" & data$id_sudd == "li021920"] <- "li021930"
    data$id_sudd[data$country_code == "LT" & data$id_sudd == "lt031993"] <- "lt031994"
    data$id_sudd[data$country_code == "NF" & data$id_sudd == "nf011980"] <- "nf011979"
    data$id_sudd[data$country_code == "TV" & data$id_sudd == "tv011994"] <- "tv011974"
    data$id_sudd[data$country_code == "UY" & data$id_sudd == "uy011918"] <- "uy011917"
    data$id_sudd[data$country_code == "YE" & data$id_sudd == "ye012991"] <- "ye011991"
    # data$id_sudd[data$country_code == "" & data$id_sudd == ""] <- ""
    # data$id_sudd[data$country_code == "" & data$id_sudd == ""] <- ""
    # data$id_sudd[data$country_code == "" & data$id_sudd == ""] <- ""
    # data$id_sudd[data$country_code == "" & data$id_sudd == ""] <- ""
    # data$id_sudd[data$country_code == "" & data$id_sudd == ""] <- ""
    # data$id_sudd[data$country_code == "" & data$id_sudd == ""] <- ""
    # data$id_sudd[data$country_code == "" & data$id_sudd == ""] <- ""
    # data$id_sudd[data$country_code == "" & data$id_sudd == ""] <- ""
    # data$id_sudd[data$country_code == "" & data$id_sudd == ""] <- ""
    # data$id_sudd[data$country_code == "" & data$id_sudd == ""] <- ""
    # data$id_sudd[data$country_code == "" & data$id_sudd == ""] <- ""
    # data$id_sudd[data$country_code == "" & data$id_sudd == ""] <- ""
    
    # return data
    data
  },
  .use_cache = use_cache,
  .cache_lifespan = cache_lifespan,
  .pkg = pkg)
}
```

## Count

```{r}
#' Count number of referendums
#'
#' Counts the number of referendums in the C2D Database.
#'
#' @inheritParams assemble_query_filter
#'
#' @return A named list with `level` as names and referendum counts as values.
#' @export
#'
#' @examples
#' # the whole database (excl. drafts)
#' c2d::count_referendums()
#' 
#' # only Swiss and Austrian referendums
#' c2d::count_referendums(country_code = c("CH", "AT"))
#' 
#' # only Swiss referendums between 2020 and 2021
#' c2d::count_referendums(country_code = "CH",
#'                        date_time_created_min = "2020-01-01",
#'                        date_time_created_max = "2021-01-01")
count_referendums <- function(is_draft = FALSE,
                              country_code = NULL,
                              subnational_entity_name = NULL,
                              municipality = NULL,
                              level = NULL,
                              type = NULL,
                              date = NULL,
                              date_time_created_min = NULL,
                              date_time_created_max = NULL,
                              query_filter = NULL) {
  httr::RETRY(verb = "GET",
              url = "https://services.c2d.ch/referendums/stats",
              query = list(filter = assemble_query_filter(country_code = country_code,
                                                          subnational_entity_name = subnational_entity_name,
                                                          municipality = municipality,
                                                          level = level,
                                                          type = type,
                                                          date = date,
                                                          is_draft = is_draft,
                                                          date_time_created_min = date_time_created_min,
                                                          date_time_created_max = date_time_created_max,
                                                          query_filter = query_filter)),
              config = httr_config(),
              times = 5L) %>%
    httr::content(as = "parsed") %$%
    votes %>%
    magrittr::set_names(names(.) %>% dplyr::recode("sub_national" = "subnational"))
}
```

## Search

Currently, the C2D API [only supports searching in the English referendum
title](https://github.com/ccmdesign/c2d-app/blob/master/docs/services.md#3-referendum-routes).

```{r}
#' Search in English referendum titles
#'
#' Allows to use the C2D API's primitive search functionality. The search is not case-sensitive and no [fuzzy
#' search](https://en.wikipedia.org/wiki/Approximate_string_matching) is performed (i.e. only exact matches are returned).
#'
#' Note that this function is probably not of much use since it doesn't return any additional information about the matched referendums but only the English
#' titles.
#'
#' @param term The Search term. A character scalar.
#'
#' @return A character vector of English referendum titles matching the search `term`.
#' @export
#'
#' @examples
#' c2d::search_referendums("freedom")
search_referendums <- function(term) {
  
  httr::RETRY(verb = "GET",
              url = "https://services.c2d.ch/referendums",
              query = list(mode = "search",
                           term = checkmate::assert_string(term)),
              config = httr_config(),
              times = 5L) %>%
    httr::content(as = "parsed") %$%
    items %>%
    purrr::flatten_chr() 
}
```

## Download file attachment

```{r}
#' Download file attachment
#'
#' Downloads a file attachment from the C2D database. The necessary `s3_object_key`s identifying individual files are found in the `files` list column returned
#' by [referendums()].
#'
#' @param s3_object_key The key uniquely identifying the file in the C2D [Amazon S3 bucket](https://en.wikipedia.org/wiki/Amazon_S3#Design). A character scalar.
#' @param path The path where the downloaded file is written to. If a directory, the original filename returned by the C2D services API will be used.
#'
#' @return A [response object][httr::response], invisibly.
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' \dontrun{
#' # get all file object keys...
#' c2d::referendums() %$%
#'   files %>%
#'   purrr::map_depth(2L, purrr::pluck, "object_key") %>%
#'   purrr::flatten() %>%
#'   purrr::flatten_chr() %>%
#'   # ...select first one...
#'   dplyr::first() %>%
#'   # ...and download the corresponding file to the current working dir
#'   c2d::download_file_attachment()}
download_file_attachment <- function(s3_object_key,
                                     path = ".") {
  if (fs::dir_exists(path)) {
    checkmate::assert_directory(path,
                                access = "rw")
    use_original_filename <- TRUE
  } else {
    checkmate::assert_path_for_output(path,
                                      overwrite = TRUE)
    use_original_filename <- FALSE
  }
  
  temp_path <- fs::file_temp()
  
  response <- httr::RETRY(verb = "GET",
                          url = paste0("https://services.c2d.ch/s3_objects/", s3_object_key),
                          config = httr_config(),
                          httr::write_disk(path = temp_path),
                          times = 5L)
  
  if (use_original_filename) {
    
    final_path <-
      response %>%
      httr::headers() %$%
      `content-disposition` %>%
      stringr::str_extract(pattern = "(?<=filename=\").+?(?=\")") %>%
      fs::path(path, .)
    
  } else {
    final_path <- path
  }
  
  fs::file_move(path = temp_path,
                new_path = final_path)
  
  invisible(response)
}
```

## Validate

This function performs various data validation steps to ensure there are no errors in the database.

WIP

```{r}
validate_referendums <- function(data,
                                 check_sudd_prefix = TRUE) {
  
  if (checkmate::assert_flag(check_sudd_prefix)) {
    
    # define allowed exceptions
    allowed_exceptions <- tibble::tribble(
      ~country_code, ~sudd_prefix,
      # Curaçao
      "CW", "an",
      # Szeklerland, cf. https://sudd.ch/event.php?id=hu042008
      "RO", "hu"
    )
    
    # assemble target country codes
    country_codes <- data$country_code %>% as.list()
    
    for (country_code in allowed_exceptions$country_code) {
      
      additional_country_codes <- allowed_exceptions %>% dplyr::filter(country_code == !!country_code) %$% sudd_prefix %>% stringr::str_to_upper()
      i_country_codes <- country_codes %>% purrr::map_lgl(~ country_code == .x) %>% which()
      
      for (i in i_country_codes) {
        country_codes[[i]] <- unique(c(country_codes[[i]], additional_country_codes))
      }
    }
    
    # add dummy indicating if target country codes match
    data$matches_sudd_prefix <-
      data$id_sudd %>%
      stringr::str_extract(pattern = "^..") %>%
      stringr::str_to_upper() %>%
      purrr::map2_lgl(.y = country_codes,
                      .f = ~ .x %in% .y)
    
    data$matches_sudd_prefix[is.na(data$id_sudd)] <- NA
  }
  
  data
}
```
